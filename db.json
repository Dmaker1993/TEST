{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-melody/source/melody-favicon.ico","path":"melody-favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/css/404.styl","path":"css/404.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/copy.js","path":"js/copy.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/fireworks.js","path":"js/fireworks.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/head.js","path":"js/head.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/katex.js","path":"js/katex.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/scroll.js","path":"js/scroll.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/transition.js","path":"js/transition.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/categories/index.md","hash":"cc7b650d9e112a6d1f4c40d26f0d67ea5324d2f4","modified":1640261397023},{"_id":"source/404/index.md","hash":"f175723264bec7e53716d540c3d623988d46b84a","modified":1640247243484},{"_id":"source/_posts/RabbitMQ的死信队列和延时队列.md","hash":"7735381f39f7d3c704347d8fd1fa53f0969de23f","modified":1640505740052},{"_id":"source/_posts/RabbitMQ基础与集群实战.md","hash":"909ae5e20f44f09a850c3f52cbc7fca0f616ce73","modified":1640505550135},{"_id":"source/tags/index.md","hash":"a30206372de1a40108bbf4ef694db5acc6c4d88f","modified":1640260395638},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1640238607766},{"_id":"node_modules/hexo-theme-melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640243133268},{"_id":"node_modules/hexo-theme-melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640243133238},{"_id":"node_modules/hexo-theme-melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640243133262},{"_id":"node_modules/hexo-theme-melody/CHANGELOG.md","hash":"74651f2362b7beb79f502d0c352827b8b29193f4","modified":1640243133252},{"_id":"node_modules/hexo-theme-melody/README.md","hash":"9239744d3bcd86c2082809278d562c7de1595eff","modified":1640243133254},{"_id":"node_modules/hexo-theme-melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1640243133270},{"_id":"node_modules/hexo-theme-melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1640243133236},{"_id":"node_modules/hexo-theme-melody/scripts/replace-config.js","hash":"a8e9a18b2798d3c694a3efa8036f82046c3eb037","modified":1640243133246},{"_id":"node_modules/hexo-theme-melody/package.json","hash":"4ed77eb7e9796c0872ea7f556aaf39e94a329955","modified":1640243133252},{"_id":"node_modules/hexo-theme-melody/_config.yml","hash":"a63149d645bb130b7102996980594dde8cde39b2","modified":1640243133270},{"_id":"node_modules/hexo-theme-melody/FAQ.md","hash":"5984dd5335f8ead64f14d3885de5cc5ef09dfff8","modified":1640243133254},{"_id":"node_modules/hexo-theme-melody/LICENSE","hash":"dbbc2e6e42affa5ac962826f01bffa8c7aecd6b8","modified":1640243132875},{"_id":"node_modules/hexo-theme-melody/languages/en.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1640243133270},{"_id":"node_modules/hexo-theme-melody/languages/default.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1640243133270},{"_id":"node_modules/hexo-theme-melody/layout/404.pug","hash":"0ad5d251ba70edad5c04a45d13ca6a8db3bf7b42","modified":1640243133255},{"_id":"node_modules/hexo-theme-melody/source/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1640243132880},{"_id":"node_modules/hexo-theme-melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1640243133257},{"_id":"node_modules/hexo-theme-melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1640243133258},{"_id":"node_modules/hexo-theme-melody/languages/zh-Hans.yml","hash":"68c5794ec57227daec2e3afe2c5d502fa0a7092a","modified":1640243133271},{"_id":"node_modules/hexo-theme-melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1640243133260},{"_id":"node_modules/hexo-theme-melody/layout/page.pug","hash":"09c1c7c4ffff114c886b097ec82e046399ab79e1","modified":1640243133262},{"_id":"node_modules/hexo-theme-melody/source/css/index.styl","hash":"2053ba56db707e7a03796ba59f77103765b02353","modified":1640243133267},{"_id":"node_modules/hexo-theme-melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1640243133263},{"_id":"node_modules/hexo-theme-melody/source/css/404.styl","hash":"b7a0f8b23cb137b1a6c4fa0f9a35e06e93065b2c","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1640243133259},{"_id":"node_modules/hexo-theme-melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1640243133264},{"_id":"node_modules/hexo-theme-melody/layout/post.pug","hash":"436bb1b7d14e29cba8010d3ea14df19681fbb5fe","modified":1640243133262},{"_id":"node_modules/hexo-theme-melody/source/css/var.styl","hash":"259feee66bf9c326e781bb63a177627dbe3eb539","modified":1640243133268},{"_id":"node_modules/hexo-theme-melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1640243133268},{"_id":"node_modules/hexo-theme-melody/source/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1640243133245},{"_id":"node_modules/hexo-theme-melody/source/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1640243132884},{"_id":"node_modules/hexo-theme-melody/source/js/fireworks.js","hash":"17d5770d46d9b531b675b129835561146290af83","modified":1640243133236},{"_id":"node_modules/hexo-theme-melody/source/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1640243133227},{"_id":"node_modules/hexo-theme-melody/source/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1640243133247},{"_id":"node_modules/hexo-theme-melody/source/js/scroll.js","hash":"fcc20d10c936d49c3f0cd2a97030ecaf64d213c8","modified":1640243133247},{"_id":"node_modules/hexo-theme-melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1640243133248},{"_id":"node_modules/hexo-theme-melody/layout/includes/config.pug","hash":"66e384b1cfe58a57b80f7dff0388bf00bb8bfdf8","modified":1640243133258},{"_id":"node_modules/hexo-theme-melody/source/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1640243133247},{"_id":"node_modules/hexo-theme-melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1640243133259},{"_id":"node_modules/hexo-theme-melody/source/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1640243133254},{"_id":"node_modules/hexo-theme-melody/layout/includes/header.pug","hash":"f440a9741eeacfa62f0a0e7ef470a104f1cb510c","modified":1640243133259},{"_id":"node_modules/hexo-theme-melody/source/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1640243133237},{"_id":"node_modules/hexo-theme-melody/layout/includes/layout.pug","hash":"58856b5048fb64e7dab75a6ae32cc2a0ad94de4f","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/layout/includes/pagination.pug","hash":"fe33a94d90836b767c42654ccc4c4de7d7f227fc","modified":1640243133262},{"_id":"node_modules/hexo-theme-melody/layout/includes/additional-js.pug","hash":"c4ca62466684758d5a26e5866f9ed87b5c9401b8","modified":1640243133256},{"_id":"node_modules/hexo-theme-melody/layout/includes/recent-posts.pug","hash":"128c448f5bab71f59912516edff9d476ff6b8afe","modified":1640243133262},{"_id":"node_modules/hexo-theme-melody/layout/includes/sidebar.pug","hash":"211b8ecfdb7b5dd836c87436def410a52dfa5ecd","modified":1640243133263},{"_id":"node_modules/hexo-theme-melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1640243132878},{"_id":"node_modules/hexo-theme-melody/source/css/_global/index.styl","hash":"2a6195ce7e822362633ebf403c9438b42fa126bb","modified":1640243133267},{"_id":"node_modules/hexo-theme-melody/layout/includes/head.pug","hash":"cdabb5841dc42a58b6e06df9bc4f5acf90bc8419","modified":1640243133259},{"_id":"node_modules/hexo-theme-melody/source/css/_highlight/diff.styl","hash":"ffdfbf088da7bf33899557395abcac0d2bffd67d","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/layout/includes/nav.pug","hash":"3f1fe059784df45f923587b81cc972659ed22e01","modified":1640243133262},{"_id":"node_modules/hexo-theme-melody/source/css/_search/index.styl","hash":"63cae4465ac54b71361c1795206534c7f2e6e5b1","modified":1640243133267},{"_id":"node_modules/hexo-theme-melody/source/css/_search/algolia.styl","hash":"534e5641e3efe2452db95cc25ec8da0111ceadcf","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/source/css/_search/local-search.styl","hash":"d7970b385265fef782cdcaaf4fe68a2217625467","modified":1640243133267},{"_id":"node_modules/hexo-theme-melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1640243133268},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/footer.styl","hash":"ca8c816bdb144503bec7e755344fb0e4e370a7bf","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/head.styl","hash":"73488de3f36369c29ecd5e0be9661bb2b508548c","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1640243132878},{"_id":"node_modules/hexo-theme-melody/source/css/_highlight/highlight.styl","hash":"016c800bf7a0ef6d520e135ab69ef072760483cb","modified":1640243133266},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1640243133267},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/post.styl","hash":"34a421a32abb8003d7d83de53f42639be4e54daf","modified":1640243133268},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/sidebar.styl","hash":"e8315401a6c791d00617c031be01f45df70fe7fd","modified":1640243133268},{"_id":"node_modules/hexo-theme-melody/source/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1640243133246},{"_id":"node_modules/hexo-theme-melody/source/css/_layout/page.styl","hash":"d2f6050bf6ef80523ed9a5a0f058fa5dbaf72ea8","modified":1640243133267},{"_id":"node_modules/hexo-theme-melody/source/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1640243132881},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1640243132884},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1640243133251},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1640243133251},{"_id":"node_modules/hexo-theme-melody/layout/includes/404/layout.pug","hash":"9c7cdf16a9b9b4aa251dba9378a0f00d985101de","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1640243132883},{"_id":"node_modules/hexo-theme-melody/layout/includes/count/busuanzi.pug","hash":"4df5e63ab0113efb93f05ef781b2a7e3f34ba753","modified":1640243133258},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/disqus.pug","hash":"e62b73df92566806bfb170f204295cffd7074215","modified":1640243133258},{"_id":"node_modules/hexo-theme-melody/layout/includes/404/404-nav.pug","hash":"4cd894857bb90fe44b55e852864692ed06588b8e","modified":1640243133255},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1640243133241},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1640243133259},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/index.pug","hash":"74f283727ad2096bd7ad8eb8c6f47b07f7e59b84","modified":1640243133260},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/vssue.pug","hash":"4ee6cea08286cbac2648a6032f73e5f8d2b88380","modified":1640243133265},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/valine.pug","hash":"bc58746ed5c8cc001ad47f1db30e3bdb1aab5fa9","modified":1640243133264},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/gitment.pug","hash":"0b7cd8b0b114876238ca022abda4c1fcdfaee12f","modified":1640243133259},{"_id":"node_modules/hexo-theme-melody/layout/includes/mixins/article-sort.pug","hash":"297b098dc6bba73b76bac4cf6bcd0c29d5dcb2ed","modified":1640243133258},{"_id":"node_modules/hexo-theme-melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1640243133263},{"_id":"node_modules/hexo-theme-melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/layout/includes/search/local-search.pug","hash":"f88070a84379bc06fb385e1193448fae6a8a54e1","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1640243133260},{"_id":"node_modules/hexo-theme-melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1640243133257},{"_id":"node_modules/hexo-theme-melody/layout/includes/share/index.pug","hash":"a2ec6da33cf5fa0ba6c8c38ec3841a0b0003ce98","modified":1640243133260},{"_id":"node_modules/hexo-theme-melody/layout/includes/share/share-js.pug","hash":"e612725ba48711fc119f91c6196287ad13f5a2ba","modified":1640243133263},{"_id":"node_modules/hexo-theme-melody/layout/includes/slide/script.pug","hash":"7ef8aa16e2b3321eb175b7f64434c2fa44eff138","modified":1640243133263},{"_id":"node_modules/hexo-theme-melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1640243133255},{"_id":"node_modules/hexo-theme-melody/layout/includes/third-party/canvas-ribbon.pug","hash":"39a03f188ac415642766b062a80b1b710f3ea609","modified":1640243133258},{"_id":"node_modules/hexo-theme-melody/layout/includes/third-party/katex.pug","hash":"79b2336ad8d921907a5b1badc10ba1651c92843b","modified":1640243133260},{"_id":"node_modules/hexo-theme-melody/layout/includes/slide/layout.pug","hash":"e6963fb20340f60fe9bd2c9dbfff50decee159b3","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/layout/includes/third-party/mathjax.pug","hash":"33b350f9826795cd59d9e277a24accc8a9bc9076","modified":1640243133261},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1640243133238},{"_id":"node_modules/hexo-theme-melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1640243133245},{"_id":"public/categories/index.html","hash":"faafe9d0e34e4a16388b9c3bfd97f285f029c4e2","modified":1640599930053},{"_id":"public/tags/index.html","hash":"60448aada1a6336a9fd00af979e2765a4cf17b5f","modified":1640599930053},{"_id":"public/archives/index.html","hash":"9ab5f487369fec888ce2ce8f4cc4b4eea19a596f","modified":1640597323998},{"_id":"public/archives/2021/index.html","hash":"f9eea9ef4d87e07d228c738050a5cfceb3228416","modified":1640597323998},{"_id":"public/archives/2021/12/index.html","hash":"ee9d913424013592ddf4df7242234619e933dbf4","modified":1640597323998},{"_id":"public/categories/中间件/index.html","hash":"3a96c6813dde023ad1510e2c38ff201f5e4353cf","modified":1640597323998},{"_id":"public/404.html","hash":"5a2313715358016958f87c1a39be707c56aad867","modified":1640597323998},{"_id":"public/index.html","hash":"fe87fb69fc590605a354c8da8c2313f78e17d714","modified":1640597323998},{"_id":"public/tags/中间件/index.html","hash":"285917f89799ffff38374c0203bfe18700a2213c","modified":1640597323998},{"_id":"public/tags/集群/index.html","hash":"bf673113cabc895bc61f7e1054fe809afa3612f6","modified":1640597323998},{"_id":"public/2021/12/26/RabbitMQ的死信队列和延时队列/index.html","hash":"f4c2bb8fe5ca89ae2dfc2fcd6911c597fcba0cda","modified":1640599930053},{"_id":"public/2021/12/23/RabbitMQ基础与集群实战/index.html","hash":"d8f198ea49f38654bc0db4e63e6dfdcfdc8f30a7","modified":1640599930053},{"_id":"public/tags/RabbitMQ/index.html","hash":"d619b19f40937e1b9b9d1ed5972d4dc8dfde5dd8","modified":1640597323998},{"_id":"public/img/avatar.png","hash":"a44601fac9a81dd7e392d05ea5ddc65c96b051df","modified":1640506019836},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1640506019836},{"_id":"public/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1640506019836},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640506019836},{"_id":"public/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1640506019836},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640506019836},{"_id":"public/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1640506019836},{"_id":"public/js/fireworks.js","hash":"17d5770d46d9b531b675b129835561146290af83","modified":1640506019836},{"_id":"public/css/404.css","hash":"712ecbf4ac203ab5f1ea92989c0f0062a3d0aca9","modified":1640506019836},{"_id":"public/js/scroll.js","hash":"fcc20d10c936d49c3f0cd2a97030ecaf64d213c8","modified":1640506019836},{"_id":"public/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1640506019836},{"_id":"public/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1640506019836},{"_id":"public/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1640506019836},{"_id":"public/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1640506019836},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1640506019836},{"_id":"public/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1640506019836},{"_id":"public/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1640506019836},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1640506019836},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1640506019836},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1640506019836},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1640506019836},{"_id":"public/css/index.css","hash":"1b9ffaa1acbba5480139b625d4a5f02b0db2e33e","modified":1640506019836},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1640506019836},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1640506019836},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1640506019836},{"_id":"source/_posts/使用Github和Hexo搭建个人博客系统.md","hash":"b31fb3adddfc51b7e0293762e392c7ceb5672602","modified":1640585799875},{"_id":"public/2021/12/27/使用Github和Hexo搭建个人博客系统/index.html","hash":"a9b63891e416fb7373dfc14dafa755186d4e3577","modified":1640599930053},{"_id":"public/categories/杂记/index.html","hash":"e24ff8bb2303009eb3744ae6a9e34a13f63ffc0d","modified":1640580706312},{"_id":"public/tags/博客系统/index.html","hash":"752bd79210ccd10003d3ee17a33755c7021206f8","modified":1640597323998},{"_id":"public/categories/经验分享/index.html","hash":"4ee7d7e891c0a66ccdef3419c23d1c809b5479fb","modified":1640597323998},{"_id":"public/tags/经验/index.html","hash":"823bc43c67c248793d1cca6ee3ad1a8fc4acc7eb","modified":1640597323998}],"Category":[{"name":"中间件","_id":"ckxmyxe9p0004cjs65fwk0rf4"},{"name":"杂记","_id":"ckxo7ck74000496s6bbshfma8"},{"name":"经验分享","_id":"ckxoafk1f0000l0s62qgi7dvc"}],"Data":[],"Page":[{"title":"categories","date":"2021-12-23T12:09:25.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-12-23 20:09:25\ntype: \"categories\"\n---\n","updated":"2021-12-23T12:09:57.023Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckxmyxe9l0000cjs61c2w8fji","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"404","date":"2019-10-13T07:49:05.000Z","layout":"404","_content":"","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2019-10-13 15:49:05\nlayout: 404\npermalink: /404\n---","updated":"2021-12-23T08:14:03.484Z","path":"/404.html","comments":1,"_id":"ckxmyxe9o0002cjs675tl28dd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-01-04T16:00:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\n---\n","updated":"2021-12-23T11:53:15.638Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckxmyxe9q0006cjs6fi1r2ywa","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"RabbitMQ基础与集群实战","top":false,"date":"2021-12-23T10:10:32.000Z","_content":"# RabbitMQ实战教程\n\n> 视频：https://www.bilibili.com/video/BV1dE411K7MG?from=search&seid=15593601763323732951&spm_id_from=333.337.0.0\n\n## 1.MQ引言\n\n### 1.1 什么是MQ\n\n​\t\t`MQ`(Message Queue)：翻译为`消息队列`，通过典型的`生产者`和`消费者`模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的消费和生产，没有业务逻辑的侵入，轻松的实现系统间的解藕。别名为：`消息中间件`，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。\n\n### 1.2 MQ有哪些\n\n​\t\t当今市面上有很多的消息中间件，如老牌的`ActiveMQ`，`RabbitMQ`，炙手可热的`Kafka`、阿里巴巴自主研发的`RocketMQ`等。\n\n### 1.3 不同MQ的特点\n\n```markdown\n# 1.ActiveMQ\n\tActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。他是一个完全支持JMS规范的消息中间件。丰富的API，多种集群架构模式让ActiveMQ称为老牌的消息中间件，在中小企业颇受欢迎。\n# 2.Kafka\n\tKafka是LinkedIn公司开源的分布式发布-订阅消息中间件，目前属于Apache顶级项目。Kafka的主要特点是基于pull模式来处理消息消费。追求高吞吐量，一开始的目的是用于日志的收集和传输。0.8版本开始支持复制，不支持事物，对消息的丢失、重复、错误没有严格的要求。适合产生大量数据的互联网服务的数据收集业务。\n# 3.RocketMQ\n\tRocketMQ是阿里开源的消息中间件。他是纯java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ的思路起源于Kafka，但并不是Kafka的一个复制，他对消息的可靠传输及事物做了优化，目前的阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流处理、binglog分发等场景。\n# 4.RabbitMQ\n\tRabbitMQ是使用Erlang语言开发的开源消息中间件系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布订阅）、可靠性、安全。AMQP协议更多用在企业内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n```\n\n> RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（延时低）、可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。\n\n## 2.RabbitMQ的引言\n\n### 2.1 RabbitMQ简介\n\n​\t\tRabbitMQ是基于AMQP协议，erlang语言开发，是部署最广泛的开源消息中间件，也是最受欢迎的消息中间件之一。\n\n![image](https://img-blog.csdnimg.cn/681db2b5bf6f486f8dfa258fa90aad53.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# AMQP协议（后续单独讲）\n\tAMQP(Advanced Message Queuing Protocol，高级消息队列协议)，在2003年被提出，在最用于解决金融领域不同平台之间消息传递的交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wrie-level protocol（链接协议）。这时其和JMS的本质差异，AMQP不从api层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。\n\t\t\t\t\t\t\t\tServer\n\t\t\t\t\t+---------------------------+\n\t\t\t\t\t|\t\tVirtual Host\t\t|\n\t\t\t\t\t|\t+--------------------+  |\n   \t+------------+  |\t|\t+-----------+    |\t|\n\t| Publisher  | -------->| Exchange\t|    |  |\n\t| Application|\t|\t|\t+-----+-----+    |  |\n\t+------------+\t|   | \t\t  |\t\t\t |\t|\n\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+\n\t\t\t\t\t|\t|\t+  Message\t+\t |\t|\t|  Consummer  |\n\t\t\t\t\t|\t|\t+\tQueue\t+ --------->| Application |\n\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+\n\t\t\t\t\t|\t+--------------------+\t|\n\t\t\t\t\t+---------------------------+\n```\n\n### 2.2 RabbitMQ的安装\n\n​\t\t本次安装的环境如下：\n\n- 系统：centos8 64位\n- erlang：24.1.7\n- rabbitmq：3.9.11\n\n#### 2.2.1 erlang下载\n\n> 因为rabbitMQ是基于erlang开发的，所以先要下载erlang的包：https://github.com/rabbitmq/erlang-rpm\n>\n> erlang版本和rabbitmq版本对照：https://www.rabbitmq.com/which-erlang.html\n\n![iamge](https://img-blog.csdnimg.cn/bf7aa8f5462148a99f279b03dcb493d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t\t本次开发使用的最新的rabbitmq版本为`3.9.11`，最小支持的erlang版本为23.2，所以本次erlang使用了`24.1.7`版本\n\n![iamge](https://img-blog.csdnimg.cn/889a43dfbe3048b58c0622101762bbad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 2.2.2 RabbitMQ下载\n\n> rabbitmq下载地址：https://www.rabbitmq.com/install-rpm.html#downloads\n\n\n![image](https://img-blog.csdnimg.cn/40404dec0e524d10bb9df1a1d16f9b5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 2.2.3 安装启动\n\n```markdown\n# 1.将rabbitmq相关包上传到linxu服务器中\n\t使用scp命令上传到服务器两个包：\n\tscp ./erlang-24.1.7-1.el8.x86_64.rpm root@10.3.4.5:/root/\n\tscp ./rabbitmq-server-3.9.11-1.el8.noarch.rpm root@10.3.4.5:/root/\n# 2.依次安装erlang、rabbitmq\n\t使用rpm命令进行安装，缺少依赖会进行提示：\n\trpm -ivh erlang-24.1.7-1.el8.x86_64.rpm\n\trpm -ivn rabbitmq-server-3.9.11-1.el8.noarch.rpm\n# 3.修改rabbitmq的配置\n\t使用rpm包的方式安装时，并没有将配置文件也放到指定目录下，所以需要自行创建一个配置文件：/etc/rabbitmq/rabbitmq.conf，具体的配置内容可以参考：https://www.rabbitmq.com/configure.html#config-file-formats。\n\t这里我们需要修改一处：loopback_users=none，表示能够让guest用户进行远程访问。默认情况下，guest用户只能在localhost域名下访问。我们使用的是云服务器，需要使用ip进行访问，所以需要修改这个配置。\n# 4.开启管理控制台插件\n\t其实就是开启rabbitmq的一个插件：rabbitmq_management，可以让我们使用web界面管理rabbitmq。执行命令：rabbitmq-plugins enable rabbitmq_management。该命令还另外开启了2个插件：rabbitmq_management_agent、rabbitmq_web_dispatch。\n# 5.启动/停止/重启rabbitmq服务\n\trabbitmq安装的时候，会将其设置为系统服务，使用系统服务命令即可：\n\tsystemctl start/stop/restart rabbitmq-server.service\n# 6.查看服务状态\n\tsystemctl stauts rabbitmq-server.service\n    结果如下为正常运行中：\n    ● rabbitmq-server.service - RabbitMQ broker\n       Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)\n       Active: active (running) since Sun 2021-12-12 23:56:51 CST; 1 day 9h ago\n      Process: 22710 ExecStop=/usr/sbin/rabbitmqctl shutdown (code=exited, status=0/SUCCESS)\n     Main PID: 22758 (beam.smp)\n        Tasks: 23 (limit: 23722)\n       Memory: 94.8M\n       CGroup: /system.slice/rabbitmq-server.service\n               ├─22758 /usr/lib64/erlang/erts-12.1.5/bin/beam.smp -W w -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 12800>\n               ├─22773 erl_child_setup 32768\n               ├─22827 inet_gethost 4\n               └─22828 inet_gethost 4\n# 7.访问管理界面\n \t默认http后台界面的端口为15672。\n \thttp://10.3.4.5:15672/\n# 8.登陆\n\t账号/密码：guest/guest\n```\n\n## 3.RabbitMQ配置\n\n### 3.1 RabbitMQ管理命令行\n\n```markdown\n# 1.服务管理\n\tsystemctl start/stop/restart rabbitmq-server.service\n# 2.管理命令行\n\t可以用来在不使用web管理端的情况下管理rabbitmq。\n\trabbitmqctl help // 查看所有的命令\n# 3.插件管理\n\trabbitmq-plugins enable/list/disable\n```\n\n### 3.2 web管理介绍\n\n![image](https://img-blog.csdnimg.cn/6a2017fe4a3a4216a594f1d64c3a28e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n- **Connection**：连接，无论是消费者还是生产者，都要与rabbitmq建立连接才能进行消息的生产与消费。\n- **Channels**：通道，建立连接后，消息的投递和获取都是通过通道来进行的。\n- **Exchages**：交换机，用来实现消息的路有。\n- **Queues**：队列，消息存放于该队列中，等待消费，消费之后移除。\n\n#### 3.2.1用户和虚拟主机管理\n\n##### 3.2.1.1 用户\n\n![image](https://img-blog.csdnimg.cn/67b980ab25e24c75b2a6d3c9590c22ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# Tags说明：\n\tAdmin(超级管理员)：登录控制台，查看所有信息，并对用户、策略（policy）进行修改。\n\tMonitoring（监控者）：登陆控制台，查看rabbitmq的节点（进程数、内存、磁盘等使用情况）信息。\n\tPolicymaker（策略制定者）：登陆控制台，对policy进行管理。\n\tManagement（普通管理员）：登陆控制台查看信息。\n\t其他：无法登陆控制台，就是普通的消费者或者生产者。\n```\n\n##### 3.2.1.2 虚拟主机\n\n![image](https://img-blog.csdnimg.cn/b21620fc59f5467ebc4c0402d5e2c0df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 虚拟主机：\n\t为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Host）概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自都有自己的队列、交换机，互不影响。相当于MySQL中的数据库。\n```\n\n##### 3.2.1.3 用户和虚拟主机绑定\n\n![image](https://img-blog.csdnimg.cn/e60681b36bec47b5bba1ebde7ee8d03b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/b4808afbd6e34a8e982624a3f0b02856.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 4.RabbitMQ的Java客户端\n\n### 4.1 AMQP协议回顾\n\n![image](https://img-blog.csdnimg.cn/eb827e01a84b4eea9bddb6dab2947c84.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 4.2 RabbitMQ支持的消息类型\n\n![image](https://img-blog.csdnimg.cn/40d40399960442e9a2d0d5668a6825d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 4.3 引入依赖\n\n```xml\n<dependency>\n  <groupId>com.rabbitmq</groupId>\n  <artifactId>amqp-client</artifactId>\n  <version>5.14.0</version>\n</dependency>\n```\n\n### 4.4 各种模型客户端代码\n\n#### 4.4.1 Direct-直连模式\n\n![image](https://img-blog.csdnimg.cn/2401e687d01347fb9827dffb97b570c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 相关概念：\n\tP：provider，生产者，要发送消息的程序\n\tC：consumer，消费者，消费消息的程序\n\tQueue：队列，存储消息的地方\n```\n\n**Producer：**\n\n```java\n/**\n * direct模式-生产者\n * <p>\n * 直接点对点，也就是生产者将消息发送到队列中，消费者直接从队列中获取\n *\n * @author secret\n * @date 2021/12/14 11:34 AM\n */\npublic class TestProducer {\n    // 定义队列名字\n    public static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 1.创建连接工程\n        ConnectionFactory connectionFactory = new ConnectionFactory();\n        connectionFactory.setHost(\"101.43.52.186\");\n        connectionFactory.setPort(5672);\n        connectionFactory.setVirtualHost(\"/adu\");\n        connectionFactory.setUsername(\"adu\");\n        connectionFactory.setPassword(\"adu\");\n        // 2.创建连接\n        Connection connection = connectionFactory.newConnection();\n        // 3.创建通道\n        Channel channel = connection.createChannel();\n        // 4.声明队列：队列名称，是否持久化，是否独占，额外参数\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 5.向队列发送消息：交换机名称，队列名称，额外参数，消息体\n        channel.basicPublish(\"\", QUEUE_NAME, null, \"hello world\".getBytes(StandardCharsets.UTF_8));\n        // 6.关闭资源\n        channel.close();\n        connection.close();\n    }\n}\n```\n\n**Consumer**:\n\n```java\n/**\n * direct模式-消费者\n *\n * @author secret\n * @date 2021/12/14 11:34 AM\n */\npublic class TestConsumer {\n    public static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 1 创建连接工厂，并设置基础参数\n        ConnectionFactory connectionFactory = new ConnectionFactory();\n        connectionFactory.setHost(\"101.43.52.186\");\n        connectionFactory.setPort(5672);\n        connectionFactory.setVirtualHost(\"/adu\");\n        connectionFactory.setUsername(\"adu\");\n        connectionFactory.setPassword(\"adu\");\n        // 2 创建连接\n        Connection connection = connectionFactory.newConnection();\n        // 3 创建通道\n        Channel channel = connection.createChannel();\n        // 4 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 4 接收消息\n        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) {\n            // 回调方法\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer：\" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n        // 5 关闭资源\n        channel.close();\n        connection.close();\n    }\n}\n```\n\n#### 4.4.2 Work Queues-工作队列\n\n![image](https://img-blog.csdnimg.cn/37c7326912a04ff1baaa25754a61535f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t\tWork Queue也被称为`Task Queue`任务模型。当消息处理比较耗时时，可能消息生产的速度远远超过了消息消费的速度。长此以往，消息就会堆积，此时就可以使用Work Queue模型。让多个消费者绑定同一个队列，共同消费队列中的消息。队列中的消息一旦被消费，就会被删除，因此不会产生重复消费。\n\n```java\n// 提取连接rabbitmq的工具类\npublic class RabbitMQUtil {\n\n    public static Connection getConnection()    {\n        try {\n            // 创建连接工厂\n            ConnectionFactory connectionFactory = new ConnectionFactory();\n            // 设置参数\n            connectionFactory.setHost(\"101.43.52.186\");\n            connectionFactory.setPort(5672);\n            connectionFactory.setVirtualHost(\"/adu\");\n            connectionFactory.setUsername(\"adu\");\n            connectionFactory.setPassword(\"adu\");\n            // 创建连接\n            return connectionFactory.newConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (TimeoutException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static Channel getChannel(Connection connection) {\n        try {\n            return connection.createChannel();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void close(Channel channel, Connection connection) {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (TimeoutException e) {\n                e.printStackTrace();\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**Producer：**\n\n```java\n/**\n * Work Queue模型\n * <p>\n * 工作队列模型，应对的是消费者消费比较慢的情况，多个消费者共同消费同一个队列中的消息。\n *\n * @author secret\n * @date 2021/12/14 2:02 PM\n */\npublic class WorkQueueProducer {\n\n    public static final String QUEUE_NAME = \"work\";\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 发消息\n        for (int i = 0; i < 10; i++) {\n            channel.basicPublish(\"\", QUEUE_NAME, null, (\"hello work queue \" + i).getBytes(StandardCharsets.UTF_8));\n        }\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class WorkQueueConsumer1 {\n    public static final String QUEUE_NAME = \"work\";\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 消费消息\n        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\n和consumer1相同代码，修改消费输出：System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n```\n\n**结果：**\n\n```markdown\n# consumer1 output...\nconsumer1: hello work queue 0\nconsumer1: hello work queue 2\nconsumer1: hello work queue 4\nconsumer1: hello work queue 6\nconsumer1: hello work queue 8\n# consumer2 output...\nconsumer2: hello work queue 1\nconsumer2: hello work queue 3\nconsumer2: hello work queue 5\nconsumer2: hello work queue 7\nconsumer2: hello work queue 9\n```\n\n**总结：**\n\n​\t\t默认情况下，RabbitMQ将按顺序依次将消息发给每个消费者，也就是说每个消费者都会收到相同数量的消息，这种平分消息的方式称为`循环`。\n\n##### 4.4.2.1 消息自动确认机制\n\n​\t\t如果一个消费者在执行任务的过程中宕机，那么在以上代码中，一旦RabbitMQ将将消息传递给消费者，他就会立即标记为删除，那么该消费者中未处理的消息将丢失。我们希望在处理任务的过程中，一个消费者宕机了，能够将任务交给其他消费者处理。这时候我们就可以用到`消息自动确认机制`。也就是说，我们可以在处理完任务之后，再通知RabbitMQ可以删除该任务。\n\n**Producer：**\n\n```java\n// 同上\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class WorkQueueConsumer3 {\n    public static final String QUEUE_NAME = \"work\";\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 每次只能消费一个消息\n        channel.basicQos(1);\n        // 消费消息\n        channel.basicConsume(QUEUE_NAME, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                try {\n                    Thread.sleep(1000); // 模拟处理消息消耗时常\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n                // 手动确认，参数1：消息标记 参数2：是否同时确认多条，false表示每次只能确认一条\n                channel.basicAck(envelope.getDeliveryTag(), false);\n            }\n        });\n    }\n\n}\n// consumer2\npublic class WorkQueueConsumer4 {\n    public static final String QUEUE_NAME = \"work\";\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 限制每次消费1条\n        channel.basicQos(1);\n        // 消费消息，autoAck改为false，表示不自动确认\n        channel.basicConsume(QUEUE_NAME, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                try {\n                    Thread.sleep(1500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n                // 手动确认\n                channel.basicAck(envelope.getDeliveryTag(), false);\n            }\n        });\n    }\n}\n```\n\n**结果：**\n\n```markdown\n# consumer1 output...\nconsumer1: hello work queue 1\nconsumer1: hello work queue 3\nconsumer1: hello work queue 5\nconsumer1: hello work queue 8\nconsumer1: hello work queue 10\nconsumer1: hello work queue 13\nconsumer1: hello work queue 15\nconsumer1: hello work queue 18\n# consumer2 output...\nconsumer1: hello work queue 0\nconsumer1: hello work queue 2\nconsumer1: hello work queue 4\nconsumer1: hello work queue 6\nconsumer1: hello work queue 7\nconsumer1: hello work queue 9\nconsumer1: hello work queue 11\nconsumer1: hello work queue 12\nconsumer1: hello work queue 14\nconsumer1: hello work queue 16\nconsumer1: hello work queue 17\nconsumer1: hello work queue 19\n```\n\n**总结：**\n\n​\t\t实现消息自动确认，需要注意两点：1）设置通道一次只能消费一条消息 2）关闭自动确认，手动确认消息\n\n#### 4.4.3 Publish/Subscribe-发布订阅模式\n\n![image](https://img-blog.csdnimg.cn/610277d029c04fe5a3933cf79f21dcc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 消息流程：\n\t可以有多个消费者，每个消费者都有自己的queue（队列），每个队列都要绑定要exchange（交换机）。\n\t生产者发送的消息只能发送给交换机，交换机来决定发送给哪个队列，生产者无法决定。\n\t交换机把消息发送给绑定过的所有队列，队列的消费者都能拿到消息，实现一个消息被多个消费者消费。\n# 对应交换机类型：fanout\n```\n\n**Proudcer：**\n\n```java\npublic class PublishSubscriptProducer {\n\n    public static final String QUEUE_NAME = \"fanout\";\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明交换机 交换机名称 交换机类型\n        channel.exchangeDeclare(\"logs\", \"fanout\");\n        // 发送消息到交换机\n        channel.basicPublish(\"logs\", \"\", null, \"hello fanout\".getBytes(StandardCharsets.UTF_8));\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class PublishSubscribeConsumer1 {\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明交换机\n        channel.exchangeDeclare(\"logs\", \"fanout\");\n        // 创建临时队列\n        String queue = channel.queueDeclare().getQueue();\n        // 绑定交换机和队列 队列名称 交换机名称 路由\n        channel.queueBind(queue, \"logs\", \"\");\n        // 接收消息\n        channel.basicConsume(queue, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\n同consumer1，输出修改为：System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n```\n\n**结果：**\n\n```markdown\n# consumer1 output...\nconsumer1: hello fanout, type [\nconsumer1: hello fanout\n\n# consumer2 output...\nconsumer2: hello fanout, type [\nconsumer2: hello fanout\n```\n\n#### 4.4.4 Routing-路由模式\n\n​\t\t在发布订阅模式中，一条消息会被所有订阅的的队列消费。但是在某些场景下，我们希望不同的消息类型被不同的队列消费，这时就需要用到Routing模式的direct类型的Exchange。\n\n```markdown\n# 在Direct模式下：\n\t队列与交换机的绑定，不能是任意绑定了，而是需要指定一个Routing Keying，消息发送方在向Exchange发送消息时，也必须指定消息的Routing Key。\n\tExchange也不再把消息交给每一个与之绑定的队列，而是根据消息的Routing Key判断，只有队列的Routing Key和消息的Routing Key完全一致时，才会发送消息。\n```\n\n![image](https://img-blog.csdnimg.cn/8f206f2cfdb34ce89c54e042a92cc21f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 说明：\n\tP：Proudcer，生产者，向Exchange发送消息，同时会指定一个Routing Key。\n\tX：Exchange，交换机，接收生产者发送的消息，然后把消息传递给与routing key完全匹配的队列。\n\tC1：Consumer，消费者，其所在队列指定了需要routing key为error的消息\n\tC2：Consumer，消费者，其所在队列指定了需要routing key为info、error、warning的消息\n```\n\n**Producer：**\n\n```java\npublic class RoutingProducer {\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明交换机\n        channel.exchangeDeclare(\"logs_direct\", \"direct\");\n        // 发送消息\n        String routingKey = \"warning\";\n        channel.basicPublish(\"logs_direct\", routingKey, null, String.format(\"routing for type [%s]\", routingKey).getBytes(StandardCharsets.UTF_8));\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class RoutingConsumer1 {\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(\"logs_direct\", \"direct\");\n        String queue = channel.queueDeclare().getQueue();\n        // consumer1绑定routing key 为info\n        channel.queueBind(queue, \"logs_direct\", \"info\");\n        channel.basicConsume(queue, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\npublic class RoutingConsumer2 {\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(\"logs_direct\", \"direct\");\n        String queue = channel.queueDeclare().getQueue();\n        // consumer1绑定routing key 为info、error、warning\n        channel.queueBind(queue, \"logs_direct\", \"info\");\n        channel.queueBind(queue, \"logs_direct\", \"error\");\n        channel.queueBind(queue, \"logs_direct\", \"warning\");\n        channel.basicConsume(queue, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n```\n\n**结果：**\n\n```markdown\n# 依次发送routing key为info、error、warning结果：\n\n## consummer1\nconsumer1: routing for type [info]\n\n## consumer2\nconsumer1: routing for type [info]\nconsumer1: routing for type [error]\nconsumer1: routing for type [warning]\n```\n\n#### 4.4.5 Topics-主题（动态路由模式）\n\n​\t\t`Topics`模式同`Routing`模式相比，都可以根据Routing Key把消息路由到不同的队列。只不过`Topic`类型的Routing Key可以使用通配符。Routing Key一般是由一个或多个单词组成，多个单词之间以‘,’分割。Exchange的类型为`topic`。\n\n![image](https://img-blog.csdnimg.cn/e1252695c8fd433e9885d1a9e8c4e9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 通配符：\n\t*（star）can substitute for exactly one word。精确匹配一个单词。\n\t#（hash）can substitute for zero or more words。匹配零个、一个或多个单词。\n## 例如：\n\taudit.# ：匹配 audit、audit.irs、audit.irs.corporate 等。\n\taudit.* ：只能匹配 audit.irs。\n```\n\n**Producer：**\n\n```java\npublic class TopicsProducer {\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(\"logs_topics\", \"topic\");\n        String routingKey = \"user.save.now\";\n        channel.basicPublish(\"logs_topics\", routingKey, null, String.format(\"hello topics, routing key : [%s]\", routingKey).getBytes(StandardCharsets.UTF_8));\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class TopicsConsumer1 {\n\n    public static final String EXCHANGE_NAME = \"logs_topics\";\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(EXCHANGE_NAME, \"topic\");\n        String queue = channel.queueDeclare().getQueue();\n        // 队列和交换机绑定的路由为 user.*\n        channel.queueBind(queue, EXCHANGE_NAME, \"user.*\");\n        channel.basicConsume(queue, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\npublic class TopicsConsumer2 {\n\n    public static final String EXCHANGE_NAME = \"logs_topics\";\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(EXCHANGE_NAME, \"topic\");\n        String queue = channel.queueDeclare().getQueue();\n        // 队列和交换机绑定的路由为 user.*\n        channel.queueBind(queue, EXCHANGE_NAME, \"user.#\");\n        channel.basicConsume(queue, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n```\n\n**结果：**\n\n```markdown\n# 依次发送routing key为user.save、user、user.save.now的结果：\n\n## conumser1:\nconsumer1: hello topics, routing key : [user.save]\n\n## consumer2:\nconsumer2: hello topics, routing key : [user.save]\nconsumer2: hello topics, routing key : [user]\nconsumer2: hello topics, routing key : [user.save.now]\n```\n\n## 5.SpringBoot重使用RabbitMQ\n\n### 5.1 搭建环境\n\n#### 5.1.1 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n#### 5.1.2 配置信息\n\n```yaml\nspring:\n  application:\n    name: adu-rabbitmq\n  rabbitmq:\n    host: 10.2.3.4\n    port: 5672\n    username: adu\n    password: adu\n    virtual-host: /adu\n```\n\n### 5.2 各种模型客户端代码\n\n#### 5.2.1 Hello World-直连模型\n\n```java\n/**\n * direct直连模式\n *\n * @author secret\n * @date 2021/12/14 6:30 PM\n */\n@Component\n@RabbitListener(queuesToDeclare = @Queue(value = \"hello\"))\npublic class HelloWorldConsumer {\n\n    @RabbitHandler\n    public void receive(String message) {\n        System.out.println(\"consumer: \" + message);\n    }\n\n}\n```\n\n#### 5.2.2 Work Queue - 工作队列模式\n\n```java\n/**\n * Work Queue模式-消费者\n * <p>\n * 循环模式，每个消费者得到的消息数相同\n *\n * @author secret\n * @date 2021/12/14 6:36 PM\n */\n@Component\npublic class WorkQueueConsumer {\n\n    @RabbitListener(queuesToDeclare = @Queue(value = \"work\", durable = \"true\", exclusive = \"false\", autoDelete = \"false\"))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n    @RabbitListener(queuesToDeclare = @Queue(value = \"work\", durable = \"true\", exclusive = \"false\", autoDelete = \"false\"))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n\n}\n```\n\n#### 5.2.3 Publish/Subscribe - 发布订阅模式\n\n```java\n/**\n * Publish/Subscribe模式\n * <p>\n * 使用交换机，将消息发给所有的绑定的队列\n *\n * @author secret\n * @date 2021/12/14 6:44 PM\n */\n@Component\npublic class PublishSubscribeConsumer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 没有参数的，表示临时队列\n            exchange = @Exchange(value = \"logs\", type = \"fanout\") // 交换机\n    ))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 没有参数的，表示临时队列\n            exchange = @Exchange(value = \"logs\", type = \"fanout\") // 交换机\n    ))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n}\n```\n\n#### 5.2.4 Routing - 路由模式（direct）\n\n```java\n/**\n * Routing 模式 - 消费者\n * <p>\n * Exchange类型：direct\n *\n * @author secret\n * @date 2021/12/14 7:01 PM\n */\n@Component\npublic class RoutingConsumer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_direct\", type = \"direct\"),\n            key = \"info\" // routing key\n    ))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_direct\", type = \"direct\"),\n            key = {\"info\", \"error\", \"warning\"} // routing key\n    ))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_direct\", type = \"direct\"),\n            key = {\"warning\"}\n    ))\n    public void receive3(String message) {\n        System.out.println(\"consumer3: \" + message);\n    }\n}\n```\n\n#### 5.2.5 Topics - 主题（动态路由）模式\n\n```java\n/**\n * Topics模式 -消费者\n *\n * Exchange的类型为：topic\n *\n * @author secret\n * @date 2021/12/14 7:16 PM\n */\n@Component\npublic class TopicsConsumer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_topics\", type = \"topic\"),\n            key = {\"user.*\"}\n    ))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_topics\", type = \"topic\"),\n            key = {\"user.#\"}\n    ))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n\n}\n```\n\n#### 5.2.6 客户端测试代码\n\n```java\n/**\n * 生产端没有指定交换机，只有routing key和object。通过生产端的routing key和消费端的队列匹配\n */\n@SpringBootTest(classes = RabbitMQApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@RunWith(SpringRunner.class)\n@EnableAutoConfiguration\npublic class RabbitMQApplicationTest {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    // 直连模式\n    @Test\n    public void testHelloWorld() {\n        rabbitTemplate.convertAndSend(\"hello\", \"hello spring boot starter amqp...\");\n    }\n\t// Work Queue模式\n    @Test\n    public void testWorkQueue() {\n        for (int i = 0; i < 20; i++) {\n            rabbitTemplate.convertAndSend(\"work\", \"hello work queue\" + i);\n        }\n    }\n\t// Publish/Subscribe模式\n    @Test\n    public void testPublishSubscribe() {\n        for (int i = 0; i < 10; i++) {\n            rabbitTemplate.convertAndSend(\"logs\", \"\", \"hello publish subscribe \" + i);\n        }\n    }\n\t// Routing模式\n    @Test\n    public void testRouting() {\n        String routingKey = \"warning\";\n        rabbitTemplate.convertAndSend(\"logs_direct\", routingKey, \"hello routing, type=\" + routingKey);\n    }\n\t// Topics模式\n    @Test\n    public void testTopics() {\n        String routingKey = \"user.save\";\n        rabbitTemplate.convertAndSend(\"logs_topics\", routingKey, \"hello topics, type=\" + routingKey);\n    }\n}\n```\n\n## 6.MQ的应用场景\n\n### 6.1 异步处理\n\n```markdown\n# 场景说明：\n\t用户注册后，需要发送邮件和注册短信，传统的做法有2种：1）串行方式 2）并行方式\n## 串行方式\n\t将注册信息写入数据库后，再发送邮件，再注册短信，以上三个任务全部返回结果后，才返回给客户端。这里有一个问题，邮件、短信并不是必须的，它只是一个通知，而这种做法需要让客户端等待没有必要等待的东西。\n## 并行方式\n\t将注册信息写入数据库后，发送邮件的同时，发送短信。以上三个任务完成后，返回给客户端，并行的方式能提高处理的效率。\n```\n\n![image](https://img-blog.csdnimg.cn/c0e203b0f649433984cbd50434586974.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/17a5dbf434ee4c76a2745392fb70a774.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 消息队列：\n\t除了以上提到的2种传统方式之外，我们还可以选择 消息队列 的形式。因为发送邮件和发送短信不是必须的，所以我们可以使用消息队列的形式，进行异步处理，相对于并行方式，减少了发送邮件或者短信的时间，相当于只有 注册信息写入数据库 + 写入消息队列 这个操作的耗时。\n```\n\n![image](https://img-blog.csdnimg.cn/c2bad0734fff4638acb0f0e7aa222327.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 6.2 应用解藕\n\n![image](https://img-blog.csdnimg.cn/4096d6dc33ff48e380b3ec742e513b3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 场景：\n\t双十一是购物节，用户下单后，订单系统需要通知库存系统，传统做法是订单系统调用库存系统提供的接口。\n# 缺点：\n\t这种做法有个缺点：当库存系统异常时，订单系统就无法使用。订单系统和库存系统就出现了耦合。解决方法引入消息队列。\n```\n\n![image](https://img-blog.csdnimg.cn/129b02a2439545ed8f748471c0f21b8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 引入消息队列：\n\t订单系统：用户下单后，订单系统完成持久化后，将消息写入 消息队列 ，返回用户下单成功。\n\t库存系统：订阅下单消息，获取下单消息，进行库存操作。就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失。\n```\n\n### 6.3 流量削峰\n\n```markdown\n# 场景：\n\t秒杀活动，一般会因为流量过大，导致应用挂掉。为了解决这个问题，一般在应用之前加入消息队列。\n# 作用：\n\t1.可以控制活动人数，超过一定阈值的订单直接丢弃\n\t2.可以缓解短时间的高流量压垮应用（程序按自己处理能力获取订单）。\n# 流程：\n\t1.用户的请求，服务器收到之后先加入到消息队列。假如超过消息队列的最大长度，则直接丢弃用户请求或者跳转到错误页面。\n\t2.秒杀业务根据消息队列中的请求信息，再做后续的处理。\n```\n\n## 7.RabbitMQ集群\n\n### 7.1 集群架构（副本集群）\n\n> 默认情况下：RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是 消息队列，默认情况下，消息队列位于一个节点上，尽管他们可以从任意节点上看到和访问。--官网\n>\n> 也就是说，集群架构的方式只能在节点之间同步（复制）交换机等基本信息，无法同步队列信息。而队列信息是保存数据的地方，如果无法在节点之间进行复制，那么集群将失去一些意义。\n\n#### 7.1.1 架构图\n\n![image](https://img-blog.csdnimg.cn/1b08e25a4092495f8412a4dd0801b780.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 核心解决问题：\n\t当集群中某一时刻Master节点宕机，可以对Queue中信息进行备份。\n```\n\n#### 7.1.2 集群搭建\n\n```markdown\nPS：使用docker安装\n# 0.集群规划\n\tnode1:  172.18.0.2 5672 15672 \t\tmaster 主节点\n\tnode2:\t172.18.0.3 5673 15673\t\trepl1  副本节点\n\tnode3:\t172.18.0.4 5674 15674\t \trepl2  副本节点\n# 1.克隆三台主机名和ip映射，并修改各个虚拟机的hostname\n\t创建网络：\n\t\tdocker network create rabbit-net\n\t创建容器：\n\t\tdocker run -d --privileged=true --hostname node1 --name node1 -p 15672:15672 -p 5672:5672 --network rabbit-net centos:8.2.2004 /sbin/init\n\t进入容器：\n\t\tdocker exec -it node/node1/node2 /bin/bash\n\t复制erlang、rabbit的rpm包到容器：\n\t\tdocker cp ./erlang.xxx.rpm node1:/\n\t\tdocker cp ./rabbitmq.xxx.rpm node1:/\n\t安装：\n\t\trpm -ihv erlang.xxx.rpm\n\t\trpm -ivh rabbitmq.xxx.rpm --nodeps --force\n\t配置：\n\t\t在/etc/hosts加入各个节点的ip和域名对应关系。\n\t问题：\n\t\t参考：https://blog.csdn.net/weixin_42181917/article/details/105579288\n\t\t1.System has not been booted with systemd as init system (PID 1). Can't operate.Failed to create bus connection: Host is down\n\t\t解决：创建容器使用 /sbin/init\n\t\t2.Could not set property: Failed to set static hostname: Device or resource busy\n\t\t解决：退出容器，重新进入在设置一次\n\t\t\thostnamectl set-hostname node/node1/node2\n\t\t\texit\n\t\t\thostnamectl set-hostname node/node1/node2\n# 2.三台机器安装rabbitmq，并同步cookie文件\n\tdocker cp 命令将宿主机中的erlang和rabbitmq的rpm包都上传到虚拟机中，启动rabbitmq。\n\tdocker cp 命令将node1节点中的 /var/lib/rabbitmq/.erlang.cookie文件复制到宿主机，再通过宿主机复制到node1和node2.\n\t这里需要注意看是否.erlang.cookie文件的权限是否和node相同：chown、chgrp 命令可以修改权限。\n# 3.查看cookie文件是否一致\n\t进入三个节点的虚拟机中，执行: cat /var/lib/rabbitmq/.erlang.cookie，查看内容是否一致。\n# 4.后台启动rabbit\n\trabbitmq-server -detached\n# 5.在node2和node3执行加入集群命令\n\t1.关闭\t\trabbitmqctl stop_app\n\t2.加入集群\t   rabbitmqctl join_cluster rabbit@node\n\t3.启动服务\t   rabbitmqctl start_app\n\t\n\n```\n\n**搭建成功：**\n\n![image](https://img-blog.csdnimg.cn/4e5b989ee58b4a63816087ee87cb34d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/c9e21a1431b74730908aefb32fdc5cbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 7.2 镜像集群\n\n> 镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间自动进行同步。且如果其中一个节点不可用，并不会导致消息丢失或者服务不可用的情况，提升MQ集群整体的高可用性。--摘自官网\n\n#### 7.2.1 架构图\n\n![image](https://img-blog.csdnimg.cn/677182699180463baa2a64e582a7042c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 7.2.2 集群搭建\n\n​\t\t镜像集群的搭建，是在`副本集群`的基础之上做的额外配置，也就是说必选先搭建好`副本集群`才能搭建镜像集群。这个额外配置就是需要创建一个`策略`。\n\n```markdown\n# 0.策略说明\n\trabbitmqctl set_policy [--vhost <vhost>] [--priority <priority>] [--apply-to <apply-to>] <name> <pattern> <definition>\n\t--vhost：可选参数，针对指定virutal host下的queue进行设置\n\t--priority：可选参数，policy的优先级，越大越优先\n\t--appliy-to：可选参数，表示策略应用的对象，后面跟queues|exchanges|all。\n\tname：策略名称，唯一标识。\n\tpattern：匹配队列的正则表达式。\n\tdefinition：镜像定义，包括三个部分：ha-mode、ha-params、ha-sync-mode\n\t\tha-mode：镜像队列模式，可选值：all/exaclty/nodes\n\t\t\tall：表示在集群的所有节点上进行镜像\n\t\t\texactly：表示在指定个数的节点上进行镜像，节点个数通过ha-params指定\n\t\t\tnodes：表示在指定节点上进行镜像，节点名称通过ha-params指定\n\t\tha-params：ha-mode需要用到的参数\n\t\tha-sync-mode：队列同步方式，可选值为：automatic/manual\n\t\t\tautomatic：自动同步\n\t\t\tmanual：用户触发同步\n# 1.查看当前策略\n\trabbitmqctl list_policies\n# 2.添加策略\n\trabbitmqctl set_policy ha-all '^hello' '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}'\n\t说明：策略正则表示为\"^\"表示匹配所有队列，\"^hello\"表示匹配hello开头的队列\n# 3.删除策略\n\trabbitmqctl clear_policy ha-all\n```\n\n**搭建成功：**\n\n![image](https://img-blog.csdnimg.cn/0a123778671941e99aac309f1180c599.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/4c70637a590c4150b0f2296b65bc3837.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n","source":"_posts/RabbitMQ基础与集群实战.md","raw":"---\ntitle: RabbitMQ基础与集群实战\ntop: false\ndate: 2021-12-23 18:10:32\ntags:\n    - 中间件\n    - 集群\n    - RabbitMQ\ncategories:\n    - 中间件\n---\n# RabbitMQ实战教程\n\n> 视频：https://www.bilibili.com/video/BV1dE411K7MG?from=search&seid=15593601763323732951&spm_id_from=333.337.0.0\n\n## 1.MQ引言\n\n### 1.1 什么是MQ\n\n​\t\t`MQ`(Message Queue)：翻译为`消息队列`，通过典型的`生产者`和`消费者`模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的消费和生产，没有业务逻辑的侵入，轻松的实现系统间的解藕。别名为：`消息中间件`，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。\n\n### 1.2 MQ有哪些\n\n​\t\t当今市面上有很多的消息中间件，如老牌的`ActiveMQ`，`RabbitMQ`，炙手可热的`Kafka`、阿里巴巴自主研发的`RocketMQ`等。\n\n### 1.3 不同MQ的特点\n\n```markdown\n# 1.ActiveMQ\n\tActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。他是一个完全支持JMS规范的消息中间件。丰富的API，多种集群架构模式让ActiveMQ称为老牌的消息中间件，在中小企业颇受欢迎。\n# 2.Kafka\n\tKafka是LinkedIn公司开源的分布式发布-订阅消息中间件，目前属于Apache顶级项目。Kafka的主要特点是基于pull模式来处理消息消费。追求高吞吐量，一开始的目的是用于日志的收集和传输。0.8版本开始支持复制，不支持事物，对消息的丢失、重复、错误没有严格的要求。适合产生大量数据的互联网服务的数据收集业务。\n# 3.RocketMQ\n\tRocketMQ是阿里开源的消息中间件。他是纯java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ的思路起源于Kafka，但并不是Kafka的一个复制，他对消息的可靠传输及事物做了优化，目前的阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流处理、binglog分发等场景。\n# 4.RabbitMQ\n\tRabbitMQ是使用Erlang语言开发的开源消息中间件系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布订阅）、可靠性、安全。AMQP协议更多用在企业内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。\n```\n\n> RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（延时低）、可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。\n\n## 2.RabbitMQ的引言\n\n### 2.1 RabbitMQ简介\n\n​\t\tRabbitMQ是基于AMQP协议，erlang语言开发，是部署最广泛的开源消息中间件，也是最受欢迎的消息中间件之一。\n\n![image](https://img-blog.csdnimg.cn/681db2b5bf6f486f8dfa258fa90aad53.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# AMQP协议（后续单独讲）\n\tAMQP(Advanced Message Queuing Protocol，高级消息队列协议)，在2003年被提出，在最用于解决金融领域不同平台之间消息传递的交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wrie-level protocol（链接协议）。这时其和JMS的本质差异，AMQP不从api层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。\n\t\t\t\t\t\t\t\tServer\n\t\t\t\t\t+---------------------------+\n\t\t\t\t\t|\t\tVirtual Host\t\t|\n\t\t\t\t\t|\t+--------------------+  |\n   \t+------------+  |\t|\t+-----------+    |\t|\n\t| Publisher  | -------->| Exchange\t|    |  |\n\t| Application|\t|\t|\t+-----+-----+    |  |\n\t+------------+\t|   | \t\t  |\t\t\t |\t|\n\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+\n\t\t\t\t\t|\t|\t+  Message\t+\t |\t|\t|  Consummer  |\n\t\t\t\t\t|\t|\t+\tQueue\t+ --------->| Application |\n\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+\n\t\t\t\t\t|\t+--------------------+\t|\n\t\t\t\t\t+---------------------------+\n```\n\n### 2.2 RabbitMQ的安装\n\n​\t\t本次安装的环境如下：\n\n- 系统：centos8 64位\n- erlang：24.1.7\n- rabbitmq：3.9.11\n\n#### 2.2.1 erlang下载\n\n> 因为rabbitMQ是基于erlang开发的，所以先要下载erlang的包：https://github.com/rabbitmq/erlang-rpm\n>\n> erlang版本和rabbitmq版本对照：https://www.rabbitmq.com/which-erlang.html\n\n![iamge](https://img-blog.csdnimg.cn/bf7aa8f5462148a99f279b03dcb493d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t\t本次开发使用的最新的rabbitmq版本为`3.9.11`，最小支持的erlang版本为23.2，所以本次erlang使用了`24.1.7`版本\n\n![iamge](https://img-blog.csdnimg.cn/889a43dfbe3048b58c0622101762bbad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 2.2.2 RabbitMQ下载\n\n> rabbitmq下载地址：https://www.rabbitmq.com/install-rpm.html#downloads\n\n\n![image](https://img-blog.csdnimg.cn/40404dec0e524d10bb9df1a1d16f9b5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 2.2.3 安装启动\n\n```markdown\n# 1.将rabbitmq相关包上传到linxu服务器中\n\t使用scp命令上传到服务器两个包：\n\tscp ./erlang-24.1.7-1.el8.x86_64.rpm root@10.3.4.5:/root/\n\tscp ./rabbitmq-server-3.9.11-1.el8.noarch.rpm root@10.3.4.5:/root/\n# 2.依次安装erlang、rabbitmq\n\t使用rpm命令进行安装，缺少依赖会进行提示：\n\trpm -ivh erlang-24.1.7-1.el8.x86_64.rpm\n\trpm -ivn rabbitmq-server-3.9.11-1.el8.noarch.rpm\n# 3.修改rabbitmq的配置\n\t使用rpm包的方式安装时，并没有将配置文件也放到指定目录下，所以需要自行创建一个配置文件：/etc/rabbitmq/rabbitmq.conf，具体的配置内容可以参考：https://www.rabbitmq.com/configure.html#config-file-formats。\n\t这里我们需要修改一处：loopback_users=none，表示能够让guest用户进行远程访问。默认情况下，guest用户只能在localhost域名下访问。我们使用的是云服务器，需要使用ip进行访问，所以需要修改这个配置。\n# 4.开启管理控制台插件\n\t其实就是开启rabbitmq的一个插件：rabbitmq_management，可以让我们使用web界面管理rabbitmq。执行命令：rabbitmq-plugins enable rabbitmq_management。该命令还另外开启了2个插件：rabbitmq_management_agent、rabbitmq_web_dispatch。\n# 5.启动/停止/重启rabbitmq服务\n\trabbitmq安装的时候，会将其设置为系统服务，使用系统服务命令即可：\n\tsystemctl start/stop/restart rabbitmq-server.service\n# 6.查看服务状态\n\tsystemctl stauts rabbitmq-server.service\n    结果如下为正常运行中：\n    ● rabbitmq-server.service - RabbitMQ broker\n       Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)\n       Active: active (running) since Sun 2021-12-12 23:56:51 CST; 1 day 9h ago\n      Process: 22710 ExecStop=/usr/sbin/rabbitmqctl shutdown (code=exited, status=0/SUCCESS)\n     Main PID: 22758 (beam.smp)\n        Tasks: 23 (limit: 23722)\n       Memory: 94.8M\n       CGroup: /system.slice/rabbitmq-server.service\n               ├─22758 /usr/lib64/erlang/erts-12.1.5/bin/beam.smp -W w -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 12800>\n               ├─22773 erl_child_setup 32768\n               ├─22827 inet_gethost 4\n               └─22828 inet_gethost 4\n# 7.访问管理界面\n \t默认http后台界面的端口为15672。\n \thttp://10.3.4.5:15672/\n# 8.登陆\n\t账号/密码：guest/guest\n```\n\n## 3.RabbitMQ配置\n\n### 3.1 RabbitMQ管理命令行\n\n```markdown\n# 1.服务管理\n\tsystemctl start/stop/restart rabbitmq-server.service\n# 2.管理命令行\n\t可以用来在不使用web管理端的情况下管理rabbitmq。\n\trabbitmqctl help // 查看所有的命令\n# 3.插件管理\n\trabbitmq-plugins enable/list/disable\n```\n\n### 3.2 web管理介绍\n\n![image](https://img-blog.csdnimg.cn/6a2017fe4a3a4216a594f1d64c3a28e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n- **Connection**：连接，无论是消费者还是生产者，都要与rabbitmq建立连接才能进行消息的生产与消费。\n- **Channels**：通道，建立连接后，消息的投递和获取都是通过通道来进行的。\n- **Exchages**：交换机，用来实现消息的路有。\n- **Queues**：队列，消息存放于该队列中，等待消费，消费之后移除。\n\n#### 3.2.1用户和虚拟主机管理\n\n##### 3.2.1.1 用户\n\n![image](https://img-blog.csdnimg.cn/67b980ab25e24c75b2a6d3c9590c22ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# Tags说明：\n\tAdmin(超级管理员)：登录控制台，查看所有信息，并对用户、策略（policy）进行修改。\n\tMonitoring（监控者）：登陆控制台，查看rabbitmq的节点（进程数、内存、磁盘等使用情况）信息。\n\tPolicymaker（策略制定者）：登陆控制台，对policy进行管理。\n\tManagement（普通管理员）：登陆控制台查看信息。\n\t其他：无法登陆控制台，就是普通的消费者或者生产者。\n```\n\n##### 3.2.1.2 虚拟主机\n\n![image](https://img-blog.csdnimg.cn/b21620fc59f5467ebc4c0402d5e2c0df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 虚拟主机：\n\t为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Host）概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自都有自己的队列、交换机，互不影响。相当于MySQL中的数据库。\n```\n\n##### 3.2.1.3 用户和虚拟主机绑定\n\n![image](https://img-blog.csdnimg.cn/e60681b36bec47b5bba1ebde7ee8d03b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/b4808afbd6e34a8e982624a3f0b02856.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 4.RabbitMQ的Java客户端\n\n### 4.1 AMQP协议回顾\n\n![image](https://img-blog.csdnimg.cn/eb827e01a84b4eea9bddb6dab2947c84.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 4.2 RabbitMQ支持的消息类型\n\n![image](https://img-blog.csdnimg.cn/40d40399960442e9a2d0d5668a6825d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 4.3 引入依赖\n\n```xml\n<dependency>\n  <groupId>com.rabbitmq</groupId>\n  <artifactId>amqp-client</artifactId>\n  <version>5.14.0</version>\n</dependency>\n```\n\n### 4.4 各种模型客户端代码\n\n#### 4.4.1 Direct-直连模式\n\n![image](https://img-blog.csdnimg.cn/2401e687d01347fb9827dffb97b570c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 相关概念：\n\tP：provider，生产者，要发送消息的程序\n\tC：consumer，消费者，消费消息的程序\n\tQueue：队列，存储消息的地方\n```\n\n**Producer：**\n\n```java\n/**\n * direct模式-生产者\n * <p>\n * 直接点对点，也就是生产者将消息发送到队列中，消费者直接从队列中获取\n *\n * @author secret\n * @date 2021/12/14 11:34 AM\n */\npublic class TestProducer {\n    // 定义队列名字\n    public static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 1.创建连接工程\n        ConnectionFactory connectionFactory = new ConnectionFactory();\n        connectionFactory.setHost(\"101.43.52.186\");\n        connectionFactory.setPort(5672);\n        connectionFactory.setVirtualHost(\"/adu\");\n        connectionFactory.setUsername(\"adu\");\n        connectionFactory.setPassword(\"adu\");\n        // 2.创建连接\n        Connection connection = connectionFactory.newConnection();\n        // 3.创建通道\n        Channel channel = connection.createChannel();\n        // 4.声明队列：队列名称，是否持久化，是否独占，额外参数\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 5.向队列发送消息：交换机名称，队列名称，额外参数，消息体\n        channel.basicPublish(\"\", QUEUE_NAME, null, \"hello world\".getBytes(StandardCharsets.UTF_8));\n        // 6.关闭资源\n        channel.close();\n        connection.close();\n    }\n}\n```\n\n**Consumer**:\n\n```java\n/**\n * direct模式-消费者\n *\n * @author secret\n * @date 2021/12/14 11:34 AM\n */\npublic class TestConsumer {\n    public static final String QUEUE_NAME = \"hello\";\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 1 创建连接工厂，并设置基础参数\n        ConnectionFactory connectionFactory = new ConnectionFactory();\n        connectionFactory.setHost(\"101.43.52.186\");\n        connectionFactory.setPort(5672);\n        connectionFactory.setVirtualHost(\"/adu\");\n        connectionFactory.setUsername(\"adu\");\n        connectionFactory.setPassword(\"adu\");\n        // 2 创建连接\n        Connection connection = connectionFactory.newConnection();\n        // 3 创建通道\n        Channel channel = connection.createChannel();\n        // 4 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 4 接收消息\n        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) {\n            // 回调方法\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer：\" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n        // 5 关闭资源\n        channel.close();\n        connection.close();\n    }\n}\n```\n\n#### 4.4.2 Work Queues-工作队列\n\n![image](https://img-blog.csdnimg.cn/37c7326912a04ff1baaa25754a61535f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t\tWork Queue也被称为`Task Queue`任务模型。当消息处理比较耗时时，可能消息生产的速度远远超过了消息消费的速度。长此以往，消息就会堆积，此时就可以使用Work Queue模型。让多个消费者绑定同一个队列，共同消费队列中的消息。队列中的消息一旦被消费，就会被删除，因此不会产生重复消费。\n\n```java\n// 提取连接rabbitmq的工具类\npublic class RabbitMQUtil {\n\n    public static Connection getConnection()    {\n        try {\n            // 创建连接工厂\n            ConnectionFactory connectionFactory = new ConnectionFactory();\n            // 设置参数\n            connectionFactory.setHost(\"101.43.52.186\");\n            connectionFactory.setPort(5672);\n            connectionFactory.setVirtualHost(\"/adu\");\n            connectionFactory.setUsername(\"adu\");\n            connectionFactory.setPassword(\"adu\");\n            // 创建连接\n            return connectionFactory.newConnection();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (TimeoutException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static Channel getChannel(Connection connection) {\n        try {\n            return connection.createChannel();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void close(Channel channel, Connection connection) {\n        if (channel != null) {\n            try {\n                channel.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (TimeoutException e) {\n                e.printStackTrace();\n            }\n        }\n        if (connection != null) {\n            try {\n                connection.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n**Producer：**\n\n```java\n/**\n * Work Queue模型\n * <p>\n * 工作队列模型，应对的是消费者消费比较慢的情况，多个消费者共同消费同一个队列中的消息。\n *\n * @author secret\n * @date 2021/12/14 2:02 PM\n */\npublic class WorkQueueProducer {\n\n    public static final String QUEUE_NAME = \"work\";\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 发消息\n        for (int i = 0; i < 10; i++) {\n            channel.basicPublish(\"\", QUEUE_NAME, null, (\"hello work queue \" + i).getBytes(StandardCharsets.UTF_8));\n        }\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class WorkQueueConsumer1 {\n    public static final String QUEUE_NAME = \"work\";\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 消费消息\n        channel.basicConsume(QUEUE_NAME, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\n和consumer1相同代码，修改消费输出：System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n```\n\n**结果：**\n\n```markdown\n# consumer1 output...\nconsumer1: hello work queue 0\nconsumer1: hello work queue 2\nconsumer1: hello work queue 4\nconsumer1: hello work queue 6\nconsumer1: hello work queue 8\n# consumer2 output...\nconsumer2: hello work queue 1\nconsumer2: hello work queue 3\nconsumer2: hello work queue 5\nconsumer2: hello work queue 7\nconsumer2: hello work queue 9\n```\n\n**总结：**\n\n​\t\t默认情况下，RabbitMQ将按顺序依次将消息发给每个消费者，也就是说每个消费者都会收到相同数量的消息，这种平分消息的方式称为`循环`。\n\n##### 4.4.2.1 消息自动确认机制\n\n​\t\t如果一个消费者在执行任务的过程中宕机，那么在以上代码中，一旦RabbitMQ将将消息传递给消费者，他就会立即标记为删除，那么该消费者中未处理的消息将丢失。我们希望在处理任务的过程中，一个消费者宕机了，能够将任务交给其他消费者处理。这时候我们就可以用到`消息自动确认机制`。也就是说，我们可以在处理完任务之后，再通知RabbitMQ可以删除该任务。\n\n**Producer：**\n\n```java\n// 同上\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class WorkQueueConsumer3 {\n    public static final String QUEUE_NAME = \"work\";\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 每次只能消费一个消息\n        channel.basicQos(1);\n        // 消费消息\n        channel.basicConsume(QUEUE_NAME, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                try {\n                    Thread.sleep(1000); // 模拟处理消息消耗时常\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n                // 手动确认，参数1：消息标记 参数2：是否同时确认多条，false表示每次只能确认一条\n                channel.basicAck(envelope.getDeliveryTag(), false);\n            }\n        });\n    }\n\n}\n// consumer2\npublic class WorkQueueConsumer4 {\n    public static final String QUEUE_NAME = \"work\";\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, true, false, false, null);\n        // 限制每次消费1条\n        channel.basicQos(1);\n        // 消费消息，autoAck改为false，表示不自动确认\n        channel.basicConsume(QUEUE_NAME, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                try {\n                    Thread.sleep(1500);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n                // 手动确认\n                channel.basicAck(envelope.getDeliveryTag(), false);\n            }\n        });\n    }\n}\n```\n\n**结果：**\n\n```markdown\n# consumer1 output...\nconsumer1: hello work queue 1\nconsumer1: hello work queue 3\nconsumer1: hello work queue 5\nconsumer1: hello work queue 8\nconsumer1: hello work queue 10\nconsumer1: hello work queue 13\nconsumer1: hello work queue 15\nconsumer1: hello work queue 18\n# consumer2 output...\nconsumer1: hello work queue 0\nconsumer1: hello work queue 2\nconsumer1: hello work queue 4\nconsumer1: hello work queue 6\nconsumer1: hello work queue 7\nconsumer1: hello work queue 9\nconsumer1: hello work queue 11\nconsumer1: hello work queue 12\nconsumer1: hello work queue 14\nconsumer1: hello work queue 16\nconsumer1: hello work queue 17\nconsumer1: hello work queue 19\n```\n\n**总结：**\n\n​\t\t实现消息自动确认，需要注意两点：1）设置通道一次只能消费一条消息 2）关闭自动确认，手动确认消息\n\n#### 4.4.3 Publish/Subscribe-发布订阅模式\n\n![image](https://img-blog.csdnimg.cn/610277d029c04fe5a3933cf79f21dcc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 消息流程：\n\t可以有多个消费者，每个消费者都有自己的queue（队列），每个队列都要绑定要exchange（交换机）。\n\t生产者发送的消息只能发送给交换机，交换机来决定发送给哪个队列，生产者无法决定。\n\t交换机把消息发送给绑定过的所有队列，队列的消费者都能拿到消息，实现一个消息被多个消费者消费。\n# 对应交换机类型：fanout\n```\n\n**Proudcer：**\n\n```java\npublic class PublishSubscriptProducer {\n\n    public static final String QUEUE_NAME = \"fanout\";\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明交换机 交换机名称 交换机类型\n        channel.exchangeDeclare(\"logs\", \"fanout\");\n        // 发送消息到交换机\n        channel.basicPublish(\"logs\", \"\", null, \"hello fanout\".getBytes(StandardCharsets.UTF_8));\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class PublishSubscribeConsumer1 {\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明交换机\n        channel.exchangeDeclare(\"logs\", \"fanout\");\n        // 创建临时队列\n        String queue = channel.queueDeclare().getQueue();\n        // 绑定交换机和队列 队列名称 交换机名称 路由\n        channel.queueBind(queue, \"logs\", \"\");\n        // 接收消息\n        channel.basicConsume(queue, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\n同consumer1，输出修改为：System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n```\n\n**结果：**\n\n```markdown\n# consumer1 output...\nconsumer1: hello fanout, type [\nconsumer1: hello fanout\n\n# consumer2 output...\nconsumer2: hello fanout, type [\nconsumer2: hello fanout\n```\n\n#### 4.4.4 Routing-路由模式\n\n​\t\t在发布订阅模式中，一条消息会被所有订阅的的队列消费。但是在某些场景下，我们希望不同的消息类型被不同的队列消费，这时就需要用到Routing模式的direct类型的Exchange。\n\n```markdown\n# 在Direct模式下：\n\t队列与交换机的绑定，不能是任意绑定了，而是需要指定一个Routing Keying，消息发送方在向Exchange发送消息时，也必须指定消息的Routing Key。\n\tExchange也不再把消息交给每一个与之绑定的队列，而是根据消息的Routing Key判断，只有队列的Routing Key和消息的Routing Key完全一致时，才会发送消息。\n```\n\n![image](https://img-blog.csdnimg.cn/8f206f2cfdb34ce89c54e042a92cc21f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 说明：\n\tP：Proudcer，生产者，向Exchange发送消息，同时会指定一个Routing Key。\n\tX：Exchange，交换机，接收生产者发送的消息，然后把消息传递给与routing key完全匹配的队列。\n\tC1：Consumer，消费者，其所在队列指定了需要routing key为error的消息\n\tC2：Consumer，消费者，其所在队列指定了需要routing key为info、error、warning的消息\n```\n\n**Producer：**\n\n```java\npublic class RoutingProducer {\n\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取管道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明交换机\n        channel.exchangeDeclare(\"logs_direct\", \"direct\");\n        // 发送消息\n        String routingKey = \"warning\";\n        channel.basicPublish(\"logs_direct\", routingKey, null, String.format(\"routing for type [%s]\", routingKey).getBytes(StandardCharsets.UTF_8));\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class RoutingConsumer1 {\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(\"logs_direct\", \"direct\");\n        String queue = channel.queueDeclare().getQueue();\n        // consumer1绑定routing key 为info\n        channel.queueBind(queue, \"logs_direct\", \"info\");\n        channel.basicConsume(queue, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\npublic class RoutingConsumer2 {\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(\"logs_direct\", \"direct\");\n        String queue = channel.queueDeclare().getQueue();\n        // consumer1绑定routing key 为info、error、warning\n        channel.queueBind(queue, \"logs_direct\", \"info\");\n        channel.queueBind(queue, \"logs_direct\", \"error\");\n        channel.queueBind(queue, \"logs_direct\", \"warning\");\n        channel.basicConsume(queue, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n```\n\n**结果：**\n\n```markdown\n# 依次发送routing key为info、error、warning结果：\n\n## consummer1\nconsumer1: routing for type [info]\n\n## consumer2\nconsumer1: routing for type [info]\nconsumer1: routing for type [error]\nconsumer1: routing for type [warning]\n```\n\n#### 4.4.5 Topics-主题（动态路由模式）\n\n​\t\t`Topics`模式同`Routing`模式相比，都可以根据Routing Key把消息路由到不同的队列。只不过`Topic`类型的Routing Key可以使用通配符。Routing Key一般是由一个或多个单词组成，多个单词之间以‘,’分割。Exchange的类型为`topic`。\n\n![image](https://img-blog.csdnimg.cn/e1252695c8fd433e9885d1a9e8c4e9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 通配符：\n\t*（star）can substitute for exactly one word。精确匹配一个单词。\n\t#（hash）can substitute for zero or more words。匹配零个、一个或多个单词。\n## 例如：\n\taudit.# ：匹配 audit、audit.irs、audit.irs.corporate 等。\n\taudit.* ：只能匹配 audit.irs。\n```\n\n**Producer：**\n\n```java\npublic class TopicsProducer {\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(\"logs_topics\", \"topic\");\n        String routingKey = \"user.save.now\";\n        channel.basicPublish(\"logs_topics\", routingKey, null, String.format(\"hello topics, routing key : [%s]\", routingKey).getBytes(StandardCharsets.UTF_8));\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer：**\n\n```java\n// consumer1\npublic class TopicsConsumer1 {\n\n    public static final String EXCHANGE_NAME = \"logs_topics\";\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(EXCHANGE_NAME, \"topic\");\n        String queue = channel.queueDeclare().getQueue();\n        // 队列和交换机绑定的路由为 user.*\n        channel.queueBind(queue, EXCHANGE_NAME, \"user.*\");\n        channel.basicConsume(queue, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer1: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n\n// consumer2\npublic class TopicsConsumer2 {\n\n    public static final String EXCHANGE_NAME = \"logs_topics\";\n\n    public static void main(String[] args) throws IOException {\n        Connection connection = RabbitMQUtil.getConnection();\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        channel.exchangeDeclare(EXCHANGE_NAME, \"topic\");\n        String queue = channel.queueDeclare().getQueue();\n        // 队列和交换机绑定的路由为 user.*\n        channel.queueBind(queue, EXCHANGE_NAME, \"user.#\");\n        channel.basicConsume(queue, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"consumer2: \" + new String(body, StandardCharsets.UTF_8));\n            }\n        });\n    }\n}\n```\n\n**结果：**\n\n```markdown\n# 依次发送routing key为user.save、user、user.save.now的结果：\n\n## conumser1:\nconsumer1: hello topics, routing key : [user.save]\n\n## consumer2:\nconsumer2: hello topics, routing key : [user.save]\nconsumer2: hello topics, routing key : [user]\nconsumer2: hello topics, routing key : [user.save.now]\n```\n\n## 5.SpringBoot重使用RabbitMQ\n\n### 5.1 搭建环境\n\n#### 5.1.1 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n#### 5.1.2 配置信息\n\n```yaml\nspring:\n  application:\n    name: adu-rabbitmq\n  rabbitmq:\n    host: 10.2.3.4\n    port: 5672\n    username: adu\n    password: adu\n    virtual-host: /adu\n```\n\n### 5.2 各种模型客户端代码\n\n#### 5.2.1 Hello World-直连模型\n\n```java\n/**\n * direct直连模式\n *\n * @author secret\n * @date 2021/12/14 6:30 PM\n */\n@Component\n@RabbitListener(queuesToDeclare = @Queue(value = \"hello\"))\npublic class HelloWorldConsumer {\n\n    @RabbitHandler\n    public void receive(String message) {\n        System.out.println(\"consumer: \" + message);\n    }\n\n}\n```\n\n#### 5.2.2 Work Queue - 工作队列模式\n\n```java\n/**\n * Work Queue模式-消费者\n * <p>\n * 循环模式，每个消费者得到的消息数相同\n *\n * @author secret\n * @date 2021/12/14 6:36 PM\n */\n@Component\npublic class WorkQueueConsumer {\n\n    @RabbitListener(queuesToDeclare = @Queue(value = \"work\", durable = \"true\", exclusive = \"false\", autoDelete = \"false\"))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n    @RabbitListener(queuesToDeclare = @Queue(value = \"work\", durable = \"true\", exclusive = \"false\", autoDelete = \"false\"))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n\n}\n```\n\n#### 5.2.3 Publish/Subscribe - 发布订阅模式\n\n```java\n/**\n * Publish/Subscribe模式\n * <p>\n * 使用交换机，将消息发给所有的绑定的队列\n *\n * @author secret\n * @date 2021/12/14 6:44 PM\n */\n@Component\npublic class PublishSubscribeConsumer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 没有参数的，表示临时队列\n            exchange = @Exchange(value = \"logs\", type = \"fanout\") // 交换机\n    ))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 没有参数的，表示临时队列\n            exchange = @Exchange(value = \"logs\", type = \"fanout\") // 交换机\n    ))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n}\n```\n\n#### 5.2.4 Routing - 路由模式（direct）\n\n```java\n/**\n * Routing 模式 - 消费者\n * <p>\n * Exchange类型：direct\n *\n * @author secret\n * @date 2021/12/14 7:01 PM\n */\n@Component\npublic class RoutingConsumer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_direct\", type = \"direct\"),\n            key = \"info\" // routing key\n    ))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_direct\", type = \"direct\"),\n            key = {\"info\", \"error\", \"warning\"} // routing key\n    ))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_direct\", type = \"direct\"),\n            key = {\"warning\"}\n    ))\n    public void receive3(String message) {\n        System.out.println(\"consumer3: \" + message);\n    }\n}\n```\n\n#### 5.2.5 Topics - 主题（动态路由）模式\n\n```java\n/**\n * Topics模式 -消费者\n *\n * Exchange的类型为：topic\n *\n * @author secret\n * @date 2021/12/14 7:16 PM\n */\n@Component\npublic class TopicsConsumer {\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_topics\", type = \"topic\"),\n            key = {\"user.*\"}\n    ))\n    public void receive1(String message) {\n        System.out.println(\"consumer1: \" + message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue, // 临时队列\n            exchange = @Exchange(value = \"logs_topics\", type = \"topic\"),\n            key = {\"user.#\"}\n    ))\n    public void receive2(String message) {\n        System.out.println(\"consumer2: \" + message);\n    }\n\n}\n```\n\n#### 5.2.6 客户端测试代码\n\n```java\n/**\n * 生产端没有指定交换机，只有routing key和object。通过生产端的routing key和消费端的队列匹配\n */\n@SpringBootTest(classes = RabbitMQApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@RunWith(SpringRunner.class)\n@EnableAutoConfiguration\npublic class RabbitMQApplicationTest {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    // 直连模式\n    @Test\n    public void testHelloWorld() {\n        rabbitTemplate.convertAndSend(\"hello\", \"hello spring boot starter amqp...\");\n    }\n\t// Work Queue模式\n    @Test\n    public void testWorkQueue() {\n        for (int i = 0; i < 20; i++) {\n            rabbitTemplate.convertAndSend(\"work\", \"hello work queue\" + i);\n        }\n    }\n\t// Publish/Subscribe模式\n    @Test\n    public void testPublishSubscribe() {\n        for (int i = 0; i < 10; i++) {\n            rabbitTemplate.convertAndSend(\"logs\", \"\", \"hello publish subscribe \" + i);\n        }\n    }\n\t// Routing模式\n    @Test\n    public void testRouting() {\n        String routingKey = \"warning\";\n        rabbitTemplate.convertAndSend(\"logs_direct\", routingKey, \"hello routing, type=\" + routingKey);\n    }\n\t// Topics模式\n    @Test\n    public void testTopics() {\n        String routingKey = \"user.save\";\n        rabbitTemplate.convertAndSend(\"logs_topics\", routingKey, \"hello topics, type=\" + routingKey);\n    }\n}\n```\n\n## 6.MQ的应用场景\n\n### 6.1 异步处理\n\n```markdown\n# 场景说明：\n\t用户注册后，需要发送邮件和注册短信，传统的做法有2种：1）串行方式 2）并行方式\n## 串行方式\n\t将注册信息写入数据库后，再发送邮件，再注册短信，以上三个任务全部返回结果后，才返回给客户端。这里有一个问题，邮件、短信并不是必须的，它只是一个通知，而这种做法需要让客户端等待没有必要等待的东西。\n## 并行方式\n\t将注册信息写入数据库后，发送邮件的同时，发送短信。以上三个任务完成后，返回给客户端，并行的方式能提高处理的效率。\n```\n\n![image](https://img-blog.csdnimg.cn/c0e203b0f649433984cbd50434586974.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/17a5dbf434ee4c76a2745392fb70a774.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 消息队列：\n\t除了以上提到的2种传统方式之外，我们还可以选择 消息队列 的形式。因为发送邮件和发送短信不是必须的，所以我们可以使用消息队列的形式，进行异步处理，相对于并行方式，减少了发送邮件或者短信的时间，相当于只有 注册信息写入数据库 + 写入消息队列 这个操作的耗时。\n```\n\n![image](https://img-blog.csdnimg.cn/c2bad0734fff4638acb0f0e7aa222327.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 6.2 应用解藕\n\n![image](https://img-blog.csdnimg.cn/4096d6dc33ff48e380b3ec742e513b3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 场景：\n\t双十一是购物节，用户下单后，订单系统需要通知库存系统，传统做法是订单系统调用库存系统提供的接口。\n# 缺点：\n\t这种做法有个缺点：当库存系统异常时，订单系统就无法使用。订单系统和库存系统就出现了耦合。解决方法引入消息队列。\n```\n\n![image](https://img-blog.csdnimg.cn/129b02a2439545ed8f748471c0f21b8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 引入消息队列：\n\t订单系统：用户下单后，订单系统完成持久化后，将消息写入 消息队列 ，返回用户下单成功。\n\t库存系统：订阅下单消息，获取下单消息，进行库存操作。就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失。\n```\n\n### 6.3 流量削峰\n\n```markdown\n# 场景：\n\t秒杀活动，一般会因为流量过大，导致应用挂掉。为了解决这个问题，一般在应用之前加入消息队列。\n# 作用：\n\t1.可以控制活动人数，超过一定阈值的订单直接丢弃\n\t2.可以缓解短时间的高流量压垮应用（程序按自己处理能力获取订单）。\n# 流程：\n\t1.用户的请求，服务器收到之后先加入到消息队列。假如超过消息队列的最大长度，则直接丢弃用户请求或者跳转到错误页面。\n\t2.秒杀业务根据消息队列中的请求信息，再做后续的处理。\n```\n\n## 7.RabbitMQ集群\n\n### 7.1 集群架构（副本集群）\n\n> 默认情况下：RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是 消息队列，默认情况下，消息队列位于一个节点上，尽管他们可以从任意节点上看到和访问。--官网\n>\n> 也就是说，集群架构的方式只能在节点之间同步（复制）交换机等基本信息，无法同步队列信息。而队列信息是保存数据的地方，如果无法在节点之间进行复制，那么集群将失去一些意义。\n\n#### 7.1.1 架构图\n\n![image](https://img-blog.csdnimg.cn/1b08e25a4092495f8412a4dd0801b780.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n```markdown\n# 核心解决问题：\n\t当集群中某一时刻Master节点宕机，可以对Queue中信息进行备份。\n```\n\n#### 7.1.2 集群搭建\n\n```markdown\nPS：使用docker安装\n# 0.集群规划\n\tnode1:  172.18.0.2 5672 15672 \t\tmaster 主节点\n\tnode2:\t172.18.0.3 5673 15673\t\trepl1  副本节点\n\tnode3:\t172.18.0.4 5674 15674\t \trepl2  副本节点\n# 1.克隆三台主机名和ip映射，并修改各个虚拟机的hostname\n\t创建网络：\n\t\tdocker network create rabbit-net\n\t创建容器：\n\t\tdocker run -d --privileged=true --hostname node1 --name node1 -p 15672:15672 -p 5672:5672 --network rabbit-net centos:8.2.2004 /sbin/init\n\t进入容器：\n\t\tdocker exec -it node/node1/node2 /bin/bash\n\t复制erlang、rabbit的rpm包到容器：\n\t\tdocker cp ./erlang.xxx.rpm node1:/\n\t\tdocker cp ./rabbitmq.xxx.rpm node1:/\n\t安装：\n\t\trpm -ihv erlang.xxx.rpm\n\t\trpm -ivh rabbitmq.xxx.rpm --nodeps --force\n\t配置：\n\t\t在/etc/hosts加入各个节点的ip和域名对应关系。\n\t问题：\n\t\t参考：https://blog.csdn.net/weixin_42181917/article/details/105579288\n\t\t1.System has not been booted with systemd as init system (PID 1). Can't operate.Failed to create bus connection: Host is down\n\t\t解决：创建容器使用 /sbin/init\n\t\t2.Could not set property: Failed to set static hostname: Device or resource busy\n\t\t解决：退出容器，重新进入在设置一次\n\t\t\thostnamectl set-hostname node/node1/node2\n\t\t\texit\n\t\t\thostnamectl set-hostname node/node1/node2\n# 2.三台机器安装rabbitmq，并同步cookie文件\n\tdocker cp 命令将宿主机中的erlang和rabbitmq的rpm包都上传到虚拟机中，启动rabbitmq。\n\tdocker cp 命令将node1节点中的 /var/lib/rabbitmq/.erlang.cookie文件复制到宿主机，再通过宿主机复制到node1和node2.\n\t这里需要注意看是否.erlang.cookie文件的权限是否和node相同：chown、chgrp 命令可以修改权限。\n# 3.查看cookie文件是否一致\n\t进入三个节点的虚拟机中，执行: cat /var/lib/rabbitmq/.erlang.cookie，查看内容是否一致。\n# 4.后台启动rabbit\n\trabbitmq-server -detached\n# 5.在node2和node3执行加入集群命令\n\t1.关闭\t\trabbitmqctl stop_app\n\t2.加入集群\t   rabbitmqctl join_cluster rabbit@node\n\t3.启动服务\t   rabbitmqctl start_app\n\t\n\n```\n\n**搭建成功：**\n\n![image](https://img-blog.csdnimg.cn/4e5b989ee58b4a63816087ee87cb34d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/c9e21a1431b74730908aefb32fdc5cbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 7.2 镜像集群\n\n> 镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间自动进行同步。且如果其中一个节点不可用，并不会导致消息丢失或者服务不可用的情况，提升MQ集群整体的高可用性。--摘自官网\n\n#### 7.2.1 架构图\n\n![image](https://img-blog.csdnimg.cn/677182699180463baa2a64e582a7042c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 7.2.2 集群搭建\n\n​\t\t镜像集群的搭建，是在`副本集群`的基础之上做的额外配置，也就是说必选先搭建好`副本集群`才能搭建镜像集群。这个额外配置就是需要创建一个`策略`。\n\n```markdown\n# 0.策略说明\n\trabbitmqctl set_policy [--vhost <vhost>] [--priority <priority>] [--apply-to <apply-to>] <name> <pattern> <definition>\n\t--vhost：可选参数，针对指定virutal host下的queue进行设置\n\t--priority：可选参数，policy的优先级，越大越优先\n\t--appliy-to：可选参数，表示策略应用的对象，后面跟queues|exchanges|all。\n\tname：策略名称，唯一标识。\n\tpattern：匹配队列的正则表达式。\n\tdefinition：镜像定义，包括三个部分：ha-mode、ha-params、ha-sync-mode\n\t\tha-mode：镜像队列模式，可选值：all/exaclty/nodes\n\t\t\tall：表示在集群的所有节点上进行镜像\n\t\t\texactly：表示在指定个数的节点上进行镜像，节点个数通过ha-params指定\n\t\t\tnodes：表示在指定节点上进行镜像，节点名称通过ha-params指定\n\t\tha-params：ha-mode需要用到的参数\n\t\tha-sync-mode：队列同步方式，可选值为：automatic/manual\n\t\t\tautomatic：自动同步\n\t\t\tmanual：用户触发同步\n# 1.查看当前策略\n\trabbitmqctl list_policies\n# 2.添加策略\n\trabbitmqctl set_policy ha-all '^hello' '{\"ha-mode\":\"all\",\"ha-sync-mode\":\"automatic\"}'\n\t说明：策略正则表示为\"^\"表示匹配所有队列，\"^hello\"表示匹配hello开头的队列\n# 3.删除策略\n\trabbitmqctl clear_policy ha-all\n```\n\n**搭建成功：**\n\n![image](https://img-blog.csdnimg.cn/0a123778671941e99aac309f1180c599.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n![image](https://img-blog.csdnimg.cn/4c70637a590c4150b0f2296b65bc3837.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n","slug":"RabbitMQ基础与集群实战","published":1,"updated":"2021-12-26T07:59:10.135Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxmyxe9m0001cjs65kd96hvf","content":"<h1 id=\"RabbitMQ实战教程\"><a href=\"#RabbitMQ实战教程\" class=\"headerlink\" title=\"RabbitMQ实战教程\"></a>RabbitMQ实战教程</h1><blockquote>\n<p>视频：<a href=\"https://www.bilibili.com/video/BV1dE411K7MG?from=search&amp;seid=15593601763323732951&amp;spm_id_from=333.337.0.0\">https://www.bilibili.com/video/BV1dE411K7MG?from=search&amp;seid=15593601763323732951&amp;spm_id_from=333.337.0.0</a></p>\n</blockquote>\n<h2 id=\"1-MQ引言\"><a href=\"#1-MQ引言\" class=\"headerlink\" title=\"1.MQ引言\"></a>1.MQ引言</h2><h3 id=\"1-1-什么是MQ\"><a href=\"#1-1-什么是MQ\" class=\"headerlink\" title=\"1.1 什么是MQ\"></a>1.1 什么是MQ</h3><p>​        <code>MQ</code>(Message Queue)：翻译为<code>消息队列</code>，通过典型的<code>生产者</code>和<code>消费者</code>模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的消费和生产，没有业务逻辑的侵入，轻松的实现系统间的解藕。别名为：<code>消息中间件</code>，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p>\n<h3 id=\"1-2-MQ有哪些\"><a href=\"#1-2-MQ有哪些\" class=\"headerlink\" title=\"1.2 MQ有哪些\"></a>1.2 MQ有哪些</h3><p>​        当今市面上有很多的消息中间件，如老牌的<code>ActiveMQ</code>，<code>RabbitMQ</code>，炙手可热的<code>Kafka</code>、阿里巴巴自主研发的<code>RocketMQ</code>等。</p>\n<h3 id=\"1-3-不同MQ的特点\"><a href=\"#1-3-不同MQ的特点\" class=\"headerlink\" title=\"1.3 不同MQ的特点\"></a>1.3 不同MQ的特点</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.ActiveMQ</span></span><br><span class=\"line\"><span class=\"code\">\tActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。他是一个完全支持JMS规范的消息中间件。丰富的API，多种集群架构模式让ActiveMQ称为老牌的消息中间件，在中小企业颇受欢迎。</span></span><br><span class=\"line\"><span class=\"code\"># 2.Kafka</span></span><br><span class=\"line\"><span class=\"code\">\tKafka是LinkedIn公司开源的分布式发布-订阅消息中间件，目前属于Apache顶级项目。Kafka的主要特点是基于pull模式来处理消息消费。追求高吞吐量，一开始的目的是用于日志的收集和传输。0.8版本开始支持复制，不支持事物，对消息的丢失、重复、错误没有严格的要求。适合产生大量数据的互联网服务的数据收集业务。</span></span><br><span class=\"line\"><span class=\"code\"># 3.RocketMQ</span></span><br><span class=\"line\"><span class=\"code\">\tRocketMQ是阿里开源的消息中间件。他是纯java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ的思路起源于Kafka，但并不是Kafka的一个复制，他对消息的可靠传输及事物做了优化，目前的阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流处理、binglog分发等场景。</span></span><br><span class=\"line\"><span class=\"code\"># 4.RabbitMQ</span></span><br><span class=\"line\"><span class=\"code\">\tRabbitMQ是使用Erlang语言开发的开源消息中间件系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布订阅）、可靠性、安全。AMQP协议更多用在企业内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（延时低）、可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p>\n</blockquote>\n<h2 id=\"2-RabbitMQ的引言\"><a href=\"#2-RabbitMQ的引言\" class=\"headerlink\" title=\"2.RabbitMQ的引言\"></a>2.RabbitMQ的引言</h2><h3 id=\"2-1-RabbitMQ简介\"><a href=\"#2-1-RabbitMQ简介\" class=\"headerlink\" title=\"2.1 RabbitMQ简介\"></a>2.1 RabbitMQ简介</h3><p>​        RabbitMQ是基于AMQP协议，erlang语言开发，是部署最广泛的开源消息中间件，也是最受欢迎的消息中间件之一。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/681db2b5bf6f486f8dfa258fa90aad53.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># AMQP协议（后续单独讲）</span></span><br><span class=\"line\"><span class=\"code\">\tAMQP(Advanced Message Queuing Protocol，高级消息队列协议)，在2003年被提出，在最用于解决金融领域不同平台之间消息传递的交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wrie-level protocol（链接协议）。这时其和JMS的本质差异，AMQP不从api层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t\t\t\tServer</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t+---------------------------+</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t\tVirtual Host\t\t|</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t+--------------------+  |</span></span><br><span class=\"line\"><span class=\"code\">   \t+------------+  |\t|\t+-----------+    |\t|</span></span><br><span class=\"line\"><span class=\"code\">\t| Publisher  | --------&gt;| Exchange\t|    |  |</span></span><br><span class=\"line\"><span class=\"code\">\t| Application|\t|\t|\t+-----+-----+    |  |</span></span><br><span class=\"line\"><span class=\"code\">\t+------------+\t|   | \t\t  |\t\t\t |\t|</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+  Message\t+\t |\t|\t|  Consummer  |</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+\tQueue\t+ ---------&gt;| Application |</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t+--------------------+\t|</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t+---------------------------+</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-RabbitMQ的安装\"><a href=\"#2-2-RabbitMQ的安装\" class=\"headerlink\" title=\"2.2 RabbitMQ的安装\"></a>2.2 RabbitMQ的安装</h3><p>​        本次安装的环境如下：</p>\n<ul>\n<li>系统：centos8 64位</li>\n<li>erlang：24.1.7</li>\n<li>rabbitmq：3.9.11</li>\n</ul>\n<h4 id=\"2-2-1-erlang下载\"><a href=\"#2-2-1-erlang下载\" class=\"headerlink\" title=\"2.2.1 erlang下载\"></a>2.2.1 erlang下载</h4><blockquote>\n<p>因为rabbitMQ是基于erlang开发的，所以先要下载erlang的包：<a href=\"https://github.com/rabbitmq/erlang-rpm\">https://github.com/rabbitmq/erlang-rpm</a></p>\n<p>erlang版本和rabbitmq版本对照：<a href=\"https://www.rabbitmq.com/which-erlang.html\">https://www.rabbitmq.com/which-erlang.html</a></p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/bf7aa8f5462148a99f279b03dcb493d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"iamge\"></p>\n<p>​        本次开发使用的最新的rabbitmq版本为<code>3.9.11</code>，最小支持的erlang版本为23.2，所以本次erlang使用了<code>24.1.7</code>版本</p>\n<p><img src=\"https://img-blog.csdnimg.cn/889a43dfbe3048b58c0622101762bbad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"iamge\"></p>\n<h4 id=\"2-2-2-RabbitMQ下载\"><a href=\"#2-2-2-RabbitMQ下载\" class=\"headerlink\" title=\"2.2.2 RabbitMQ下载\"></a>2.2.2 RabbitMQ下载</h4><blockquote>\n<p>rabbitmq下载地址：<a href=\"https://www.rabbitmq.com/install-rpm.html#downloads\">https://www.rabbitmq.com/install-rpm.html#downloads</a></p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/40404dec0e524d10bb9df1a1d16f9b5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h4 id=\"2-2-3-安装启动\"><a href=\"#2-2-3-安装启动\" class=\"headerlink\" title=\"2.2.3 安装启动\"></a>2.2.3 安装启动</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.将rabbitmq相关包上传到linxu服务器中</span></span><br><span class=\"line\"><span class=\"code\">\t使用scp命令上传到服务器两个包：</span></span><br><span class=\"line\"><span class=\"code\">\tscp ./erlang-24.1.7-1.el8.x86_64.rpm root@10.3.4.5:/root/</span></span><br><span class=\"line\"><span class=\"code\">\tscp ./rabbitmq-server-3.9.11-1.el8.noarch.rpm root@10.3.4.5:/root/</span></span><br><span class=\"line\"><span class=\"code\"># 2.依次安装erlang、rabbitmq</span></span><br><span class=\"line\"><span class=\"code\">\t使用rpm命令进行安装，缺少依赖会进行提示：</span></span><br><span class=\"line\"><span class=\"code\">\trpm -ivh erlang-24.1.7-1.el8.x86_64.rpm</span></span><br><span class=\"line\"><span class=\"code\">\trpm -ivn rabbitmq-server-3.9.11-1.el8.noarch.rpm</span></span><br><span class=\"line\"><span class=\"code\"># 3.修改rabbitmq的配置</span></span><br><span class=\"line\"><span class=\"code\">\t使用rpm包的方式安装时，并没有将配置文件也放到指定目录下，所以需要自行创建一个配置文件：/etc/rabbitmq/rabbitmq.conf，具体的配置内容可以参考：https://www.rabbitmq.com/configure.html#config-file-formats。</span></span><br><span class=\"line\"><span class=\"code\">\t这里我们需要修改一处：loopback_users=none，表示能够让guest用户进行远程访问。默认情况下，guest用户只能在localhost域名下访问。我们使用的是云服务器，需要使用ip进行访问，所以需要修改这个配置。</span></span><br><span class=\"line\"><span class=\"code\"># 4.开启管理控制台插件</span></span><br><span class=\"line\"><span class=\"code\">\t其实就是开启rabbitmq的一个插件：rabbitmq_management，可以让我们使用web界面管理rabbitmq。执行命令：rabbitmq-plugins enable rabbitmq_management。该命令还另外开启了2个插件：rabbitmq_management_agent、rabbitmq_web_dispatch。</span></span><br><span class=\"line\"><span class=\"code\"># 5.启动/停止/重启rabbitmq服务</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmq安装的时候，会将其设置为系统服务，使用系统服务命令即可：</span></span><br><span class=\"line\"><span class=\"code\">\tsystemctl start/stop/restart rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\"># 6.查看服务状态</span></span><br><span class=\"line\"><span class=\"code\">\tsystemctl stauts rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\">    结果如下为正常运行中：</span></span><br><span class=\"line\"><span class=\"code\">    ● rabbitmq-server.service - RabbitMQ broker</span></span><br><span class=\"line\"><span class=\"code\">       Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class=\"line\"><span class=\"code\">       Active: active (running) since Sun 2021-12-12 23:56:51 CST; 1 day 9h ago</span></span><br><span class=\"line\"><span class=\"code\">      Process: 22710 ExecStop=/usr/sbin/rabbitmqctl shutdown (code=exited, status=0/SUCCESS)</span></span><br><span class=\"line\"><span class=\"code\">     Main PID: 22758 (beam.smp)</span></span><br><span class=\"line\"><span class=\"code\">        Tasks: 23 (limit: 23722)</span></span><br><span class=\"line\"><span class=\"code\">       Memory: 94.8M</span></span><br><span class=\"line\"><span class=\"code\">       CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\">               ├─22758 /usr/lib64/erlang/erts-12.1.5/bin/beam.smp -W w -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 12800&gt;</span></span><br><span class=\"line\"><span class=\"code\">               ├─22773 erl_child_setup 32768</span></span><br><span class=\"line\"><span class=\"code\">               ├─22827 inet_gethost 4</span></span><br><span class=\"line\"><span class=\"code\">               └─22828 inet_gethost 4</span></span><br><span class=\"line\"><span class=\"code\"># 7.访问管理界面</span></span><br><span class=\"line\"><span class=\"code\"> \t默认http后台界面的端口为15672。</span></span><br><span class=\"line\"><span class=\"code\"> \thttp://10.3.4.5:15672/</span></span><br><span class=\"line\"><span class=\"code\"># 8.登陆</span></span><br><span class=\"line\"><span class=\"code\">\t账号/密码：guest/guest</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-RabbitMQ配置\"><a href=\"#3-RabbitMQ配置\" class=\"headerlink\" title=\"3.RabbitMQ配置\"></a>3.RabbitMQ配置</h2><h3 id=\"3-1-RabbitMQ管理命令行\"><a href=\"#3-1-RabbitMQ管理命令行\" class=\"headerlink\" title=\"3.1 RabbitMQ管理命令行\"></a>3.1 RabbitMQ管理命令行</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.服务管理</span></span><br><span class=\"line\"><span class=\"code\">\tsystemctl start/stop/restart rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\"># 2.管理命令行</span></span><br><span class=\"line\"><span class=\"code\">\t可以用来在不使用web管理端的情况下管理rabbitmq。</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl help // 查看所有的命令</span></span><br><span class=\"line\"><span class=\"code\"># 3.插件管理</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmq-plugins enable/list/disable</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-web管理介绍\"><a href=\"#3-2-web管理介绍\" class=\"headerlink\" title=\"3.2 web管理介绍\"></a>3.2 web管理介绍</h3><p><img src=\"https://img-blog.csdnimg.cn/6a2017fe4a3a4216a594f1d64c3a28e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<ul>\n<li><strong>Connection</strong>：连接，无论是消费者还是生产者，都要与rabbitmq建立连接才能进行消息的生产与消费。</li>\n<li><strong>Channels</strong>：通道，建立连接后，消息的投递和获取都是通过通道来进行的。</li>\n<li><strong>Exchages</strong>：交换机，用来实现消息的路有。</li>\n<li><strong>Queues</strong>：队列，消息存放于该队列中，等待消费，消费之后移除。</li>\n</ul>\n<h4 id=\"3-2-1用户和虚拟主机管理\"><a href=\"#3-2-1用户和虚拟主机管理\" class=\"headerlink\" title=\"3.2.1用户和虚拟主机管理\"></a>3.2.1用户和虚拟主机管理</h4><h5 id=\"3-2-1-1-用户\"><a href=\"#3-2-1-1-用户\" class=\"headerlink\" title=\"3.2.1.1 用户\"></a>3.2.1.1 用户</h5><p><img src=\"https://img-blog.csdnimg.cn/67b980ab25e24c75b2a6d3c9590c22ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># Tags说明：</span></span><br><span class=\"line\"><span class=\"code\">\tAdmin(超级管理员)：登录控制台，查看所有信息，并对用户、策略（policy）进行修改。</span></span><br><span class=\"line\"><span class=\"code\">\tMonitoring（监控者）：登陆控制台，查看rabbitmq的节点（进程数、内存、磁盘等使用情况）信息。</span></span><br><span class=\"line\"><span class=\"code\">\tPolicymaker（策略制定者）：登陆控制台，对policy进行管理。</span></span><br><span class=\"line\"><span class=\"code\">\tManagement（普通管理员）：登陆控制台查看信息。</span></span><br><span class=\"line\"><span class=\"code\">\t其他：无法登陆控制台，就是普通的消费者或者生产者。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-1-2-虚拟主机\"><a href=\"#3-2-1-2-虚拟主机\" class=\"headerlink\" title=\"3.2.1.2 虚拟主机\"></a>3.2.1.2 虚拟主机</h5><p><img src=\"https://img-blog.csdnimg.cn/b21620fc59f5467ebc4c0402d5e2c0df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 虚拟主机：</span></span><br><span class=\"line\"><span class=\"code\">\t为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Host）概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自都有自己的队列、交换机，互不影响。相当于MySQL中的数据库。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-1-3-用户和虚拟主机绑定\"><a href=\"#3-2-1-3-用户和虚拟主机绑定\" class=\"headerlink\" title=\"3.2.1.3 用户和虚拟主机绑定\"></a>3.2.1.3 用户和虚拟主机绑定</h5><p><img src=\"https://img-blog.csdnimg.cn/e60681b36bec47b5bba1ebde7ee8d03b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/b4808afbd6e34a8e982624a3f0b02856.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h2 id=\"4-RabbitMQ的Java客户端\"><a href=\"#4-RabbitMQ的Java客户端\" class=\"headerlink\" title=\"4.RabbitMQ的Java客户端\"></a>4.RabbitMQ的Java客户端</h2><h3 id=\"4-1-AMQP协议回顾\"><a href=\"#4-1-AMQP协议回顾\" class=\"headerlink\" title=\"4.1 AMQP协议回顾\"></a>4.1 AMQP协议回顾</h3><p><img src=\"https://img-blog.csdnimg.cn/eb827e01a84b4eea9bddb6dab2947c84.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"4-2-RabbitMQ支持的消息类型\"><a href=\"#4-2-RabbitMQ支持的消息类型\" class=\"headerlink\" title=\"4.2 RabbitMQ支持的消息类型\"></a>4.2 RabbitMQ支持的消息类型</h3><p><img src=\"https://img-blog.csdnimg.cn/40d40399960442e9a2d0d5668a6825d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"4-3-引入依赖\"><a href=\"#4-3-引入依赖\" class=\"headerlink\" title=\"4.3 引入依赖\"></a>4.3 引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.14.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-各种模型客户端代码\"><a href=\"#4-4-各种模型客户端代码\" class=\"headerlink\" title=\"4.4 各种模型客户端代码\"></a>4.4 各种模型客户端代码</h3><h4 id=\"4-4-1-Direct-直连模式\"><a href=\"#4-4-1-Direct-直连模式\" class=\"headerlink\" title=\"4.4.1 Direct-直连模式\"></a>4.4.1 Direct-直连模式</h4><p><img src=\"https://img-blog.csdnimg.cn/2401e687d01347fb9827dffb97b570c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 相关概念：</span></span><br><span class=\"line\"><span class=\"code\">\tP：provider，生产者，要发送消息的程序</span></span><br><span class=\"line\"><span class=\"code\">\tC：consumer，消费者，消费消息的程序</span></span><br><span class=\"line\"><span class=\"code\">\tQueue：队列，存储消息的地方</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * direct模式-生产者</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接点对点，也就是生产者将消息发送到队列中，消费者直接从队列中获取</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 11:34 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义队列名字</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工程</span></span><br><span class=\"line\">        ConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        connectionFactory.setHost(<span class=\"string\">&quot;101.43.52.186&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        connectionFactory.setVirtualHost(<span class=\"string\">&quot;/adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setUsername(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPassword(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = connectionFactory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 4.声明队列：队列名称，是否持久化，是否独占，额外参数</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 5.向队列发送消息：交换机名称，队列名称，额外参数，消息体</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 6.关闭资源</span></span><br><span class=\"line\">        channel.close();</span><br><span class=\"line\">        connection.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * direct模式-消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 11:34 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1 创建连接工厂，并设置基础参数</span></span><br><span class=\"line\">        ConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        connectionFactory.setHost(<span class=\"string\">&quot;101.43.52.186&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        connectionFactory.setVirtualHost(<span class=\"string\">&quot;/adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setUsername(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPassword(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2 创建连接</span></span><br><span class=\"line\">        Connection connection = connectionFactory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 3 创建通道</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 4 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4 接收消息</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调方法</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer：&quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 5 关闭资源</span></span><br><span class=\"line\">        channel.close();</span><br><span class=\"line\">        connection.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-2-Work-Queues-工作队列\"><a href=\"#4-4-2-Work-Queues-工作队列\" class=\"headerlink\" title=\"4.4.2 Work Queues-工作队列\"></a>4.4.2 Work Queues-工作队列</h4><p><img src=\"https://img-blog.csdnimg.cn/37c7326912a04ff1baaa25754a61535f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p>​        Work Queue也被称为<code>Task Queue</code>任务模型。当消息处理比较耗时时，可能消息生产的速度远远超过了消息消费的速度。长此以往，消息就会堆积，此时就可以使用Work Queue模型。让多个消费者绑定同一个队列，共同消费队列中的消息。队列中的消息一旦被消费，就会被删除，因此不会产生重复消费。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提取连接rabbitmq的工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMQUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span>    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建连接工厂</span></span><br><span class=\"line\">            ConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">            <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">            connectionFactory.setHost(<span class=\"string\">&quot;101.43.52.186&quot;</span>);</span><br><span class=\"line\">            connectionFactory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">            connectionFactory.setVirtualHost(<span class=\"string\">&quot;/adu&quot;</span>);</span><br><span class=\"line\">            connectionFactory.setUsername(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">            connectionFactory.setPassword(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 创建连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> connectionFactory.newConnection();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title\">getChannel</span><span class=\"params\">(Connection connection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.createChannel();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">(Channel channel, Connection connection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                channel.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                connection.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Work Queue模型</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 工作队列模型，应对的是消费者消费比较慢的情况，多个消费者共同消费同一个队列中的消息。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 2:02 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发消息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, (<span class=\"string\">&quot;hello work queue &quot;</span> + i).getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费消息</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\">和consumer1相同代码，修改消费输出：System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># consumer1 output...</span></span><br><span class=\"line\">consumer1: hello work queue 0</span><br><span class=\"line\">consumer1: hello work queue 2</span><br><span class=\"line\">consumer1: hello work queue 4</span><br><span class=\"line\">consumer1: hello work queue 6</span><br><span class=\"line\">consumer1: hello work queue 8</span><br><span class=\"line\"><span class=\"section\"># consumer2 output...</span></span><br><span class=\"line\">consumer2: hello work queue 1</span><br><span class=\"line\">consumer2: hello work queue 3</span><br><span class=\"line\">consumer2: hello work queue 5</span><br><span class=\"line\">consumer2: hello work queue 7</span><br><span class=\"line\">consumer2: hello work queue 9</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>​        默认情况下，RabbitMQ将按顺序依次将消息发给每个消费者，也就是说每个消费者都会收到相同数量的消息，这种平分消息的方式称为<code>循环</code>。</p>\n<h5 id=\"4-4-2-1-消息自动确认机制\"><a href=\"#4-4-2-1-消息自动确认机制\" class=\"headerlink\" title=\"4.4.2.1 消息自动确认机制\"></a>4.4.2.1 消息自动确认机制</h5><p>​        如果一个消费者在执行任务的过程中宕机，那么在以上代码中，一旦RabbitMQ将将消息传递给消费者，他就会立即标记为删除，那么该消费者中未处理的消息将丢失。我们希望在处理任务的过程中，一个消费者宕机了，能够将任务交给其他消费者处理。这时候我们就可以用到<code>消息自动确认机制</code>。也就是说，我们可以在处理完任务之后，再通知RabbitMQ可以删除该任务。</p>\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同上</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 每次只能消费一个消息</span></span><br><span class=\"line\">        channel.basicQos(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费消息</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 模拟处理消息消耗时常</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                <span class=\"comment\">// 手动确认，参数1：消息标记 参数2：是否同时确认多条，false表示每次只能确认一条</span></span><br><span class=\"line\">                channel.basicAck(envelope.getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer4</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 限制每次消费1条</span></span><br><span class=\"line\">        channel.basicQos(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费消息，autoAck改为false，表示不自动确认</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                <span class=\"comment\">// 手动确认</span></span><br><span class=\"line\">                channel.basicAck(envelope.getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># consumer1 output...</span></span><br><span class=\"line\">consumer1: hello work queue 1</span><br><span class=\"line\">consumer1: hello work queue 3</span><br><span class=\"line\">consumer1: hello work queue 5</span><br><span class=\"line\">consumer1: hello work queue 8</span><br><span class=\"line\">consumer1: hello work queue 10</span><br><span class=\"line\">consumer1: hello work queue 13</span><br><span class=\"line\">consumer1: hello work queue 15</span><br><span class=\"line\">consumer1: hello work queue 18</span><br><span class=\"line\"><span class=\"section\"># consumer2 output...</span></span><br><span class=\"line\">consumer1: hello work queue 0</span><br><span class=\"line\">consumer1: hello work queue 2</span><br><span class=\"line\">consumer1: hello work queue 4</span><br><span class=\"line\">consumer1: hello work queue 6</span><br><span class=\"line\">consumer1: hello work queue 7</span><br><span class=\"line\">consumer1: hello work queue 9</span><br><span class=\"line\">consumer1: hello work queue 11</span><br><span class=\"line\">consumer1: hello work queue 12</span><br><span class=\"line\">consumer1: hello work queue 14</span><br><span class=\"line\">consumer1: hello work queue 16</span><br><span class=\"line\">consumer1: hello work queue 17</span><br><span class=\"line\">consumer1: hello work queue 19</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>​        实现消息自动确认，需要注意两点：1）设置通道一次只能消费一条消息 2）关闭自动确认，手动确认消息</p>\n<h4 id=\"4-4-3-Publish-Subscribe-发布订阅模式\"><a href=\"#4-4-3-Publish-Subscribe-发布订阅模式\" class=\"headerlink\" title=\"4.4.3 Publish/Subscribe-发布订阅模式\"></a>4.4.3 Publish/Subscribe-发布订阅模式</h4><p><img src=\"https://img-blog.csdnimg.cn/610277d029c04fe5a3933cf79f21dcc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 消息流程：</span></span><br><span class=\"line\"><span class=\"code\">\t可以有多个消费者，每个消费者都有自己的queue（队列），每个队列都要绑定要exchange（交换机）。</span></span><br><span class=\"line\"><span class=\"code\">\t生产者发送的消息只能发送给交换机，交换机来决定发送给哪个队列，生产者无法决定。</span></span><br><span class=\"line\"><span class=\"code\">\t交换机把消息发送给绑定过的所有队列，队列的消费者都能拿到消息，实现一个消息被多个消费者消费。</span></span><br><span class=\"line\"><span class=\"code\"># 对应交换机类型：fanout</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Proudcer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishSubscriptProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;fanout&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机 交换机名称 交换机类型</span></span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息到交换机</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;hello fanout&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishSubscribeConsumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建临时队列</span></span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定交换机和队列 队列名称 交换机名称 路由</span></span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 接收消息</span></span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\">同consumer1，输出修改为：System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># consumer1 output...</span></span><br><span class=\"line\">consumer1: hello fanout, type [</span><br><span class=\"line\">consumer1: hello fanout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># consumer2 output...</span></span><br><span class=\"line\">consumer2: hello fanout, type [</span><br><span class=\"line\">consumer2: hello fanout</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-4-Routing-路由模式\"><a href=\"#4-4-4-Routing-路由模式\" class=\"headerlink\" title=\"4.4.4 Routing-路由模式\"></a>4.4.4 Routing-路由模式</h4><p>​        在发布订阅模式中，一条消息会被所有订阅的的队列消费。但是在某些场景下，我们希望不同的消息类型被不同的队列消费，这时就需要用到Routing模式的direct类型的Exchange。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 在Direct模式下：</span></span><br><span class=\"line\"><span class=\"code\">\t队列与交换机的绑定，不能是任意绑定了，而是需要指定一个Routing Keying，消息发送方在向Exchange发送消息时，也必须指定消息的Routing Key。</span></span><br><span class=\"line\"><span class=\"code\">\tExchange也不再把消息交给每一个与之绑定的队列，而是根据消息的Routing Key判断，只有队列的Routing Key和消息的Routing Key完全一致时，才会发送消息。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/8f206f2cfdb34ce89c54e042a92cc21f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 说明：</span></span><br><span class=\"line\"><span class=\"code\">\tP：Proudcer，生产者，向Exchange发送消息，同时会指定一个Routing Key。</span></span><br><span class=\"line\"><span class=\"code\">\tX：Exchange，交换机，接收生产者发送的消息，然后把消息传递给与routing key完全匹配的队列。</span></span><br><span class=\"line\"><span class=\"code\">\tC1：Consumer，消费者，其所在队列指定了需要routing key为error的消息</span></span><br><span class=\"line\"><span class=\"code\">\tC2：Consumer，消费者，其所在队列指定了需要routing key为info、error、warning的消息</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;logs_direct&quot;</span>, routingKey, <span class=\"keyword\">null</span>, String.format(<span class=\"string\">&quot;routing for type [%s]&quot;</span>, routingKey).getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingConsumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// consumer1绑定routing key 为info</span></span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingConsumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// consumer1绑定routing key 为info、error、warning</span></span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 依次发送routing key为info、error、warning结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## consummer1</span></span><br><span class=\"line\">consumer1: routing for type [info]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## consumer2</span></span><br><span class=\"line\">consumer1: routing for type [info]</span><br><span class=\"line\">consumer1: routing for type [error]</span><br><span class=\"line\">consumer1: routing for type [warning]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-5-Topics-主题（动态路由模式）\"><a href=\"#4-4-5-Topics-主题（动态路由模式）\" class=\"headerlink\" title=\"4.4.5 Topics-主题（动态路由模式）\"></a>4.4.5 Topics-主题（动态路由模式）</h4><p>​        <code>Topics</code>模式同<code>Routing</code>模式相比，都可以根据Routing Key把消息路由到不同的队列。只不过<code>Topic</code>类型的Routing Key可以使用通配符。Routing Key一般是由一个或多个单词组成，多个单词之间以‘,’分割。Exchange的类型为<code>topic</code>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e1252695c8fd433e9885d1a9e8c4e9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 通配符：</span></span><br><span class=\"line\"><span class=\"code\">\t*（star）can substitute for exactly one word。精确匹配一个单词。</span></span><br><span class=\"line\"><span class=\"code\">\t#（hash）can substitute for zero or more words。匹配零个、一个或多个单词。</span></span><br><span class=\"line\"><span class=\"code\">## 例如：</span></span><br><span class=\"line\"><span class=\"code\">\taudit.# ：匹配 audit、audit.irs、audit.irs.corporate 等。</span></span><br><span class=\"line\"><span class=\"code\">\taudit.* ：只能匹配 audit.irs。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_topics&quot;</span>, <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;user.save.now&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;logs_topics&quot;</span>, routingKey, <span class=\"keyword\">null</span>, String.format(<span class=\"string\">&quot;hello topics, routing key : [%s]&quot;</span>, routingKey).getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsConsumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs_topics&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// 队列和交换机绑定的路由为 user.*</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGE_NAME, <span class=\"string\">&quot;user.*&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsConsumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs_topics&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// 队列和交换机绑定的路由为 user.*</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGE_NAME, <span class=\"string\">&quot;user.#&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 依次发送routing key为user.save、user、user.save.now的结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## conumser1:</span></span><br><span class=\"line\">consumer1: hello topics, routing key : [user.save]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## consumer2:</span></span><br><span class=\"line\">consumer2: hello topics, routing key : [user.save]</span><br><span class=\"line\">consumer2: hello topics, routing key : [user]</span><br><span class=\"line\">consumer2: hello topics, routing key : [user.save.now]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-SpringBoot重使用RabbitMQ\"><a href=\"#5-SpringBoot重使用RabbitMQ\" class=\"headerlink\" title=\"5.SpringBoot重使用RabbitMQ\"></a>5.SpringBoot重使用RabbitMQ</h2><h3 id=\"5-1-搭建环境\"><a href=\"#5-1-搭建环境\" class=\"headerlink\" title=\"5.1 搭建环境\"></a>5.1 搭建环境</h3><h4 id=\"5-1-1-引入依赖\"><a href=\"#5-1-1-引入依赖\" class=\"headerlink\" title=\"5.1.1 引入依赖\"></a>5.1.1 引入依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-1-2-配置信息\"><a href=\"#5-1-2-配置信息\" class=\"headerlink\" title=\"5.1.2 配置信息\"></a>5.1.2 配置信息</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">adu-rabbitmq</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">10.2</span><span class=\"number\">.3</span><span class=\"number\">.4</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">5672</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">adu</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">adu</span></span><br><span class=\"line\">    <span class=\"attr\">virtual-host:</span> <span class=\"string\">/adu</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-各种模型客户端代码\"><a href=\"#5-2-各种模型客户端代码\" class=\"headerlink\" title=\"5.2 各种模型客户端代码\"></a>5.2 各种模型客户端代码</h3><h4 id=\"5-2-1-Hello-World-直连模型\"><a href=\"#5-2-1-Hello-World-直连模型\" class=\"headerlink\" title=\"5.2.1 Hello World-直连模型\"></a>5.2.1 Hello World-直连模型</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * direct直连模式</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 6:30 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;hello&quot;))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorldConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-2-Work-Queue-工作队列模式\"><a href=\"#5-2-2-Work-Queue-工作队列模式\" class=\"headerlink\" title=\"5.2.2 Work Queue - 工作队列模式\"></a>5.2.2 Work Queue - 工作队列模式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Work Queue模式-消费者</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 循环模式，每个消费者得到的消息数相同</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 6:36 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;work&quot;, durable = &quot;true&quot;, exclusive = &quot;false&quot;, autoDelete = &quot;false&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;work&quot;, durable = &quot;true&quot;, exclusive = &quot;false&quot;, autoDelete = &quot;false&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-3-Publish-Subscribe-发布订阅模式\"><a href=\"#5-2-3-Publish-Subscribe-发布订阅模式\" class=\"headerlink\" title=\"5.2.3 Publish/Subscribe - 发布订阅模式\"></a>5.2.3 Publish/Subscribe - 发布订阅模式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Publish/Subscribe模式</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用交换机，将消息发给所有的绑定的队列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 6:44 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishSubscribeConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 没有参数的，表示临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs&quot;, type = &quot;fanout&quot;) // 交换机</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 没有参数的，表示临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs&quot;, type = &quot;fanout&quot;) // 交换机</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-4-Routing-路由模式（direct）\"><a href=\"#5-2-4-Routing-路由模式（direct）\" class=\"headerlink\" title=\"5.2.4 Routing - 路由模式（direct）\"></a>5.2.4 Routing - 路由模式（direct）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Routing 模式 - 消费者</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Exchange类型：direct</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 7:01 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_direct&quot;, type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &quot;info&quot; // routing key</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_direct&quot;, type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;info&quot;, &quot;error&quot;, &quot;warning&quot;&#125; // routing key</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_direct&quot;, type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;warning&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive3</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer3: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-5-Topics-主题（动态路由）模式\"><a href=\"#5-2-5-Topics-主题（动态路由）模式\" class=\"headerlink\" title=\"5.2.5 Topics - 主题（动态路由）模式\"></a>5.2.5 Topics - 主题（动态路由）模式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Topics模式 -消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Exchange的类型为：topic</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 7:16 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_topics&quot;, type = &quot;topic&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;user.*&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_topics&quot;, type = &quot;topic&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;user.#&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-6-客户端测试代码\"><a href=\"#5-2-6-客户端测试代码\" class=\"headerlink\" title=\"5.2.6 客户端测试代码\"></a>5.2.6 客户端测试代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产端没有指定交换机，只有routing key和object。通过生产端的routing key和消费端的队列匹配</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = RabbitMQApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMQApplicationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直连模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testHelloWorld</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;hello spring boot starter amqp...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Work Queue模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testWorkQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            rabbitTemplate.convertAndSend(<span class=\"string\">&quot;work&quot;</span>, <span class=\"string\">&quot;hello work queue&quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Publish/Subscribe模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPublishSubscribe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            rabbitTemplate.convertAndSend(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;hello publish subscribe &quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Routing模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testRouting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;logs_direct&quot;</span>, routingKey, <span class=\"string\">&quot;hello routing, type=&quot;</span> + routingKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Topics模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopics</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;user.save&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;logs_topics&quot;</span>, routingKey, <span class=\"string\">&quot;hello topics, type=&quot;</span> + routingKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-MQ的应用场景\"><a href=\"#6-MQ的应用场景\" class=\"headerlink\" title=\"6.MQ的应用场景\"></a>6.MQ的应用场景</h2><h3 id=\"6-1-异步处理\"><a href=\"#6-1-异步处理\" class=\"headerlink\" title=\"6.1 异步处理\"></a>6.1 异步处理</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 场景说明：</span></span><br><span class=\"line\"><span class=\"code\">\t用户注册后，需要发送邮件和注册短信，传统的做法有2种：1）串行方式 2）并行方式</span></span><br><span class=\"line\"><span class=\"code\">## 串行方式</span></span><br><span class=\"line\"><span class=\"code\">\t将注册信息写入数据库后，再发送邮件，再注册短信，以上三个任务全部返回结果后，才返回给客户端。这里有一个问题，邮件、短信并不是必须的，它只是一个通知，而这种做法需要让客户端等待没有必要等待的东西。</span></span><br><span class=\"line\"><span class=\"code\">## 并行方式</span></span><br><span class=\"line\"><span class=\"code\">\t将注册信息写入数据库后，发送邮件的同时，发送短信。以上三个任务完成后，返回给客户端，并行的方式能提高处理的效率。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/c0e203b0f649433984cbd50434586974.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/17a5dbf434ee4c76a2745392fb70a774.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 消息队列：</span></span><br><span class=\"line\"><span class=\"code\">\t除了以上提到的2种传统方式之外，我们还可以选择 消息队列 的形式。因为发送邮件和发送短信不是必须的，所以我们可以使用消息队列的形式，进行异步处理，相对于并行方式，减少了发送邮件或者短信的时间，相当于只有 注册信息写入数据库 + 写入消息队列 这个操作的耗时。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/c2bad0734fff4638acb0f0e7aa222327.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"6-2-应用解藕\"><a href=\"#6-2-应用解藕\" class=\"headerlink\" title=\"6.2 应用解藕\"></a>6.2 应用解藕</h3><p><img src=\"https://img-blog.csdnimg.cn/4096d6dc33ff48e380b3ec742e513b3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 场景：</span></span><br><span class=\"line\"><span class=\"code\">\t双十一是购物节，用户下单后，订单系统需要通知库存系统，传统做法是订单系统调用库存系统提供的接口。</span></span><br><span class=\"line\"><span class=\"code\"># 缺点：</span></span><br><span class=\"line\"><span class=\"code\">\t这种做法有个缺点：当库存系统异常时，订单系统就无法使用。订单系统和库存系统就出现了耦合。解决方法引入消息队列。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/129b02a2439545ed8f748471c0f21b8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 引入消息队列：</span></span><br><span class=\"line\"><span class=\"code\">\t订单系统：用户下单后，订单系统完成持久化后，将消息写入 消息队列 ，返回用户下单成功。</span></span><br><span class=\"line\"><span class=\"code\">\t库存系统：订阅下单消息，获取下单消息，进行库存操作。就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-3-流量削峰\"><a href=\"#6-3-流量削峰\" class=\"headerlink\" title=\"6.3 流量削峰\"></a>6.3 流量削峰</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 场景：</span></span><br><span class=\"line\"><span class=\"code\">\t秒杀活动，一般会因为流量过大，导致应用挂掉。为了解决这个问题，一般在应用之前加入消息队列。</span></span><br><span class=\"line\"><span class=\"code\"># 作用：</span></span><br><span class=\"line\"><span class=\"code\">\t1.可以控制活动人数，超过一定阈值的订单直接丢弃</span></span><br><span class=\"line\"><span class=\"code\">\t2.可以缓解短时间的高流量压垮应用（程序按自己处理能力获取订单）。</span></span><br><span class=\"line\"><span class=\"code\"># 流程：</span></span><br><span class=\"line\"><span class=\"code\">\t1.用户的请求，服务器收到之后先加入到消息队列。假如超过消息队列的最大长度，则直接丢弃用户请求或者跳转到错误页面。</span></span><br><span class=\"line\"><span class=\"code\">\t2.秒杀业务根据消息队列中的请求信息，再做后续的处理。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-RabbitMQ集群\"><a href=\"#7-RabbitMQ集群\" class=\"headerlink\" title=\"7.RabbitMQ集群\"></a>7.RabbitMQ集群</h2><h3 id=\"7-1-集群架构（副本集群）\"><a href=\"#7-1-集群架构（副本集群）\" class=\"headerlink\" title=\"7.1 集群架构（副本集群）\"></a>7.1 集群架构（副本集群）</h3><blockquote>\n<p>默认情况下：RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是 消息队列，默认情况下，消息队列位于一个节点上，尽管他们可以从任意节点上看到和访问。–官网</p>\n<p>也就是说，集群架构的方式只能在节点之间同步（复制）交换机等基本信息，无法同步队列信息。而队列信息是保存数据的地方，如果无法在节点之间进行复制，那么集群将失去一些意义。</p>\n</blockquote>\n<h4 id=\"7-1-1-架构图\"><a href=\"#7-1-1-架构图\" class=\"headerlink\" title=\"7.1.1 架构图\"></a>7.1.1 架构图</h4><p><img src=\"https://img-blog.csdnimg.cn/1b08e25a4092495f8412a4dd0801b780.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 核心解决问题：</span></span><br><span class=\"line\"><span class=\"code\">\t当集群中某一时刻Master节点宕机，可以对Queue中信息进行备份。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-1-2-集群搭建\"><a href=\"#7-1-2-集群搭建\" class=\"headerlink\" title=\"7.1.2 集群搭建\"></a>7.1.2 集群搭建</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS：使用docker安装</span><br><span class=\"line\"><span class=\"section\"># 0.集群规划</span></span><br><span class=\"line\"><span class=\"code\">\tnode1:  172.18.0.2 5672 15672 \t\tmaster 主节点</span></span><br><span class=\"line\"><span class=\"code\">\tnode2:\t172.18.0.3 5673 15673\t\trepl1  副本节点</span></span><br><span class=\"line\"><span class=\"code\">\tnode3:\t172.18.0.4 5674 15674\t \trepl2  副本节点</span></span><br><span class=\"line\"><span class=\"code\"># 1.克隆三台主机名和ip映射，并修改各个虚拟机的hostname</span></span><br><span class=\"line\"><span class=\"code\">\t创建网络：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker network create rabbit-net</span></span><br><span class=\"line\"><span class=\"code\">\t创建容器：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker run -d --privileged=true --hostname node1 --name node1 -p 15672:15672 -p 5672:5672 --network rabbit-net centos:8.2.2004 /sbin/init</span></span><br><span class=\"line\"><span class=\"code\">\t进入容器：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker exec -it node/node1/node2 /bin/bash</span></span><br><span class=\"line\"><span class=\"code\">\t复制erlang、rabbit的rpm包到容器：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker cp ./erlang.xxx.rpm node1:/</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker cp ./rabbitmq.xxx.rpm node1:/</span></span><br><span class=\"line\"><span class=\"code\">\t安装：</span></span><br><span class=\"line\"><span class=\"code\">\t\trpm -ihv erlang.xxx.rpm</span></span><br><span class=\"line\"><span class=\"code\">\t\trpm -ivh rabbitmq.xxx.rpm --nodeps --force</span></span><br><span class=\"line\"><span class=\"code\">\t配置：</span></span><br><span class=\"line\"><span class=\"code\">\t\t在/etc/hosts加入各个节点的ip和域名对应关系。</span></span><br><span class=\"line\"><span class=\"code\">\t问题：</span></span><br><span class=\"line\"><span class=\"code\">\t\t参考：https://blog.csdn.net/weixin_42181917/article/details/105579288</span></span><br><span class=\"line\"><span class=\"code\">\t\t1.System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.Failed to create bus connection: Host is down</span></span><br><span class=\"line\"><span class=\"code\">\t\t解决：创建容器使用 /sbin/init</span></span><br><span class=\"line\"><span class=\"code\">\t\t2.Could not set property: Failed to set static hostname: Device or resource busy</span></span><br><span class=\"line\"><span class=\"code\">\t\t解决：退出容器，重新进入在设置一次</span></span><br><span class=\"line\"><span class=\"code\">\t\t\thostnamectl set-hostname node/node1/node2</span></span><br><span class=\"line\"><span class=\"code\">\t\t\texit</span></span><br><span class=\"line\"><span class=\"code\">\t\t\thostnamectl set-hostname node/node1/node2</span></span><br><span class=\"line\"><span class=\"code\"># 2.三台机器安装rabbitmq，并同步cookie文件</span></span><br><span class=\"line\"><span class=\"code\">\tdocker cp 命令将宿主机中的erlang和rabbitmq的rpm包都上传到虚拟机中，启动rabbitmq。</span></span><br><span class=\"line\"><span class=\"code\">\tdocker cp 命令将node1节点中的 /var/lib/rabbitmq/.erlang.cookie文件复制到宿主机，再通过宿主机复制到node1和node2.</span></span><br><span class=\"line\"><span class=\"code\">\t这里需要注意看是否.erlang.cookie文件的权限是否和node相同：chown、chgrp 命令可以修改权限。</span></span><br><span class=\"line\"><span class=\"code\"># 3.查看cookie文件是否一致</span></span><br><span class=\"line\"><span class=\"code\">\t进入三个节点的虚拟机中，执行: cat /var/lib/rabbitmq/.erlang.cookie，查看内容是否一致。</span></span><br><span class=\"line\"><span class=\"code\"># 4.后台启动rabbit</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmq-server -detached</span></span><br><span class=\"line\"><span class=\"code\"># 5.在node2和node3执行加入集群命令</span></span><br><span class=\"line\"><span class=\"code\">\t1.关闭\t\trabbitmqctl stop_app</span></span><br><span class=\"line\"><span class=\"code\">\t2.加入集群\t   rabbitmqctl join_cluster rabbit@node</span></span><br><span class=\"line\"><span class=\"code\">\t3.启动服务\t   rabbitmqctl start_app</span></span><br><span class=\"line\"><span class=\"code\">\t</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>搭建成功：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4e5b989ee58b4a63816087ee87cb34d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c9e21a1431b74730908aefb32fdc5cbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"7-2-镜像集群\"><a href=\"#7-2-镜像集群\" class=\"headerlink\" title=\"7.2 镜像集群\"></a>7.2 镜像集群</h3><blockquote>\n<p>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间自动进行同步。且如果其中一个节点不可用，并不会导致消息丢失或者服务不可用的情况，提升MQ集群整体的高可用性。–摘自官网</p>\n</blockquote>\n<h4 id=\"7-2-1-架构图\"><a href=\"#7-2-1-架构图\" class=\"headerlink\" title=\"7.2.1 架构图\"></a>7.2.1 架构图</h4><p><img src=\"https://img-blog.csdnimg.cn/677182699180463baa2a64e582a7042c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h4 id=\"7-2-2-集群搭建\"><a href=\"#7-2-2-集群搭建\" class=\"headerlink\" title=\"7.2.2 集群搭建\"></a>7.2.2 集群搭建</h4><p>​        镜像集群的搭建，是在<code>副本集群</code>的基础之上做的额外配置，也就是说必选先搭建好<code>副本集群</code>才能搭建镜像集群。这个额外配置就是需要创建一个<code>策略</code>。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 0.策略说明</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl set_policy [--vhost &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt; &lt;definition&gt;</span></span><br><span class=\"line\"><span class=\"code\">\t--vhost：可选参数，针对指定virutal host下的queue进行设置</span></span><br><span class=\"line\"><span class=\"code\">\t--priority：可选参数，policy的优先级，越大越优先</span></span><br><span class=\"line\"><span class=\"code\">\t--appliy-to：可选参数，表示策略应用的对象，后面跟queues|exchanges|all。</span></span><br><span class=\"line\"><span class=\"code\">\tname：策略名称，唯一标识。</span></span><br><span class=\"line\"><span class=\"code\">\tpattern：匹配队列的正则表达式。</span></span><br><span class=\"line\"><span class=\"code\">\tdefinition：镜像定义，包括三个部分：ha-mode、ha-params、ha-sync-mode</span></span><br><span class=\"line\"><span class=\"code\">\t\tha-mode：镜像队列模式，可选值：all/exaclty/nodes</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tall：表示在集群的所有节点上进行镜像</span></span><br><span class=\"line\"><span class=\"code\">\t\t\texactly：表示在指定个数的节点上进行镜像，节点个数通过ha-params指定</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tnodes：表示在指定节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class=\"line\"><span class=\"code\">\t\tha-params：ha-mode需要用到的参数</span></span><br><span class=\"line\"><span class=\"code\">\t\tha-sync-mode：队列同步方式，可选值为：automatic/manual</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tautomatic：自动同步</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tmanual：用户触发同步</span></span><br><span class=\"line\"><span class=\"code\"># 1.查看当前策略</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl list_policies</span></span><br><span class=\"line\"><span class=\"code\"># 2.添加策略</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl set_policy ha-all &#x27;^hello&#x27; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"code\">\t说明：策略正则表示为&quot;^&quot;表示匹配所有队列，&quot;^hello&quot;表示匹配hello开头的队列</span></span><br><span class=\"line\"><span class=\"code\"># 3.删除策略</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl clear_policy ha-all</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>搭建成功：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0a123778671941e99aac309f1180c599.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4c70637a590c4150b0f2296b65bc3837.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RabbitMQ实战教程\"><a href=\"#RabbitMQ实战教程\" class=\"headerlink\" title=\"RabbitMQ实战教程\"></a>RabbitMQ实战教程</h1><blockquote>\n<p>视频：<a href=\"https://www.bilibili.com/video/BV1dE411K7MG?from=search&amp;seid=15593601763323732951&amp;spm_id_from=333.337.0.0\">https://www.bilibili.com/video/BV1dE411K7MG?from=search&amp;seid=15593601763323732951&amp;spm_id_from=333.337.0.0</a></p>\n</blockquote>\n<h2 id=\"1-MQ引言\"><a href=\"#1-MQ引言\" class=\"headerlink\" title=\"1.MQ引言\"></a>1.MQ引言</h2><h3 id=\"1-1-什么是MQ\"><a href=\"#1-1-什么是MQ\" class=\"headerlink\" title=\"1.1 什么是MQ\"></a>1.1 什么是MQ</h3><p>​        <code>MQ</code>(Message Queue)：翻译为<code>消息队列</code>，通过典型的<code>生产者</code>和<code>消费者</code>模型，生产者不断向消息队列中生产消息，消费者不断从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的消费和生产，没有业务逻辑的侵入，轻松的实现系统间的解藕。别名为：<code>消息中间件</code>，通过利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。</p>\n<h3 id=\"1-2-MQ有哪些\"><a href=\"#1-2-MQ有哪些\" class=\"headerlink\" title=\"1.2 MQ有哪些\"></a>1.2 MQ有哪些</h3><p>​        当今市面上有很多的消息中间件，如老牌的<code>ActiveMQ</code>，<code>RabbitMQ</code>，炙手可热的<code>Kafka</code>、阿里巴巴自主研发的<code>RocketMQ</code>等。</p>\n<h3 id=\"1-3-不同MQ的特点\"><a href=\"#1-3-不同MQ的特点\" class=\"headerlink\" title=\"1.3 不同MQ的特点\"></a>1.3 不同MQ的特点</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.ActiveMQ</span></span><br><span class=\"line\"><span class=\"code\">\tActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线。他是一个完全支持JMS规范的消息中间件。丰富的API，多种集群架构模式让ActiveMQ称为老牌的消息中间件，在中小企业颇受欢迎。</span></span><br><span class=\"line\"><span class=\"code\"># 2.Kafka</span></span><br><span class=\"line\"><span class=\"code\">\tKafka是LinkedIn公司开源的分布式发布-订阅消息中间件，目前属于Apache顶级项目。Kafka的主要特点是基于pull模式来处理消息消费。追求高吞吐量，一开始的目的是用于日志的收集和传输。0.8版本开始支持复制，不支持事物，对消息的丢失、重复、错误没有严格的要求。适合产生大量数据的互联网服务的数据收集业务。</span></span><br><span class=\"line\"><span class=\"code\"># 3.RocketMQ</span></span><br><span class=\"line\"><span class=\"code\">\tRocketMQ是阿里开源的消息中间件。他是纯java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ的思路起源于Kafka，但并不是Kafka的一个复制，他对消息的可靠传输及事物做了优化，目前的阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流处理、binglog分发等场景。</span></span><br><span class=\"line\"><span class=\"code\"># 4.RabbitMQ</span></span><br><span class=\"line\"><span class=\"code\">\tRabbitMQ是使用Erlang语言开发的开源消息中间件系统，基于AMQP协议来实现。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布订阅）、可靠性、安全。AMQP协议更多用在企业内对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>RabbitMQ比Kafka可靠，Kafka更适合IO高吞吐的处理，一般应用在大数据日志处理或对实时性（延时低）、可靠性（少量丢数据）要求稍低的场景使用，比如ELK日志收集。</p>\n</blockquote>\n<h2 id=\"2-RabbitMQ的引言\"><a href=\"#2-RabbitMQ的引言\" class=\"headerlink\" title=\"2.RabbitMQ的引言\"></a>2.RabbitMQ的引言</h2><h3 id=\"2-1-RabbitMQ简介\"><a href=\"#2-1-RabbitMQ简介\" class=\"headerlink\" title=\"2.1 RabbitMQ简介\"></a>2.1 RabbitMQ简介</h3><p>​        RabbitMQ是基于AMQP协议，erlang语言开发，是部署最广泛的开源消息中间件，也是最受欢迎的消息中间件之一。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/681db2b5bf6f486f8dfa258fa90aad53.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># AMQP协议（后续单独讲）</span></span><br><span class=\"line\"><span class=\"code\">\tAMQP(Advanced Message Queuing Protocol，高级消息队列协议)，在2003年被提出，在最用于解决金融领域不同平台之间消息传递的交互问题。顾名思义，AMQP是一种协议，更准确的说是一种binary wrie-level protocol（链接协议）。这时其和JMS的本质差异，AMQP不从api层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t\t\t\tServer</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t+---------------------------+</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t\tVirtual Host\t\t|</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t+--------------------+  |</span></span><br><span class=\"line\"><span class=\"code\">   \t+------------+  |\t|\t+-----------+    |\t|</span></span><br><span class=\"line\"><span class=\"code\">\t| Publisher  | --------&gt;| Exchange\t|    |  |</span></span><br><span class=\"line\"><span class=\"code\">\t| Application|\t|\t|\t+-----+-----+    |  |</span></span><br><span class=\"line\"><span class=\"code\">\t+------------+\t|   | \t\t  |\t\t\t |\t|</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+  Message\t+\t |\t|\t|  Consummer  |</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+\tQueue\t+ ---------&gt;| Application |</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t|\t+-----------+\t |\t|\t+-------------+</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t|\t+--------------------+\t|</span></span><br><span class=\"line\"><span class=\"code\">\t\t\t\t\t+---------------------------+</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-RabbitMQ的安装\"><a href=\"#2-2-RabbitMQ的安装\" class=\"headerlink\" title=\"2.2 RabbitMQ的安装\"></a>2.2 RabbitMQ的安装</h3><p>​        本次安装的环境如下：</p>\n<ul>\n<li>系统：centos8 64位</li>\n<li>erlang：24.1.7</li>\n<li>rabbitmq：3.9.11</li>\n</ul>\n<h4 id=\"2-2-1-erlang下载\"><a href=\"#2-2-1-erlang下载\" class=\"headerlink\" title=\"2.2.1 erlang下载\"></a>2.2.1 erlang下载</h4><blockquote>\n<p>因为rabbitMQ是基于erlang开发的，所以先要下载erlang的包：<a href=\"https://github.com/rabbitmq/erlang-rpm\">https://github.com/rabbitmq/erlang-rpm</a></p>\n<p>erlang版本和rabbitmq版本对照：<a href=\"https://www.rabbitmq.com/which-erlang.html\">https://www.rabbitmq.com/which-erlang.html</a></p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/bf7aa8f5462148a99f279b03dcb493d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"iamge\"></p>\n<p>​        本次开发使用的最新的rabbitmq版本为<code>3.9.11</code>，最小支持的erlang版本为23.2，所以本次erlang使用了<code>24.1.7</code>版本</p>\n<p><img src=\"https://img-blog.csdnimg.cn/889a43dfbe3048b58c0622101762bbad.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"iamge\"></p>\n<h4 id=\"2-2-2-RabbitMQ下载\"><a href=\"#2-2-2-RabbitMQ下载\" class=\"headerlink\" title=\"2.2.2 RabbitMQ下载\"></a>2.2.2 RabbitMQ下载</h4><blockquote>\n<p>rabbitmq下载地址：<a href=\"https://www.rabbitmq.com/install-rpm.html#downloads\">https://www.rabbitmq.com/install-rpm.html#downloads</a></p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/40404dec0e524d10bb9df1a1d16f9b5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h4 id=\"2-2-3-安装启动\"><a href=\"#2-2-3-安装启动\" class=\"headerlink\" title=\"2.2.3 安装启动\"></a>2.2.3 安装启动</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.将rabbitmq相关包上传到linxu服务器中</span></span><br><span class=\"line\"><span class=\"code\">\t使用scp命令上传到服务器两个包：</span></span><br><span class=\"line\"><span class=\"code\">\tscp ./erlang-24.1.7-1.el8.x86_64.rpm root@10.3.4.5:/root/</span></span><br><span class=\"line\"><span class=\"code\">\tscp ./rabbitmq-server-3.9.11-1.el8.noarch.rpm root@10.3.4.5:/root/</span></span><br><span class=\"line\"><span class=\"code\"># 2.依次安装erlang、rabbitmq</span></span><br><span class=\"line\"><span class=\"code\">\t使用rpm命令进行安装，缺少依赖会进行提示：</span></span><br><span class=\"line\"><span class=\"code\">\trpm -ivh erlang-24.1.7-1.el8.x86_64.rpm</span></span><br><span class=\"line\"><span class=\"code\">\trpm -ivn rabbitmq-server-3.9.11-1.el8.noarch.rpm</span></span><br><span class=\"line\"><span class=\"code\"># 3.修改rabbitmq的配置</span></span><br><span class=\"line\"><span class=\"code\">\t使用rpm包的方式安装时，并没有将配置文件也放到指定目录下，所以需要自行创建一个配置文件：/etc/rabbitmq/rabbitmq.conf，具体的配置内容可以参考：https://www.rabbitmq.com/configure.html#config-file-formats。</span></span><br><span class=\"line\"><span class=\"code\">\t这里我们需要修改一处：loopback_users=none，表示能够让guest用户进行远程访问。默认情况下，guest用户只能在localhost域名下访问。我们使用的是云服务器，需要使用ip进行访问，所以需要修改这个配置。</span></span><br><span class=\"line\"><span class=\"code\"># 4.开启管理控制台插件</span></span><br><span class=\"line\"><span class=\"code\">\t其实就是开启rabbitmq的一个插件：rabbitmq_management，可以让我们使用web界面管理rabbitmq。执行命令：rabbitmq-plugins enable rabbitmq_management。该命令还另外开启了2个插件：rabbitmq_management_agent、rabbitmq_web_dispatch。</span></span><br><span class=\"line\"><span class=\"code\"># 5.启动/停止/重启rabbitmq服务</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmq安装的时候，会将其设置为系统服务，使用系统服务命令即可：</span></span><br><span class=\"line\"><span class=\"code\">\tsystemctl start/stop/restart rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\"># 6.查看服务状态</span></span><br><span class=\"line\"><span class=\"code\">\tsystemctl stauts rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\">    结果如下为正常运行中：</span></span><br><span class=\"line\"><span class=\"code\">    ● rabbitmq-server.service - RabbitMQ broker</span></span><br><span class=\"line\"><span class=\"code\">       Loaded: loaded (/usr/lib/systemd/system/rabbitmq-server.service; disabled; vendor preset: disabled)</span></span><br><span class=\"line\"><span class=\"code\">       Active: active (running) since Sun 2021-12-12 23:56:51 CST; 1 day 9h ago</span></span><br><span class=\"line\"><span class=\"code\">      Process: 22710 ExecStop=/usr/sbin/rabbitmqctl shutdown (code=exited, status=0/SUCCESS)</span></span><br><span class=\"line\"><span class=\"code\">     Main PID: 22758 (beam.smp)</span></span><br><span class=\"line\"><span class=\"code\">        Tasks: 23 (limit: 23722)</span></span><br><span class=\"line\"><span class=\"code\">       Memory: 94.8M</span></span><br><span class=\"line\"><span class=\"code\">       CGroup: /system.slice/rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\">               ├─22758 /usr/lib64/erlang/erts-12.1.5/bin/beam.smp -W w -MBas ageffcbf -MHas ageffcbf -MBlmbcs 512 -MHlmbcs 512 -MMmcs 30 -P 1048576 -t 5000000 -stbt db -zdbbl 12800&gt;</span></span><br><span class=\"line\"><span class=\"code\">               ├─22773 erl_child_setup 32768</span></span><br><span class=\"line\"><span class=\"code\">               ├─22827 inet_gethost 4</span></span><br><span class=\"line\"><span class=\"code\">               └─22828 inet_gethost 4</span></span><br><span class=\"line\"><span class=\"code\"># 7.访问管理界面</span></span><br><span class=\"line\"><span class=\"code\"> \t默认http后台界面的端口为15672。</span></span><br><span class=\"line\"><span class=\"code\"> \thttp://10.3.4.5:15672/</span></span><br><span class=\"line\"><span class=\"code\"># 8.登陆</span></span><br><span class=\"line\"><span class=\"code\">\t账号/密码：guest/guest</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-RabbitMQ配置\"><a href=\"#3-RabbitMQ配置\" class=\"headerlink\" title=\"3.RabbitMQ配置\"></a>3.RabbitMQ配置</h2><h3 id=\"3-1-RabbitMQ管理命令行\"><a href=\"#3-1-RabbitMQ管理命令行\" class=\"headerlink\" title=\"3.1 RabbitMQ管理命令行\"></a>3.1 RabbitMQ管理命令行</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 1.服务管理</span></span><br><span class=\"line\"><span class=\"code\">\tsystemctl start/stop/restart rabbitmq-server.service</span></span><br><span class=\"line\"><span class=\"code\"># 2.管理命令行</span></span><br><span class=\"line\"><span class=\"code\">\t可以用来在不使用web管理端的情况下管理rabbitmq。</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl help // 查看所有的命令</span></span><br><span class=\"line\"><span class=\"code\"># 3.插件管理</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmq-plugins enable/list/disable</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-web管理介绍\"><a href=\"#3-2-web管理介绍\" class=\"headerlink\" title=\"3.2 web管理介绍\"></a>3.2 web管理介绍</h3><p><img src=\"https://img-blog.csdnimg.cn/6a2017fe4a3a4216a594f1d64c3a28e6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<ul>\n<li><strong>Connection</strong>：连接，无论是消费者还是生产者，都要与rabbitmq建立连接才能进行消息的生产与消费。</li>\n<li><strong>Channels</strong>：通道，建立连接后，消息的投递和获取都是通过通道来进行的。</li>\n<li><strong>Exchages</strong>：交换机，用来实现消息的路有。</li>\n<li><strong>Queues</strong>：队列，消息存放于该队列中，等待消费，消费之后移除。</li>\n</ul>\n<h4 id=\"3-2-1用户和虚拟主机管理\"><a href=\"#3-2-1用户和虚拟主机管理\" class=\"headerlink\" title=\"3.2.1用户和虚拟主机管理\"></a>3.2.1用户和虚拟主机管理</h4><h5 id=\"3-2-1-1-用户\"><a href=\"#3-2-1-1-用户\" class=\"headerlink\" title=\"3.2.1.1 用户\"></a>3.2.1.1 用户</h5><p><img src=\"https://img-blog.csdnimg.cn/67b980ab25e24c75b2a6d3c9590c22ff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># Tags说明：</span></span><br><span class=\"line\"><span class=\"code\">\tAdmin(超级管理员)：登录控制台，查看所有信息，并对用户、策略（policy）进行修改。</span></span><br><span class=\"line\"><span class=\"code\">\tMonitoring（监控者）：登陆控制台，查看rabbitmq的节点（进程数、内存、磁盘等使用情况）信息。</span></span><br><span class=\"line\"><span class=\"code\">\tPolicymaker（策略制定者）：登陆控制台，对policy进行管理。</span></span><br><span class=\"line\"><span class=\"code\">\tManagement（普通管理员）：登陆控制台查看信息。</span></span><br><span class=\"line\"><span class=\"code\">\t其他：无法登陆控制台，就是普通的消费者或者生产者。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-1-2-虚拟主机\"><a href=\"#3-2-1-2-虚拟主机\" class=\"headerlink\" title=\"3.2.1.2 虚拟主机\"></a>3.2.1.2 虚拟主机</h5><p><img src=\"https://img-blog.csdnimg.cn/b21620fc59f5467ebc4c0402d5e2c0df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 虚拟主机：</span></span><br><span class=\"line\"><span class=\"code\">\t为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Host）概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自都有自己的队列、交换机，互不影响。相当于MySQL中的数据库。</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"3-2-1-3-用户和虚拟主机绑定\"><a href=\"#3-2-1-3-用户和虚拟主机绑定\" class=\"headerlink\" title=\"3.2.1.3 用户和虚拟主机绑定\"></a>3.2.1.3 用户和虚拟主机绑定</h5><p><img src=\"https://img-blog.csdnimg.cn/e60681b36bec47b5bba1ebde7ee8d03b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/b4808afbd6e34a8e982624a3f0b02856.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h2 id=\"4-RabbitMQ的Java客户端\"><a href=\"#4-RabbitMQ的Java客户端\" class=\"headerlink\" title=\"4.RabbitMQ的Java客户端\"></a>4.RabbitMQ的Java客户端</h2><h3 id=\"4-1-AMQP协议回顾\"><a href=\"#4-1-AMQP协议回顾\" class=\"headerlink\" title=\"4.1 AMQP协议回顾\"></a>4.1 AMQP协议回顾</h3><p><img src=\"https://img-blog.csdnimg.cn/eb827e01a84b4eea9bddb6dab2947c84.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"4-2-RabbitMQ支持的消息类型\"><a href=\"#4-2-RabbitMQ支持的消息类型\" class=\"headerlink\" title=\"4.2 RabbitMQ支持的消息类型\"></a>4.2 RabbitMQ支持的消息类型</h3><p><img src=\"https://img-blog.csdnimg.cn/40d40399960442e9a2d0d5668a6825d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"4-3-引入依赖\"><a href=\"#4-3-引入依赖\" class=\"headerlink\" title=\"4.3 引入依赖\"></a>4.3 引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.rabbitmq<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>amqp-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.14.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-各种模型客户端代码\"><a href=\"#4-4-各种模型客户端代码\" class=\"headerlink\" title=\"4.4 各种模型客户端代码\"></a>4.4 各种模型客户端代码</h3><h4 id=\"4-4-1-Direct-直连模式\"><a href=\"#4-4-1-Direct-直连模式\" class=\"headerlink\" title=\"4.4.1 Direct-直连模式\"></a>4.4.1 Direct-直连模式</h4><p><img src=\"https://img-blog.csdnimg.cn/2401e687d01347fb9827dffb97b570c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 相关概念：</span></span><br><span class=\"line\"><span class=\"code\">\tP：provider，生产者，要发送消息的程序</span></span><br><span class=\"line\"><span class=\"code\">\tC：consumer，消费者，消费消息的程序</span></span><br><span class=\"line\"><span class=\"code\">\tQueue：队列，存储消息的地方</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * direct模式-生产者</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 直接点对点，也就是生产者将消息发送到队列中，消费者直接从队列中获取</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 11:34 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestProducer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 定义队列名字</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1.创建连接工程</span></span><br><span class=\"line\">        ConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        connectionFactory.setHost(<span class=\"string\">&quot;101.43.52.186&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        connectionFactory.setVirtualHost(<span class=\"string\">&quot;/adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setUsername(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPassword(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2.创建连接</span></span><br><span class=\"line\">        Connection connection = connectionFactory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 3.创建通道</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 4.声明队列：队列名称，是否持久化，是否独占，额外参数</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 5.向队列发送消息：交换机名称，队列名称，额外参数，消息体</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 6.关闭资源</span></span><br><span class=\"line\">        channel.close();</span><br><span class=\"line\">        connection.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * direct模式-消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 11:34 AM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestConsumer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1 创建连接工厂，并设置基础参数</span></span><br><span class=\"line\">        ConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">        connectionFactory.setHost(<span class=\"string\">&quot;101.43.52.186&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">        connectionFactory.setVirtualHost(<span class=\"string\">&quot;/adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setUsername(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        connectionFactory.setPassword(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2 创建连接</span></span><br><span class=\"line\">        Connection connection = connectionFactory.newConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 3 创建通道</span></span><br><span class=\"line\">        Channel channel = connection.createChannel();</span><br><span class=\"line\">        <span class=\"comment\">// 4 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 4 接收消息</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 回调方法</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer：&quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">// 5 关闭资源</span></span><br><span class=\"line\">        channel.close();</span><br><span class=\"line\">        connection.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-2-Work-Queues-工作队列\"><a href=\"#4-4-2-Work-Queues-工作队列\" class=\"headerlink\" title=\"4.4.2 Work Queues-工作队列\"></a>4.4.2 Work Queues-工作队列</h4><p><img src=\"https://img-blog.csdnimg.cn/37c7326912a04ff1baaa25754a61535f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p>​        Work Queue也被称为<code>Task Queue</code>任务模型。当消息处理比较耗时时，可能消息生产的速度远远超过了消息消费的速度。长此以往，消息就会堆积，此时就可以使用Work Queue模型。让多个消费者绑定同一个队列，共同消费队列中的消息。队列中的消息一旦被消费，就会被删除，因此不会产生重复消费。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提取连接rabbitmq的工具类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMQUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span>    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建连接工厂</span></span><br><span class=\"line\">            ConnectionFactory connectionFactory = <span class=\"keyword\">new</span> ConnectionFactory();</span><br><span class=\"line\">            <span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">            connectionFactory.setHost(<span class=\"string\">&quot;101.43.52.186&quot;</span>);</span><br><span class=\"line\">            connectionFactory.setPort(<span class=\"number\">5672</span>);</span><br><span class=\"line\">            connectionFactory.setVirtualHost(<span class=\"string\">&quot;/adu&quot;</span>);</span><br><span class=\"line\">            connectionFactory.setUsername(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">            connectionFactory.setPassword(<span class=\"string\">&quot;adu&quot;</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 创建连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> connectionFactory.newConnection();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Channel <span class=\"title\">getChannel</span><span class=\"params\">(Connection connection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> connection.createChannel();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">(Channel channel, Connection connection)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (channel != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                channel.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (TimeoutException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                connection.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Work Queue模型</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 工作队列模型，应对的是消费者消费比较慢的情况，多个消费者共同消费同一个队列中的消息。</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 2:02 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发消息</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            channel.basicPublish(<span class=\"string\">&quot;&quot;</span>, QUEUE_NAME, <span class=\"keyword\">null</span>, (<span class=\"string\">&quot;hello work queue &quot;</span> + i).getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费消息</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\">和consumer1相同代码，修改消费输出：System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># consumer1 output...</span></span><br><span class=\"line\">consumer1: hello work queue 0</span><br><span class=\"line\">consumer1: hello work queue 2</span><br><span class=\"line\">consumer1: hello work queue 4</span><br><span class=\"line\">consumer1: hello work queue 6</span><br><span class=\"line\">consumer1: hello work queue 8</span><br><span class=\"line\"><span class=\"section\"># consumer2 output...</span></span><br><span class=\"line\">consumer2: hello work queue 1</span><br><span class=\"line\">consumer2: hello work queue 3</span><br><span class=\"line\">consumer2: hello work queue 5</span><br><span class=\"line\">consumer2: hello work queue 7</span><br><span class=\"line\">consumer2: hello work queue 9</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>​        默认情况下，RabbitMQ将按顺序依次将消息发给每个消费者，也就是说每个消费者都会收到相同数量的消息，这种平分消息的方式称为<code>循环</code>。</p>\n<h5 id=\"4-4-2-1-消息自动确认机制\"><a href=\"#4-4-2-1-消息自动确认机制\" class=\"headerlink\" title=\"4.4.2.1 消息自动确认机制\"></a>4.4.2.1 消息自动确认机制</h5><p>​        如果一个消费者在执行任务的过程中宕机，那么在以上代码中，一旦RabbitMQ将将消息传递给消费者，他就会立即标记为删除，那么该消费者中未处理的消息将丢失。我们希望在处理任务的过程中，一个消费者宕机了，能够将任务交给其他消费者处理。这时候我们就可以用到<code>消息自动确认机制</code>。也就是说，我们可以在处理完任务之后，再通知RabbitMQ可以删除该任务。</p>\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同上</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer3</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 每次只能消费一个消息</span></span><br><span class=\"line\">        channel.basicQos(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费消息</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1000</span>); <span class=\"comment\">// 模拟处理消息消耗时常</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                <span class=\"comment\">// 手动确认，参数1：消息标记 参数2：是否同时确认多条，false表示每次只能确认一条</span></span><br><span class=\"line\">                channel.basicAck(envelope.getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer4</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;work&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(QUEUE_NAME, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 限制每次消费1条</span></span><br><span class=\"line\">        channel.basicQos(<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 消费消息，autoAck改为false，表示不自动确认</span></span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                <span class=\"comment\">// 手动确认</span></span><br><span class=\"line\">                channel.basicAck(envelope.getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># consumer1 output...</span></span><br><span class=\"line\">consumer1: hello work queue 1</span><br><span class=\"line\">consumer1: hello work queue 3</span><br><span class=\"line\">consumer1: hello work queue 5</span><br><span class=\"line\">consumer1: hello work queue 8</span><br><span class=\"line\">consumer1: hello work queue 10</span><br><span class=\"line\">consumer1: hello work queue 13</span><br><span class=\"line\">consumer1: hello work queue 15</span><br><span class=\"line\">consumer1: hello work queue 18</span><br><span class=\"line\"><span class=\"section\"># consumer2 output...</span></span><br><span class=\"line\">consumer1: hello work queue 0</span><br><span class=\"line\">consumer1: hello work queue 2</span><br><span class=\"line\">consumer1: hello work queue 4</span><br><span class=\"line\">consumer1: hello work queue 6</span><br><span class=\"line\">consumer1: hello work queue 7</span><br><span class=\"line\">consumer1: hello work queue 9</span><br><span class=\"line\">consumer1: hello work queue 11</span><br><span class=\"line\">consumer1: hello work queue 12</span><br><span class=\"line\">consumer1: hello work queue 14</span><br><span class=\"line\">consumer1: hello work queue 16</span><br><span class=\"line\">consumer1: hello work queue 17</span><br><span class=\"line\">consumer1: hello work queue 19</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p>​        实现消息自动确认，需要注意两点：1）设置通道一次只能消费一条消息 2）关闭自动确认，手动确认消息</p>\n<h4 id=\"4-4-3-Publish-Subscribe-发布订阅模式\"><a href=\"#4-4-3-Publish-Subscribe-发布订阅模式\" class=\"headerlink\" title=\"4.4.3 Publish/Subscribe-发布订阅模式\"></a>4.4.3 Publish/Subscribe-发布订阅模式</h4><p><img src=\"https://img-blog.csdnimg.cn/610277d029c04fe5a3933cf79f21dcc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 消息流程：</span></span><br><span class=\"line\"><span class=\"code\">\t可以有多个消费者，每个消费者都有自己的queue（队列），每个队列都要绑定要exchange（交换机）。</span></span><br><span class=\"line\"><span class=\"code\">\t生产者发送的消息只能发送给交换机，交换机来决定发送给哪个队列，生产者无法决定。</span></span><br><span class=\"line\"><span class=\"code\">\t交换机把消息发送给绑定过的所有队列，队列的消费者都能拿到消息，实现一个消息被多个消费者消费。</span></span><br><span class=\"line\"><span class=\"code\"># 对应交换机类型：fanout</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Proudcer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishSubscriptProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String QUEUE_NAME = <span class=\"string\">&quot;fanout&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机 交换机名称 交换机类型</span></span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息到交换机</span></span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;hello fanout&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishSubscribeConsumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;fanout&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 创建临时队列</span></span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// 绑定交换机和队列 队列名称 交换机名称 路由</span></span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 接收消息</span></span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\">同consumer1，输出修改为：System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># consumer1 output...</span></span><br><span class=\"line\">consumer1: hello fanout, type [</span><br><span class=\"line\">consumer1: hello fanout</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\"># consumer2 output...</span></span><br><span class=\"line\">consumer2: hello fanout, type [</span><br><span class=\"line\">consumer2: hello fanout</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-4-Routing-路由模式\"><a href=\"#4-4-4-Routing-路由模式\" class=\"headerlink\" title=\"4.4.4 Routing-路由模式\"></a>4.4.4 Routing-路由模式</h4><p>​        在发布订阅模式中，一条消息会被所有订阅的的队列消费。但是在某些场景下，我们希望不同的消息类型被不同的队列消费，这时就需要用到Routing模式的direct类型的Exchange。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 在Direct模式下：</span></span><br><span class=\"line\"><span class=\"code\">\t队列与交换机的绑定，不能是任意绑定了，而是需要指定一个Routing Keying，消息发送方在向Exchange发送消息时，也必须指定消息的Routing Key。</span></span><br><span class=\"line\"><span class=\"code\">\tExchange也不再把消息交给每一个与之绑定的队列，而是根据消息的Routing Key判断，只有队列的Routing Key和消息的Routing Key完全一致时，才会发送消息。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/8f206f2cfdb34ce89c54e042a92cc21f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 说明：</span></span><br><span class=\"line\"><span class=\"code\">\tP：Proudcer，生产者，向Exchange发送消息，同时会指定一个Routing Key。</span></span><br><span class=\"line\"><span class=\"code\">\tX：Exchange，交换机，接收生产者发送的消息，然后把消息传递给与routing key完全匹配的队列。</span></span><br><span class=\"line\"><span class=\"code\">\tC1：Consumer，消费者，其所在队列指定了需要routing key为error的消息</span></span><br><span class=\"line\"><span class=\"code\">\tC2：Consumer，消费者，其所在队列指定了需要routing key为info、error、warning的消息</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取管道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;logs_direct&quot;</span>, routingKey, <span class=\"keyword\">null</span>, String.format(<span class=\"string\">&quot;routing for type [%s]&quot;</span>, routingKey).getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingConsumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// consumer1绑定routing key 为info</span></span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingConsumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;direct&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// consumer1绑定routing key 为info、error、warning</span></span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;info&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;error&quot;</span>);</span><br><span class=\"line\">        channel.queueBind(queue, <span class=\"string\">&quot;logs_direct&quot;</span>, <span class=\"string\">&quot;warning&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 依次发送routing key为info、error、warning结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## consummer1</span></span><br><span class=\"line\">consumer1: routing for type [info]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## consumer2</span></span><br><span class=\"line\">consumer1: routing for type [info]</span><br><span class=\"line\">consumer1: routing for type [error]</span><br><span class=\"line\">consumer1: routing for type [warning]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-4-5-Topics-主题（动态路由模式）\"><a href=\"#4-4-5-Topics-主题（动态路由模式）\" class=\"headerlink\" title=\"4.4.5 Topics-主题（动态路由模式）\"></a>4.4.5 Topics-主题（动态路由模式）</h4><p>​        <code>Topics</code>模式同<code>Routing</code>模式相比，都可以根据Routing Key把消息路由到不同的队列。只不过<code>Topic</code>类型的Routing Key可以使用通配符。Routing Key一般是由一个或多个单词组成，多个单词之间以‘,’分割。Exchange的类型为<code>topic</code>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e1252695c8fd433e9885d1a9e8c4e9fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 通配符：</span></span><br><span class=\"line\"><span class=\"code\">\t*（star）can substitute for exactly one word。精确匹配一个单词。</span></span><br><span class=\"line\"><span class=\"code\">\t#（hash）can substitute for zero or more words。匹配零个、一个或多个单词。</span></span><br><span class=\"line\"><span class=\"code\">## 例如：</span></span><br><span class=\"line\"><span class=\"code\">\taudit.# ：匹配 audit、audit.irs、audit.irs.corporate 等。</span></span><br><span class=\"line\"><span class=\"code\">\taudit.* ：只能匹配 audit.irs。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Producer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsProducer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(<span class=\"string\">&quot;logs_topics&quot;</span>, <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;user.save.now&quot;</span>;</span><br><span class=\"line\">        channel.basicPublish(<span class=\"string\">&quot;logs_topics&quot;</span>, routingKey, <span class=\"keyword\">null</span>, String.format(<span class=\"string\">&quot;hello topics, routing key : [%s]&quot;</span>, routingKey).getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsConsumer1</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs_topics&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// 队列和交换机绑定的路由为 user.*</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGE_NAME, <span class=\"string\">&quot;user.*&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsConsumer2</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String EXCHANGE_NAME = <span class=\"string\">&quot;logs_topics&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;topic&quot;</span>);</span><br><span class=\"line\">        String queue = channel.queueDeclare().getQueue();</span><br><span class=\"line\">        <span class=\"comment\">// 队列和交换机绑定的路由为 user.*</span></span><br><span class=\"line\">        channel.queueBind(queue, EXCHANGE_NAME, <span class=\"string\">&quot;user.#&quot;</span>);</span><br><span class=\"line\">        channel.basicConsume(queue, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>结果：</strong></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 依次发送routing key为user.save、user、user.save.now的结果：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## conumser1:</span></span><br><span class=\"line\">consumer1: hello topics, routing key : [user.save]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">## consumer2:</span></span><br><span class=\"line\">consumer2: hello topics, routing key : [user.save]</span><br><span class=\"line\">consumer2: hello topics, routing key : [user]</span><br><span class=\"line\">consumer2: hello topics, routing key : [user.save.now]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-SpringBoot重使用RabbitMQ\"><a href=\"#5-SpringBoot重使用RabbitMQ\" class=\"headerlink\" title=\"5.SpringBoot重使用RabbitMQ\"></a>5.SpringBoot重使用RabbitMQ</h2><h3 id=\"5-1-搭建环境\"><a href=\"#5-1-搭建环境\" class=\"headerlink\" title=\"5.1 搭建环境\"></a>5.1 搭建环境</h3><h4 id=\"5-1-1-引入依赖\"><a href=\"#5-1-1-引入依赖\" class=\"headerlink\" title=\"5.1.1 引入依赖\"></a>5.1.1 引入依赖</h4><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-1-2-配置信息\"><a href=\"#5-1-2-配置信息\" class=\"headerlink\" title=\"5.1.2 配置信息\"></a>5.1.2 配置信息</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">application:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">adu-rabbitmq</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">10.2</span><span class=\"number\">.3</span><span class=\"number\">.4</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">5672</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">adu</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">adu</span></span><br><span class=\"line\">    <span class=\"attr\">virtual-host:</span> <span class=\"string\">/adu</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-各种模型客户端代码\"><a href=\"#5-2-各种模型客户端代码\" class=\"headerlink\" title=\"5.2 各种模型客户端代码\"></a>5.2 各种模型客户端代码</h3><h4 id=\"5-2-1-Hello-World-直连模型\"><a href=\"#5-2-1-Hello-World-直连模型\" class=\"headerlink\" title=\"5.2.1 Hello World-直连模型\"></a>5.2.1 Hello World-直连模型</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * direct直连模式</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 6:30 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;hello&quot;))</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloWorldConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-2-Work-Queue-工作队列模式\"><a href=\"#5-2-2-Work-Queue-工作队列模式\" class=\"headerlink\" title=\"5.2.2 Work Queue - 工作队列模式\"></a>5.2.2 Work Queue - 工作队列模式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Work Queue模式-消费者</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 循环模式，每个消费者得到的消息数相同</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 6:36 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkQueueConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;work&quot;, durable = &quot;true&quot;, exclusive = &quot;false&quot;, autoDelete = &quot;false&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queuesToDeclare = @Queue(value = &quot;work&quot;, durable = &quot;true&quot;, exclusive = &quot;false&quot;, autoDelete = &quot;false&quot;))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-3-Publish-Subscribe-发布订阅模式\"><a href=\"#5-2-3-Publish-Subscribe-发布订阅模式\" class=\"headerlink\" title=\"5.2.3 Publish/Subscribe - 发布订阅模式\"></a>5.2.3 Publish/Subscribe - 发布订阅模式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Publish/Subscribe模式</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用交换机，将消息发给所有的绑定的队列</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 6:44 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PublishSubscribeConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 没有参数的，表示临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs&quot;, type = &quot;fanout&quot;) // 交换机</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 没有参数的，表示临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs&quot;, type = &quot;fanout&quot;) // 交换机</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-4-Routing-路由模式（direct）\"><a href=\"#5-2-4-Routing-路由模式（direct）\" class=\"headerlink\" title=\"5.2.4 Routing - 路由模式（direct）\"></a>5.2.4 Routing - 路由模式（direct）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Routing 模式 - 消费者</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> * Exchange类型：direct</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 7:01 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RoutingConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_direct&quot;, type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &quot;info&quot; // routing key</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_direct&quot;, type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;info&quot;, &quot;error&quot;, &quot;warning&quot;&#125; // routing key</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_direct&quot;, type = &quot;direct&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;warning&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive3</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer3: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-5-Topics-主题（动态路由）模式\"><a href=\"#5-2-5-Topics-主题（动态路由）模式\" class=\"headerlink\" title=\"5.2.5 Topics - 主题（动态路由）模式\"></a>5.2.5 Topics - 主题（动态路由）模式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Topics模式 -消费者</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * Exchange的类型为：topic</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> secret</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@date</span> 2021/12/14 7:16 PM</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TopicsConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_topics&quot;, type = &quot;topic&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;user.*&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive1</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\">            value = @Queue, // 临时队列</span></span><br><span class=\"line\"><span class=\"meta\">            exchange = @Exchange(value = &quot;logs_topics&quot;, type = &quot;topic&quot;),</span></span><br><span class=\"line\"><span class=\"meta\">            key = &#123;&quot;user.#&quot;&#125;</span></span><br><span class=\"line\"><span class=\"meta\">    ))</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">receive2</span><span class=\"params\">(String message)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span> + message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-6-客户端测试代码\"><a href=\"#5-2-6-客户端测试代码\" class=\"headerlink\" title=\"5.2.6 客户端测试代码\"></a>5.2.6 客户端测试代码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 生产端没有指定交换机，只有routing key和object。通过生产端的routing key和消费端的队列匹配</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest(classes = RabbitMQApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span></span><br><span class=\"line\"><span class=\"meta\">@RunWith(SpringRunner.class)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAutoConfiguration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RabbitMQApplicationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直连模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testHelloWorld</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;hello spring boot starter amqp...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Work Queue模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testWorkQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            rabbitTemplate.convertAndSend(<span class=\"string\">&quot;work&quot;</span>, <span class=\"string\">&quot;hello work queue&quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Publish/Subscribe模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testPublishSubscribe</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            rabbitTemplate.convertAndSend(<span class=\"string\">&quot;logs&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;hello publish subscribe &quot;</span> + i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Routing模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testRouting</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;warning&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;logs_direct&quot;</span>, routingKey, <span class=\"string\">&quot;hello routing, type=&quot;</span> + routingKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// Topics模式</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTopics</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String routingKey = <span class=\"string\">&quot;user.save&quot;</span>;</span><br><span class=\"line\">        rabbitTemplate.convertAndSend(<span class=\"string\">&quot;logs_topics&quot;</span>, routingKey, <span class=\"string\">&quot;hello topics, type=&quot;</span> + routingKey);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-MQ的应用场景\"><a href=\"#6-MQ的应用场景\" class=\"headerlink\" title=\"6.MQ的应用场景\"></a>6.MQ的应用场景</h2><h3 id=\"6-1-异步处理\"><a href=\"#6-1-异步处理\" class=\"headerlink\" title=\"6.1 异步处理\"></a>6.1 异步处理</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 场景说明：</span></span><br><span class=\"line\"><span class=\"code\">\t用户注册后，需要发送邮件和注册短信，传统的做法有2种：1）串行方式 2）并行方式</span></span><br><span class=\"line\"><span class=\"code\">## 串行方式</span></span><br><span class=\"line\"><span class=\"code\">\t将注册信息写入数据库后，再发送邮件，再注册短信，以上三个任务全部返回结果后，才返回给客户端。这里有一个问题，邮件、短信并不是必须的，它只是一个通知，而这种做法需要让客户端等待没有必要等待的东西。</span></span><br><span class=\"line\"><span class=\"code\">## 并行方式</span></span><br><span class=\"line\"><span class=\"code\">\t将注册信息写入数据库后，发送邮件的同时，发送短信。以上三个任务完成后，返回给客户端，并行的方式能提高处理的效率。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/c0e203b0f649433984cbd50434586974.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/17a5dbf434ee4c76a2745392fb70a774.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 消息队列：</span></span><br><span class=\"line\"><span class=\"code\">\t除了以上提到的2种传统方式之外，我们还可以选择 消息队列 的形式。因为发送邮件和发送短信不是必须的，所以我们可以使用消息队列的形式，进行异步处理，相对于并行方式，减少了发送邮件或者短信的时间，相当于只有 注册信息写入数据库 + 写入消息队列 这个操作的耗时。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/c2bad0734fff4638acb0f0e7aa222327.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"6-2-应用解藕\"><a href=\"#6-2-应用解藕\" class=\"headerlink\" title=\"6.2 应用解藕\"></a>6.2 应用解藕</h3><p><img src=\"https://img-blog.csdnimg.cn/4096d6dc33ff48e380b3ec742e513b3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 场景：</span></span><br><span class=\"line\"><span class=\"code\">\t双十一是购物节，用户下单后，订单系统需要通知库存系统，传统做法是订单系统调用库存系统提供的接口。</span></span><br><span class=\"line\"><span class=\"code\"># 缺点：</span></span><br><span class=\"line\"><span class=\"code\">\t这种做法有个缺点：当库存系统异常时，订单系统就无法使用。订单系统和库存系统就出现了耦合。解决方法引入消息队列。</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/129b02a2439545ed8f748471c0f21b8a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 引入消息队列：</span></span><br><span class=\"line\"><span class=\"code\">\t订单系统：用户下单后，订单系统完成持久化后，将消息写入 消息队列 ，返回用户下单成功。</span></span><br><span class=\"line\"><span class=\"code\">\t库存系统：订阅下单消息，获取下单消息，进行库存操作。就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息丢失。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-3-流量削峰\"><a href=\"#6-3-流量削峰\" class=\"headerlink\" title=\"6.3 流量削峰\"></a>6.3 流量削峰</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 场景：</span></span><br><span class=\"line\"><span class=\"code\">\t秒杀活动，一般会因为流量过大，导致应用挂掉。为了解决这个问题，一般在应用之前加入消息队列。</span></span><br><span class=\"line\"><span class=\"code\"># 作用：</span></span><br><span class=\"line\"><span class=\"code\">\t1.可以控制活动人数，超过一定阈值的订单直接丢弃</span></span><br><span class=\"line\"><span class=\"code\">\t2.可以缓解短时间的高流量压垮应用（程序按自己处理能力获取订单）。</span></span><br><span class=\"line\"><span class=\"code\"># 流程：</span></span><br><span class=\"line\"><span class=\"code\">\t1.用户的请求，服务器收到之后先加入到消息队列。假如超过消息队列的最大长度，则直接丢弃用户请求或者跳转到错误页面。</span></span><br><span class=\"line\"><span class=\"code\">\t2.秒杀业务根据消息队列中的请求信息，再做后续的处理。</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-RabbitMQ集群\"><a href=\"#7-RabbitMQ集群\" class=\"headerlink\" title=\"7.RabbitMQ集群\"></a>7.RabbitMQ集群</h2><h3 id=\"7-1-集群架构（副本集群）\"><a href=\"#7-1-集群架构（副本集群）\" class=\"headerlink\" title=\"7.1 集群架构（副本集群）\"></a>7.1 集群架构（副本集群）</h3><blockquote>\n<p>默认情况下：RabbitMQ代理操作所需的所有数据/状态都将跨所有节点复制。这方面的一个例外是 消息队列，默认情况下，消息队列位于一个节点上，尽管他们可以从任意节点上看到和访问。–官网</p>\n<p>也就是说，集群架构的方式只能在节点之间同步（复制）交换机等基本信息，无法同步队列信息。而队列信息是保存数据的地方，如果无法在节点之间进行复制，那么集群将失去一些意义。</p>\n</blockquote>\n<h4 id=\"7-1-1-架构图\"><a href=\"#7-1-1-架构图\" class=\"headerlink\" title=\"7.1.1 架构图\"></a>7.1.1 架构图</h4><p><img src=\"https://img-blog.csdnimg.cn/1b08e25a4092495f8412a4dd0801b780.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 核心解决问题：</span></span><br><span class=\"line\"><span class=\"code\">\t当集群中某一时刻Master节点宕机，可以对Queue中信息进行备份。</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-1-2-集群搭建\"><a href=\"#7-1-2-集群搭建\" class=\"headerlink\" title=\"7.1.2 集群搭建\"></a>7.1.2 集群搭建</h4><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS：使用docker安装</span><br><span class=\"line\"><span class=\"section\"># 0.集群规划</span></span><br><span class=\"line\"><span class=\"code\">\tnode1:  172.18.0.2 5672 15672 \t\tmaster 主节点</span></span><br><span class=\"line\"><span class=\"code\">\tnode2:\t172.18.0.3 5673 15673\t\trepl1  副本节点</span></span><br><span class=\"line\"><span class=\"code\">\tnode3:\t172.18.0.4 5674 15674\t \trepl2  副本节点</span></span><br><span class=\"line\"><span class=\"code\"># 1.克隆三台主机名和ip映射，并修改各个虚拟机的hostname</span></span><br><span class=\"line\"><span class=\"code\">\t创建网络：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker network create rabbit-net</span></span><br><span class=\"line\"><span class=\"code\">\t创建容器：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker run -d --privileged=true --hostname node1 --name node1 -p 15672:15672 -p 5672:5672 --network rabbit-net centos:8.2.2004 /sbin/init</span></span><br><span class=\"line\"><span class=\"code\">\t进入容器：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker exec -it node/node1/node2 /bin/bash</span></span><br><span class=\"line\"><span class=\"code\">\t复制erlang、rabbit的rpm包到容器：</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker cp ./erlang.xxx.rpm node1:/</span></span><br><span class=\"line\"><span class=\"code\">\t\tdocker cp ./rabbitmq.xxx.rpm node1:/</span></span><br><span class=\"line\"><span class=\"code\">\t安装：</span></span><br><span class=\"line\"><span class=\"code\">\t\trpm -ihv erlang.xxx.rpm</span></span><br><span class=\"line\"><span class=\"code\">\t\trpm -ivh rabbitmq.xxx.rpm --nodeps --force</span></span><br><span class=\"line\"><span class=\"code\">\t配置：</span></span><br><span class=\"line\"><span class=\"code\">\t\t在/etc/hosts加入各个节点的ip和域名对应关系。</span></span><br><span class=\"line\"><span class=\"code\">\t问题：</span></span><br><span class=\"line\"><span class=\"code\">\t\t参考：https://blog.csdn.net/weixin_42181917/article/details/105579288</span></span><br><span class=\"line\"><span class=\"code\">\t\t1.System has not been booted with systemd as init system (PID 1). Can&#x27;t operate.Failed to create bus connection: Host is down</span></span><br><span class=\"line\"><span class=\"code\">\t\t解决：创建容器使用 /sbin/init</span></span><br><span class=\"line\"><span class=\"code\">\t\t2.Could not set property: Failed to set static hostname: Device or resource busy</span></span><br><span class=\"line\"><span class=\"code\">\t\t解决：退出容器，重新进入在设置一次</span></span><br><span class=\"line\"><span class=\"code\">\t\t\thostnamectl set-hostname node/node1/node2</span></span><br><span class=\"line\"><span class=\"code\">\t\t\texit</span></span><br><span class=\"line\"><span class=\"code\">\t\t\thostnamectl set-hostname node/node1/node2</span></span><br><span class=\"line\"><span class=\"code\"># 2.三台机器安装rabbitmq，并同步cookie文件</span></span><br><span class=\"line\"><span class=\"code\">\tdocker cp 命令将宿主机中的erlang和rabbitmq的rpm包都上传到虚拟机中，启动rabbitmq。</span></span><br><span class=\"line\"><span class=\"code\">\tdocker cp 命令将node1节点中的 /var/lib/rabbitmq/.erlang.cookie文件复制到宿主机，再通过宿主机复制到node1和node2.</span></span><br><span class=\"line\"><span class=\"code\">\t这里需要注意看是否.erlang.cookie文件的权限是否和node相同：chown、chgrp 命令可以修改权限。</span></span><br><span class=\"line\"><span class=\"code\"># 3.查看cookie文件是否一致</span></span><br><span class=\"line\"><span class=\"code\">\t进入三个节点的虚拟机中，执行: cat /var/lib/rabbitmq/.erlang.cookie，查看内容是否一致。</span></span><br><span class=\"line\"><span class=\"code\"># 4.后台启动rabbit</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmq-server -detached</span></span><br><span class=\"line\"><span class=\"code\"># 5.在node2和node3执行加入集群命令</span></span><br><span class=\"line\"><span class=\"code\">\t1.关闭\t\trabbitmqctl stop_app</span></span><br><span class=\"line\"><span class=\"code\">\t2.加入集群\t   rabbitmqctl join_cluster rabbit@node</span></span><br><span class=\"line\"><span class=\"code\">\t3.启动服务\t   rabbitmqctl start_app</span></span><br><span class=\"line\"><span class=\"code\">\t</span></span><br><span class=\"line\"><span class=\"code\"></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>搭建成功：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4e5b989ee58b4a63816087ee87cb34d4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/c9e21a1431b74730908aefb32fdc5cbe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h3 id=\"7-2-镜像集群\"><a href=\"#7-2-镜像集群\" class=\"headerlink\" title=\"7.2 镜像集群\"></a>7.2 镜像集群</h3><blockquote>\n<p>镜像队列机制就是将队列在三个节点之间设置主从关系，消息会在三个节点之间自动进行同步。且如果其中一个节点不可用，并不会导致消息丢失或者服务不可用的情况，提升MQ集群整体的高可用性。–摘自官网</p>\n</blockquote>\n<h4 id=\"7-2-1-架构图\"><a href=\"#7-2-1-架构图\" class=\"headerlink\" title=\"7.2.1 架构图\"></a>7.2.1 架构图</h4><p><img src=\"https://img-blog.csdnimg.cn/677182699180463baa2a64e582a7042c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<h4 id=\"7-2-2-集群搭建\"><a href=\"#7-2-2-集群搭建\" class=\"headerlink\" title=\"7.2.2 集群搭建\"></a>7.2.2 集群搭建</h4><p>​        镜像集群的搭建，是在<code>副本集群</code>的基础之上做的额外配置，也就是说必选先搭建好<code>副本集群</code>才能搭建镜像集群。这个额外配置就是需要创建一个<code>策略</code>。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># 0.策略说明</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl set_policy [--vhost &lt;vhost&gt;] [--priority &lt;priority&gt;] [--apply-to &lt;apply-to&gt;] &lt;name&gt; &lt;pattern&gt; &lt;definition&gt;</span></span><br><span class=\"line\"><span class=\"code\">\t--vhost：可选参数，针对指定virutal host下的queue进行设置</span></span><br><span class=\"line\"><span class=\"code\">\t--priority：可选参数，policy的优先级，越大越优先</span></span><br><span class=\"line\"><span class=\"code\">\t--appliy-to：可选参数，表示策略应用的对象，后面跟queues|exchanges|all。</span></span><br><span class=\"line\"><span class=\"code\">\tname：策略名称，唯一标识。</span></span><br><span class=\"line\"><span class=\"code\">\tpattern：匹配队列的正则表达式。</span></span><br><span class=\"line\"><span class=\"code\">\tdefinition：镜像定义，包括三个部分：ha-mode、ha-params、ha-sync-mode</span></span><br><span class=\"line\"><span class=\"code\">\t\tha-mode：镜像队列模式，可选值：all/exaclty/nodes</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tall：表示在集群的所有节点上进行镜像</span></span><br><span class=\"line\"><span class=\"code\">\t\t\texactly：表示在指定个数的节点上进行镜像，节点个数通过ha-params指定</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tnodes：表示在指定节点上进行镜像，节点名称通过ha-params指定</span></span><br><span class=\"line\"><span class=\"code\">\t\tha-params：ha-mode需要用到的参数</span></span><br><span class=\"line\"><span class=\"code\">\t\tha-sync-mode：队列同步方式，可选值为：automatic/manual</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tautomatic：自动同步</span></span><br><span class=\"line\"><span class=\"code\">\t\t\tmanual：用户触发同步</span></span><br><span class=\"line\"><span class=\"code\"># 1.查看当前策略</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl list_policies</span></span><br><span class=\"line\"><span class=\"code\"># 2.添加策略</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl set_policy ha-all &#x27;^hello&#x27; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;</span></span><br><span class=\"line\"><span class=\"code\">\t说明：策略正则表示为&quot;^&quot;表示匹配所有队列，&quot;^hello&quot;表示匹配hello开头的队列</span></span><br><span class=\"line\"><span class=\"code\"># 3.删除策略</span></span><br><span class=\"line\"><span class=\"code\">\trabbitmqctl clear_policy ha-all</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>搭建成功：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0a123778671941e99aac309f1180c599.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/4c70637a590c4150b0f2296b65bc3837.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"image\"></p>\n"},{"title":"RabbitMQ的死信队列和延时队列","top":false,"date":"2021-12-26T06:14:49.000Z","_content":"\n# RabbitMQ死信队列和延时队列\n\n​\t\tRabbitMQ本身是具有`死信队列`和`死信交换机`属性的，`延时队列` 可以通过死信队列和死信交换机来实现。在电商行业中，通常都会有一个需求：订单超时未支付，自动取消该订单。那么通过RabbitMQ实现的延时队列就是实现该需求的一种方式。\n\n## 1、死信队列\n\n​\t\t`死信`顾名思义，就是死掉的信息，英文是Dead Letter。`死信交换机（Dead-Letter-Exchange）`和普通交换机没有区别，都是可以接受信息并转发到与之绑定并能路由到的队列，区别在于`死信交换机`是转发`死信`的，而和该`死信交换机`绑定的队列就是`死信队列`。说的再通俗一点，死信交换机和死信队列其实都只是普通的交换机和队列，只不过接受、转发的信息是`死信`，其他操作并没有区别。\n\n### 1.1 死信的条件\n\n​\t\t称为`死信`的信息，需要如下几个条件：\n\n- 消息被消费者拒绝（通过basic.reject 或者 back.nack），并且设置 requeue=false。\n- 消息过期，因为队列设置了TTL（Time To Live）时间。\n- 消息被丢弃，因为超过了队列的长度限制。\n\n这时以上几个条件的方式基本上都有2种：1）`rabbitmqctl`命令行设置policy（策略）参数； 2）硬编码，也就是在代码中设置。\n\n### 1.2 消费者拒绝\n\n#### 1.2.1 编码方式\n\n​\t\t硬编码就是在代码中编写**业务队列声明时**对应的参数：\n\n- `x-dead-letter-exchange`：死信交换机，必须\n- `x-dead-letter-routing-key`：死信交换机转发到死信队列的路由键，可选\n\n**Producer:**\n\n```java\n// producer\npublic class RejectProducer {\n\t// 定义业务交换机\n    public static final String ORDER_X = \"order.exchange\";\n\t// main方法\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 发消息，路由键分别为：d.order.123、d.other.123、d\n        // 1）d.order.123：业务consumer会收到消息，order死信队列也会收到消息\n        // 2）d.other.123：业务consumer会收到消息，other死信队列也会收到消息\n        // 3）d：只有业务consumer会收到消息\n        channel.basicPublish(ORDER_X, \"d.order.123\", null, \"hello my friend\".getBytes(StandardCharsets.UTF_8));\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer:**\n\n```java\n/**\n * 死信队列条件：消费者拒绝\n * 1）basic.reject(tag, requeue) 表示拒绝接受消息，第二个参数表示是否重新入队，如果为true，可能造成死循环，需要注意\n * 2）basic.nack(tag, multi, requeue) multi可以同时拒绝多条，requeue和reject相同。nack表示未ack的数据，会有单独的标识\n */\npublic class RejectConsumer {\n\n    public static final String DEAD_LETTER_X = \"dead.letter.exchange\";\n    public static final String DEAD_LETTER_Q_1 = \"dead.letter.queue.order\";\n    public static final String DEAD_LETTER_Q_2 = \"dead.letter.queue.other\";\n    public static final String ORDER_X = \"order.exchange\";\n    public static final String ORDER_Q = \"order.queue\";\n\n    public static void main(String[] args) throws IOException {\n        // reject和nack方式\n        rejectAndNack();\n    }\n\n    public static void rejectAndNack() throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明死信队列和死信交换机\n        declareOrderDLX(channel);\n        declareOtherDLX(channel);\n        \n        // 声明业务交换机\n        channel.exchangeDeclare(ORDER_X, \"topic\", false, true, null);\n        // 设置业务参数\n        Map<String, Object> arguments = new HashMap<>();\n        // 设置死信交换机，一个死信交换机绑定了两个死信队列，根据路由键来区分消息的转发\n        arguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_X);\n        // 设置死信队列路由key：\n        // 如果这里设置了路由键，则publish过来的消息再转发到死信交换机时，以该路由键转发到死信队列，\n        // 如果未设置该参数，则按照publish时的路由键转发到死信队列\n//        arguments.put(\"x-dead-letter-routing-key\", \"d.other\");\n        // 声明业务队列\n        channel.queueDeclare(ORDER_Q, false, false, true, arguments);\n        // 绑定业务队列和业务交换机\n        channel.queueBind(ORDER_Q, ORDER_X, \"#\");\n        // 监听业务队列消息\n        channel.basicConsume(ORDER_Q, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"order consumer: \" + new String(body, StandardCharsets.UTF_8));\n                // 拒绝\n                channel.basicReject(envelope.getDeliveryTag(), false);\n                System.out.println(\"order properties: \" + envelope.toString());\n            }\n        });\n    }\n\n    // 声明order死信队列\n    public static void declareOrderDLX(Channel channel) throws IOException {\n        // 声明交换机，只是为了模拟，设置的duriable=false，autodelete=true\n        channel.exchangeDeclare(DEAD_LETTER_X, \"topic\", false, true, null);\n        // 声明队列\n        channel.queueDeclare(DEAD_LETTER_Q_1, false, false, true, null);\n        // 绑定交换机和队列，只接受 *.order.# 规则的消息\n        channel.queueBind(DEAD_LETTER_Q_1, DEAD_LETTER_X, \"*.order.#\");\n        // 监听消息\n        channel.basicConsume(DEAD_LETTER_Q_1, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"dead letter consumer 【order】: \" + new String(body, StandardCharsets.UTF_8));\n                System.out.println(\"dead letter properties 【order】:\" + envelope.toString());\n            }\n        });\n    }\n\n    // 声明other死信队列\n    public static void declareOtherDLX(Channel channel) throws IOException {\n        // 声明交换机\n        channel.exchangeDeclare(DEAD_LETTER_X, \"topic\", false, true, null);\n        // 声明队列\n        channel.queueDeclare(DEAD_LETTER_Q_2, false, false, true, null);\n        // 绑定交换机和队列，只接受 *.other.# 规则的消息\n        channel.queueBind(DEAD_LETTER_Q_2, DEAD_LETTER_X, \"*.other.#\");\n        // 监听消息\n        channel.basicConsume(DEAD_LETTER_Q_2, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"dead letter consumer 【other】: \" + new String(body, StandardCharsets.UTF_8));\n                System.out.println(\"dead letter properties 【other】:\" + envelope.toString());\n            }\n        });\n    }\n}\n```\n\n**总结：**\n\n**1）** consumer方使用`basic.reject`或者`basic.nack`都会将消息转发到匹配的死信队列（requeue=false），区别在于`basic.reject`相比`basic.nack`少一个参数`mutil`，表示是否批量back。而且nack的数量可以再web端看到。\n\n**2）** 使用`x-letter-dead-exchange`设置死信交换机，这个是必须设置的。`x-letter-dead-routing-key`设置死信交换机转发到死信队列的路由键，相当于重新定义了publish的路由键，该参数可选，可以根据具体业务判断是否需要设置。\n\n#### 1.1.2 策略方式\n\n策略方式需要在rabbitmq的服务器上执行如下命令：\n\n```bash\nrabbitmqctl set_policy {策略名称} \".*\" '{\"dead-letter-exchange\":\"my-dlx\"}' --apply-to queues\n```\n\n例如：\n\n```bash\nrabbitmqctl set_policy dlx \"dead.*\" '{\"dead-letter-exchange\":\"test-dead-letter-exchange\"}' --apply-to queues\n```\n\n表示给所有的 *以dead.开头* 的队列设置死信交换机 *test-dead-letter-exchange* ，策略名字为 *dlx*。然后我们在rabbitmq的web界面新建一个名字为`test-dead-letter-exchange`的exchange，并且新建名为`dead.order.queue`和`dead.other.queue`的queue，绑定`test-dead-letter-exchange`，路由键分别为：`order.#`和`other.#`。\n\n![死信交换机绑定死信队列](https://img-blog.csdnimg.cn/9b1d1dd66aeb4e7292f0058df0a368b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n> 说明：由于我们要模拟的死信转发到死信队列的情况，所以这两个新建的queue都设置了ttl为10000ms，也就是10s。\n\n![死信队列](https://img-blog.csdnimg.cn/dbdbef64985544f8afdd75dc4cb06712.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\t\t\n\n我们看到消息在10s之后成功到了`dead.order.queue`，说明我们的配置生效。这里我将这个过程画个图：\n\n![绑定死信队列](https://img-blog.csdnimg.cn/d6d9c46a56fc4a0cb9722c5000360189.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 1.3 设置过期时间\n\n> 文档：https://www.rabbitmq.com/ttl.html\n\n​\t\t我们可以给 *队列* 或者 *消息* 设置过期时间。*队列* 的过期时间，类似于 `autoDelete` 参数，表示队列在指定时长内如果没有使用的话会被删除，队列没有使用者，队列最近未重新声明（重新声明续订租约），以及`basic.get`至少在过期期间未被调用，例如，这可以用于RPC样式的回复队列，其中可以创建许多可能永远不会被耗尽的队列。*消息* 的过期时间我们可以在发消息时设置在消息体，也可以给这个队列设置一个消息过期时间，其实就是两种方式，一种设置在队列上，另一种是设置在消息上。\n\n#### 1.3.1 编码方式\n\n**1）设置消息体过期时间**\n\n```java\n// 设置消息属性\nAMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()\n    .expiration(\"2000\") // 设置消息过期时间，2s，既是所在队列没有过期时间也可以\n    .build();\n// 发消息\nchannel.basicPublish(\"hello\", \"order.123\", properties, \"hello my friend\".getBytes(StandardCharsets.UTF_8));\n```\n\n**2）设置队列的消息过期时间**\n\n```java\n// 设置参数\nMap<String, Object> arguments = new HashMap<>();\n// 设置队列的过期时间，5s\narguments.put(\"x-message-ttl\", 5000);\n// 设置死信队列\narguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_X);\n// 声明队列\nchannel.queueDeclare(ORDER_Q, false, false, true, arguments);\n```\n\n我们可以看到，创建好队列之后会有个`TTL`标识，`x-message-ttl`标识该队列设置的消息过期时间为5s。\n\n![队列的消息过期时间](https://img-blog.csdnimg.cn/c05ac2bbdb3049db94b434e4e3c508d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**3）设置队列的过期时间**\n\n```java\n// 设置队列参数\nMap<String, Object> arguments = new HashMap<>();\n// 设置队列中消息的过期时间，5s\narguments.put(\"x-message-ttl\", 5000);\n// 设置队列的过期时间，10s如果队列未使用（未操作），则删除队列\narguments.put(\"x-expires\", 10000);\n// 声明队列\nchannel.queueDeclare(ORDER_Q, true, false, false, arguments);\n```\n\n**注意：无论队列中是否存在消息，如果没有操作队列，就会被自动删除。**\n\n#### 1.3.2 策略方式\n\n**1）设置队列的消息过期时间**\n\n```bash\nrabbitmqctl set_policy --vhost /adu TTL \".*\" '{\"message-ttl\":60000}' --apply-to queues\n```\n\n表示在 `/adu`虚拟主机下增加一个名称为 *TTL* 策略，设所有队列 `message-ttl`消息过期时间60s。\n\n**2）设置队列的过期时间**\n\n```bash\nrabbitmqctl set_policy --vhost /adu expiry \".*\" '{\"expires\":1800000}' --apply-to queues\n```\n\n表示在`/adu`虚拟主机下增加一个名称为 *expiry* 的策略，设置所有的队列过期时间为180s。\n\n### 1.4 超过队列长度\n\n​\t\t默认情况下，队列没有长度限制（但是总归是有硬盘和内存的限制的）。我们可以显示的设置队列的长度，可以是消息的**数量限制**，也可以是队列总消息内容的**占用内存长度**，或者两种都设置。一个队列的最大长度，可以使用 *策略* 或者 *编码* 的方式进行设置，或者在创建队列时web界面设置。如果 `策略` 方式和 `编码` 方式都设置了，则 `值更小的` 会生效。\n\n​\t\t如果队列设置了队列长度限制，那么当队列中的消息达到最大长度时，默认的 *溢出* 规则为 *丢弃最老的消息（队列头部）*。我们可以改变这个规则，使用 `overflow` 参数来配置。`overflow` 可选值为 `x-reject-publish`或者`x-reject-publish-dls` ，两者都表示拒绝接受新消息，区别在于 `reject-publish-dlx` 也会导致死信拒绝消息<sup>1</sup>。\n\n> 此处有个疑问：reject-publish-dlx和reject-publish的区别问题。针对官网的翻译，我觉得 `reject-publish-dlx` 是与之绑定的死信队列不会收到消息， `reject-publish` 相反会收到消息。但是做实验的时候刚好和我理解的相反？熟悉的铁子们回复说一下哈呀。\n\n#### 1.4.1 编码方式\n\n​\t\t使用`x-max-length`和`x-max-length-bytes`参数设置。\n\n```java\n// 设置参数\nMap<String, Object> arguments = new HashMap<>();\n// 设置队列最大长度，5条消息\narguments.put(\"x-max-length\", 5);\n// 队列溢出的策略：drop-head（默认）、reject-publish、reject-publish-dlx\n//        arguments.put(\"x-overflow\", \"reject-publish-dlx\");\narguments.put(\"x-overflow\", \"reject-publish\");\n// 设置死信队列\narguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_X);\n// 声明队列\nchannel.queueDeclare(ORDER_Q, false, false, true, arguments);\n```\n\n#### 1.4.2 策略方式\n\n```bash\nrabbitmqctl set_policy --vhost /adu limit \"^five_msg\" '{\"dead-letter-exchange\":\"test-dead-letter-exchange\",\"max-length\":5,\"overflow\":\"reject-publish-dlx\"}' --apply-to queues\n```\n\n表示在 `/adu`虚拟主机下增加一个名称为 *limit* 策略，设所有以 *five_msg* 开头的队列 *消息最多为5个*、*消息溢出策略为拒绝*、*设置死信交换机* 。\n\n> 设置 `max-length-bytes` 也是同样的方式。\n\n## 2、延时队列\n\n​\t\t延时队列，顾名思义就是存放延时消息的队列，也就是说消费者在一定的延时后才会收到消息。典型的应用场景就是如上所述的订单超时未支付自动取消。\n\n### 2.1 借助死信队列实现\n\n​\t\t其实在介绍完 *死信队列* 之后，就能大概看出来如何使用 *死信队列* 来实现延时队列了。就是使用消息的`TTL` 属性，将过期的消息转发到死信队列中，业务监听死信队列的消息就行了。这种情况适合给队列设置消息过期时间的情况，就是队列中所有的消息都是同一个过期时间，到期按照顺序转发到死信队列中，不会有问题。\n\n​\t\t如果消息的过期时间是在发消息的时候设置在消息体上的，可能会出问题。比如按顺序发送msg1和msg2两条消息，msg1的过期时间为5s，msg2的过期时间为2s。正常理解下，结果肯定是msg2先到死信队列被消费，但是结果却是两条消息都在5s时转发到死信队列被消费。其实比较好理解，因为队列的特性就是 *先进先出* ，即使msg2先到了过期时间，但是msg1在它之前阻塞，只有msg1被消费了，msg2才能到队头被消费。 我们画个图：\n\n![死信队列实现延时队列问题](https://img-blog.csdnimg.cn/15894c373b12405381d8e89b2383a82b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 2.2 借助RabbitMQ插件实现\n\n​\t\trabbitmq提供了一个插件 `rabbitmq_delayed_message_exchange` 让我们能够实现 *延迟队列* 的效果，同时能够解决 *通过死信队列实现延迟队列* 出现的消息阻塞问题。该插件从RabbitMQ的3.6.12开始支持，要确认当前自己的rabbitmq版本是否支持该插件。\n\n#### 2.2.1 下载插件\n\n> 下载地址：https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\n\n​\t\t下载该插件后，将 `rabbitmq_delayed_message_exchange-3.9.0.ez` 包放到 *RabbitMQ安装目录的plugins* 目录下：\n\n![插件位置](https://img-blog.csdnimg.cn/bb1b98bbafdf455dbd9a38491aeefccd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 2.2.2 启用插件\n\n执行控制台命令，重启rabbitmq服务：\n\n```bash\n# 1.列出所有插件\nrabbitmq-plugins list\n# 2.启用rabbitmq_delayed_message_exchange\nrabbitmq-plubins enable rabbitmq_delayed_message_exchange\n# 3.重启服务（好像可以不用重启）\nsystemctl restart rabbitmq-server.service\n```\n\n​\t\t在此之后，web界面的 *exchanges* 便可以创建type为 `x-delayed-message` 的交换机，或者在代码中声明该类型的交换机。要是用其延时功能，需要在发消息的时候加一个 header ：`x-delay=xxx` ，表示延时xxx毫秒。\n\n```java\n// 声明延时交换机，type=x-delayed-message，x-delayed-type=direct|fanout|topic\nMap<String, Object> args = new HashMap<>();\nargs.put(\"x-delayed-type\", \"topic\"); // 相当于之前exchange的type\nchannel.exchangeDeclare(EXCHANGE_NAME, \"x-delayed-message\", false, true, args);\n\n// 发送消息，x-delay，值为过期时间\nMap<String, Object> headers = new HashMap<>();\nheaders.put(\"x-delay\", 5000); // 5s\nAMQP.BasicProperties props = new AMQP.BasicProperties().builder()\n    .headers(headers)\n    .build();\n// 发送消息\nchannel.basicPublish(EXCHANGE_NAME, \"other.save\", props, \"i am 5s message\".getBytes(StandardCharsets.UTF_8));\n```\n\n![添加延时交换机](https://img-blog.csdnimg.cn/106078170371495d9f19780059e92d51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 3、总结\n\n​\t\t上面我们提到了使用RabbitMQ实现延时队列功的方案：1）借助本事的死信队列实现，监听死信队列；2）借助插件实现。优缺点如下：\n\n- 死信队列实现方式，需要在队列上设置消息过期时间，不灵活；需要再多用一个死信队列，占用空间；rabbitmq本事自带死信队列，实现方便。\n- 插件实现方式，需要下载安装插件，要考虑版本兼容性；代码逻辑简单，容易上手。\n\n​\t\t回到我们开头的需求：订单支付超时自动取消。这个功能主要就是需要一个延时队列，那通过rabbitmq实现延时队列只是一种方式，还可以通过其他方式实现，比如Java的 `DelayQueue` 、`Quartz定时任务`、`Redis的zset`、`时间轮` 等都可以实现，具体方案还是要结合项目和具体方式的优缺点来选择。比如项目中使用到了RabbitMQ，那使用RabbitMQ实现延迟队列就是比较好的方式，那具体选择插件方式还是死信队列方式，还需要看项目中对该功能的灵活程度来选择。\n\n**参考：**\n\n1. [https://www.rabbitmq.com/dlx.html](https://www.rabbitmq.com/dlx.html)\n2. [https://www.cnblogs.com/williamwsj/p/8108970.html](https://www.cnblogs.com/williamwsj/p/8108970.html)\n3. [https://www.jianshu.com/p/256d2eaf1786](https://www.jianshu.com/p/256d2eaf1786)\n4. [https://www.rabbitmq.com/community-plugins.html](https://www.rabbitmq.com/community-plugins.html)\n5. [https://blog.csdn.net/zhenghongcs/article/details/106700446](https://blog.csdn.net/zhenghongcs/article/details/106700446)\n\n------\n\n最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～\n","source":"_posts/RabbitMQ的死信队列和延时队列.md","raw":"---\ntitle: RabbitMQ的死信队列和延时队列\ntop: false\ndate: 2021-12-26 14:14:49\ntags:\n    - 中间件\n    - RabbitMQ\ncategories:\n    - 中间件\n---\n\n# RabbitMQ死信队列和延时队列\n\n​\t\tRabbitMQ本身是具有`死信队列`和`死信交换机`属性的，`延时队列` 可以通过死信队列和死信交换机来实现。在电商行业中，通常都会有一个需求：订单超时未支付，自动取消该订单。那么通过RabbitMQ实现的延时队列就是实现该需求的一种方式。\n\n## 1、死信队列\n\n​\t\t`死信`顾名思义，就是死掉的信息，英文是Dead Letter。`死信交换机（Dead-Letter-Exchange）`和普通交换机没有区别，都是可以接受信息并转发到与之绑定并能路由到的队列，区别在于`死信交换机`是转发`死信`的，而和该`死信交换机`绑定的队列就是`死信队列`。说的再通俗一点，死信交换机和死信队列其实都只是普通的交换机和队列，只不过接受、转发的信息是`死信`，其他操作并没有区别。\n\n### 1.1 死信的条件\n\n​\t\t称为`死信`的信息，需要如下几个条件：\n\n- 消息被消费者拒绝（通过basic.reject 或者 back.nack），并且设置 requeue=false。\n- 消息过期，因为队列设置了TTL（Time To Live）时间。\n- 消息被丢弃，因为超过了队列的长度限制。\n\n这时以上几个条件的方式基本上都有2种：1）`rabbitmqctl`命令行设置policy（策略）参数； 2）硬编码，也就是在代码中设置。\n\n### 1.2 消费者拒绝\n\n#### 1.2.1 编码方式\n\n​\t\t硬编码就是在代码中编写**业务队列声明时**对应的参数：\n\n- `x-dead-letter-exchange`：死信交换机，必须\n- `x-dead-letter-routing-key`：死信交换机转发到死信队列的路由键，可选\n\n**Producer:**\n\n```java\n// producer\npublic class RejectProducer {\n\t// 定义业务交换机\n    public static final String ORDER_X = \"order.exchange\";\n\t// main方法\n    public static void main(String[] args) throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 发消息，路由键分别为：d.order.123、d.other.123、d\n        // 1）d.order.123：业务consumer会收到消息，order死信队列也会收到消息\n        // 2）d.other.123：业务consumer会收到消息，other死信队列也会收到消息\n        // 3）d：只有业务consumer会收到消息\n        channel.basicPublish(ORDER_X, \"d.order.123\", null, \"hello my friend\".getBytes(StandardCharsets.UTF_8));\n        // 关闭资源\n        RabbitMQUtil.close(channel, connection);\n    }\n}\n```\n\n**Consumer:**\n\n```java\n/**\n * 死信队列条件：消费者拒绝\n * 1）basic.reject(tag, requeue) 表示拒绝接受消息，第二个参数表示是否重新入队，如果为true，可能造成死循环，需要注意\n * 2）basic.nack(tag, multi, requeue) multi可以同时拒绝多条，requeue和reject相同。nack表示未ack的数据，会有单独的标识\n */\npublic class RejectConsumer {\n\n    public static final String DEAD_LETTER_X = \"dead.letter.exchange\";\n    public static final String DEAD_LETTER_Q_1 = \"dead.letter.queue.order\";\n    public static final String DEAD_LETTER_Q_2 = \"dead.letter.queue.other\";\n    public static final String ORDER_X = \"order.exchange\";\n    public static final String ORDER_Q = \"order.queue\";\n\n    public static void main(String[] args) throws IOException {\n        // reject和nack方式\n        rejectAndNack();\n    }\n\n    public static void rejectAndNack() throws IOException {\n        // 获取连接\n        Connection connection = RabbitMQUtil.getConnection();\n        // 获取通道\n        Channel channel = RabbitMQUtil.getChannel(connection);\n        // 声明死信队列和死信交换机\n        declareOrderDLX(channel);\n        declareOtherDLX(channel);\n        \n        // 声明业务交换机\n        channel.exchangeDeclare(ORDER_X, \"topic\", false, true, null);\n        // 设置业务参数\n        Map<String, Object> arguments = new HashMap<>();\n        // 设置死信交换机，一个死信交换机绑定了两个死信队列，根据路由键来区分消息的转发\n        arguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_X);\n        // 设置死信队列路由key：\n        // 如果这里设置了路由键，则publish过来的消息再转发到死信交换机时，以该路由键转发到死信队列，\n        // 如果未设置该参数，则按照publish时的路由键转发到死信队列\n//        arguments.put(\"x-dead-letter-routing-key\", \"d.other\");\n        // 声明业务队列\n        channel.queueDeclare(ORDER_Q, false, false, true, arguments);\n        // 绑定业务队列和业务交换机\n        channel.queueBind(ORDER_Q, ORDER_X, \"#\");\n        // 监听业务队列消息\n        channel.basicConsume(ORDER_Q, false, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"order consumer: \" + new String(body, StandardCharsets.UTF_8));\n                // 拒绝\n                channel.basicReject(envelope.getDeliveryTag(), false);\n                System.out.println(\"order properties: \" + envelope.toString());\n            }\n        });\n    }\n\n    // 声明order死信队列\n    public static void declareOrderDLX(Channel channel) throws IOException {\n        // 声明交换机，只是为了模拟，设置的duriable=false，autodelete=true\n        channel.exchangeDeclare(DEAD_LETTER_X, \"topic\", false, true, null);\n        // 声明队列\n        channel.queueDeclare(DEAD_LETTER_Q_1, false, false, true, null);\n        // 绑定交换机和队列，只接受 *.order.# 规则的消息\n        channel.queueBind(DEAD_LETTER_Q_1, DEAD_LETTER_X, \"*.order.#\");\n        // 监听消息\n        channel.basicConsume(DEAD_LETTER_Q_1, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"dead letter consumer 【order】: \" + new String(body, StandardCharsets.UTF_8));\n                System.out.println(\"dead letter properties 【order】:\" + envelope.toString());\n            }\n        });\n    }\n\n    // 声明other死信队列\n    public static void declareOtherDLX(Channel channel) throws IOException {\n        // 声明交换机\n        channel.exchangeDeclare(DEAD_LETTER_X, \"topic\", false, true, null);\n        // 声明队列\n        channel.queueDeclare(DEAD_LETTER_Q_2, false, false, true, null);\n        // 绑定交换机和队列，只接受 *.other.# 规则的消息\n        channel.queueBind(DEAD_LETTER_Q_2, DEAD_LETTER_X, \"*.other.#\");\n        // 监听消息\n        channel.basicConsume(DEAD_LETTER_Q_2, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n                System.out.println(\"dead letter consumer 【other】: \" + new String(body, StandardCharsets.UTF_8));\n                System.out.println(\"dead letter properties 【other】:\" + envelope.toString());\n            }\n        });\n    }\n}\n```\n\n**总结：**\n\n**1）** consumer方使用`basic.reject`或者`basic.nack`都会将消息转发到匹配的死信队列（requeue=false），区别在于`basic.reject`相比`basic.nack`少一个参数`mutil`，表示是否批量back。而且nack的数量可以再web端看到。\n\n**2）** 使用`x-letter-dead-exchange`设置死信交换机，这个是必须设置的。`x-letter-dead-routing-key`设置死信交换机转发到死信队列的路由键，相当于重新定义了publish的路由键，该参数可选，可以根据具体业务判断是否需要设置。\n\n#### 1.1.2 策略方式\n\n策略方式需要在rabbitmq的服务器上执行如下命令：\n\n```bash\nrabbitmqctl set_policy {策略名称} \".*\" '{\"dead-letter-exchange\":\"my-dlx\"}' --apply-to queues\n```\n\n例如：\n\n```bash\nrabbitmqctl set_policy dlx \"dead.*\" '{\"dead-letter-exchange\":\"test-dead-letter-exchange\"}' --apply-to queues\n```\n\n表示给所有的 *以dead.开头* 的队列设置死信交换机 *test-dead-letter-exchange* ，策略名字为 *dlx*。然后我们在rabbitmq的web界面新建一个名字为`test-dead-letter-exchange`的exchange，并且新建名为`dead.order.queue`和`dead.other.queue`的queue，绑定`test-dead-letter-exchange`，路由键分别为：`order.#`和`other.#`。\n\n![死信交换机绑定死信队列](https://img-blog.csdnimg.cn/9b1d1dd66aeb4e7292f0058df0a368b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n> 说明：由于我们要模拟的死信转发到死信队列的情况，所以这两个新建的queue都设置了ttl为10000ms，也就是10s。\n\n![死信队列](https://img-blog.csdnimg.cn/dbdbef64985544f8afdd75dc4cb06712.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\t\t\n\n我们看到消息在10s之后成功到了`dead.order.queue`，说明我们的配置生效。这里我将这个过程画个图：\n\n![绑定死信队列](https://img-blog.csdnimg.cn/d6d9c46a56fc4a0cb9722c5000360189.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 1.3 设置过期时间\n\n> 文档：https://www.rabbitmq.com/ttl.html\n\n​\t\t我们可以给 *队列* 或者 *消息* 设置过期时间。*队列* 的过期时间，类似于 `autoDelete` 参数，表示队列在指定时长内如果没有使用的话会被删除，队列没有使用者，队列最近未重新声明（重新声明续订租约），以及`basic.get`至少在过期期间未被调用，例如，这可以用于RPC样式的回复队列，其中可以创建许多可能永远不会被耗尽的队列。*消息* 的过期时间我们可以在发消息时设置在消息体，也可以给这个队列设置一个消息过期时间，其实就是两种方式，一种设置在队列上，另一种是设置在消息上。\n\n#### 1.3.1 编码方式\n\n**1）设置消息体过期时间**\n\n```java\n// 设置消息属性\nAMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()\n    .expiration(\"2000\") // 设置消息过期时间，2s，既是所在队列没有过期时间也可以\n    .build();\n// 发消息\nchannel.basicPublish(\"hello\", \"order.123\", properties, \"hello my friend\".getBytes(StandardCharsets.UTF_8));\n```\n\n**2）设置队列的消息过期时间**\n\n```java\n// 设置参数\nMap<String, Object> arguments = new HashMap<>();\n// 设置队列的过期时间，5s\narguments.put(\"x-message-ttl\", 5000);\n// 设置死信队列\narguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_X);\n// 声明队列\nchannel.queueDeclare(ORDER_Q, false, false, true, arguments);\n```\n\n我们可以看到，创建好队列之后会有个`TTL`标识，`x-message-ttl`标识该队列设置的消息过期时间为5s。\n\n![队列的消息过期时间](https://img-blog.csdnimg.cn/c05ac2bbdb3049db94b434e4e3c508d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n**3）设置队列的过期时间**\n\n```java\n// 设置队列参数\nMap<String, Object> arguments = new HashMap<>();\n// 设置队列中消息的过期时间，5s\narguments.put(\"x-message-ttl\", 5000);\n// 设置队列的过期时间，10s如果队列未使用（未操作），则删除队列\narguments.put(\"x-expires\", 10000);\n// 声明队列\nchannel.queueDeclare(ORDER_Q, true, false, false, arguments);\n```\n\n**注意：无论队列中是否存在消息，如果没有操作队列，就会被自动删除。**\n\n#### 1.3.2 策略方式\n\n**1）设置队列的消息过期时间**\n\n```bash\nrabbitmqctl set_policy --vhost /adu TTL \".*\" '{\"message-ttl\":60000}' --apply-to queues\n```\n\n表示在 `/adu`虚拟主机下增加一个名称为 *TTL* 策略，设所有队列 `message-ttl`消息过期时间60s。\n\n**2）设置队列的过期时间**\n\n```bash\nrabbitmqctl set_policy --vhost /adu expiry \".*\" '{\"expires\":1800000}' --apply-to queues\n```\n\n表示在`/adu`虚拟主机下增加一个名称为 *expiry* 的策略，设置所有的队列过期时间为180s。\n\n### 1.4 超过队列长度\n\n​\t\t默认情况下，队列没有长度限制（但是总归是有硬盘和内存的限制的）。我们可以显示的设置队列的长度，可以是消息的**数量限制**，也可以是队列总消息内容的**占用内存长度**，或者两种都设置。一个队列的最大长度，可以使用 *策略* 或者 *编码* 的方式进行设置，或者在创建队列时web界面设置。如果 `策略` 方式和 `编码` 方式都设置了，则 `值更小的` 会生效。\n\n​\t\t如果队列设置了队列长度限制，那么当队列中的消息达到最大长度时，默认的 *溢出* 规则为 *丢弃最老的消息（队列头部）*。我们可以改变这个规则，使用 `overflow` 参数来配置。`overflow` 可选值为 `x-reject-publish`或者`x-reject-publish-dls` ，两者都表示拒绝接受新消息，区别在于 `reject-publish-dlx` 也会导致死信拒绝消息<sup>1</sup>。\n\n> 此处有个疑问：reject-publish-dlx和reject-publish的区别问题。针对官网的翻译，我觉得 `reject-publish-dlx` 是与之绑定的死信队列不会收到消息， `reject-publish` 相反会收到消息。但是做实验的时候刚好和我理解的相反？熟悉的铁子们回复说一下哈呀。\n\n#### 1.4.1 编码方式\n\n​\t\t使用`x-max-length`和`x-max-length-bytes`参数设置。\n\n```java\n// 设置参数\nMap<String, Object> arguments = new HashMap<>();\n// 设置队列最大长度，5条消息\narguments.put(\"x-max-length\", 5);\n// 队列溢出的策略：drop-head（默认）、reject-publish、reject-publish-dlx\n//        arguments.put(\"x-overflow\", \"reject-publish-dlx\");\narguments.put(\"x-overflow\", \"reject-publish\");\n// 设置死信队列\narguments.put(\"x-dead-letter-exchange\", DEAD_LETTER_X);\n// 声明队列\nchannel.queueDeclare(ORDER_Q, false, false, true, arguments);\n```\n\n#### 1.4.2 策略方式\n\n```bash\nrabbitmqctl set_policy --vhost /adu limit \"^five_msg\" '{\"dead-letter-exchange\":\"test-dead-letter-exchange\",\"max-length\":5,\"overflow\":\"reject-publish-dlx\"}' --apply-to queues\n```\n\n表示在 `/adu`虚拟主机下增加一个名称为 *limit* 策略，设所有以 *five_msg* 开头的队列 *消息最多为5个*、*消息溢出策略为拒绝*、*设置死信交换机* 。\n\n> 设置 `max-length-bytes` 也是同样的方式。\n\n## 2、延时队列\n\n​\t\t延时队列，顾名思义就是存放延时消息的队列，也就是说消费者在一定的延时后才会收到消息。典型的应用场景就是如上所述的订单超时未支付自动取消。\n\n### 2.1 借助死信队列实现\n\n​\t\t其实在介绍完 *死信队列* 之后，就能大概看出来如何使用 *死信队列* 来实现延时队列了。就是使用消息的`TTL` 属性，将过期的消息转发到死信队列中，业务监听死信队列的消息就行了。这种情况适合给队列设置消息过期时间的情况，就是队列中所有的消息都是同一个过期时间，到期按照顺序转发到死信队列中，不会有问题。\n\n​\t\t如果消息的过期时间是在发消息的时候设置在消息体上的，可能会出问题。比如按顺序发送msg1和msg2两条消息，msg1的过期时间为5s，msg2的过期时间为2s。正常理解下，结果肯定是msg2先到死信队列被消费，但是结果却是两条消息都在5s时转发到死信队列被消费。其实比较好理解，因为队列的特性就是 *先进先出* ，即使msg2先到了过期时间，但是msg1在它之前阻塞，只有msg1被消费了，msg2才能到队头被消费。 我们画个图：\n\n![死信队列实现延时队列问题](https://img-blog.csdnimg.cn/15894c373b12405381d8e89b2383a82b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n### 2.2 借助RabbitMQ插件实现\n\n​\t\trabbitmq提供了一个插件 `rabbitmq_delayed_message_exchange` 让我们能够实现 *延迟队列* 的效果，同时能够解决 *通过死信队列实现延迟队列* 出现的消息阻塞问题。该插件从RabbitMQ的3.6.12开始支持，要确认当前自己的rabbitmq版本是否支持该插件。\n\n#### 2.2.1 下载插件\n\n> 下载地址：https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\n\n​\t\t下载该插件后，将 `rabbitmq_delayed_message_exchange-3.9.0.ez` 包放到 *RabbitMQ安装目录的plugins* 目录下：\n\n![插件位置](https://img-blog.csdnimg.cn/bb1b98bbafdf455dbd9a38491aeefccd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n#### 2.2.2 启用插件\n\n执行控制台命令，重启rabbitmq服务：\n\n```bash\n# 1.列出所有插件\nrabbitmq-plugins list\n# 2.启用rabbitmq_delayed_message_exchange\nrabbitmq-plubins enable rabbitmq_delayed_message_exchange\n# 3.重启服务（好像可以不用重启）\nsystemctl restart rabbitmq-server.service\n```\n\n​\t\t在此之后，web界面的 *exchanges* 便可以创建type为 `x-delayed-message` 的交换机，或者在代码中声明该类型的交换机。要是用其延时功能，需要在发消息的时候加一个 header ：`x-delay=xxx` ，表示延时xxx毫秒。\n\n```java\n// 声明延时交换机，type=x-delayed-message，x-delayed-type=direct|fanout|topic\nMap<String, Object> args = new HashMap<>();\nargs.put(\"x-delayed-type\", \"topic\"); // 相当于之前exchange的type\nchannel.exchangeDeclare(EXCHANGE_NAME, \"x-delayed-message\", false, true, args);\n\n// 发送消息，x-delay，值为过期时间\nMap<String, Object> headers = new HashMap<>();\nheaders.put(\"x-delay\", 5000); // 5s\nAMQP.BasicProperties props = new AMQP.BasicProperties().builder()\n    .headers(headers)\n    .build();\n// 发送消息\nchannel.basicPublish(EXCHANGE_NAME, \"other.save\", props, \"i am 5s message\".getBytes(StandardCharsets.UTF_8));\n```\n\n![添加延时交换机](https://img-blog.csdnimg.cn/106078170371495d9f19780059e92d51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 3、总结\n\n​\t\t上面我们提到了使用RabbitMQ实现延时队列功的方案：1）借助本事的死信队列实现，监听死信队列；2）借助插件实现。优缺点如下：\n\n- 死信队列实现方式，需要在队列上设置消息过期时间，不灵活；需要再多用一个死信队列，占用空间；rabbitmq本事自带死信队列，实现方便。\n- 插件实现方式，需要下载安装插件，要考虑版本兼容性；代码逻辑简单，容易上手。\n\n​\t\t回到我们开头的需求：订单支付超时自动取消。这个功能主要就是需要一个延时队列，那通过rabbitmq实现延时队列只是一种方式，还可以通过其他方式实现，比如Java的 `DelayQueue` 、`Quartz定时任务`、`Redis的zset`、`时间轮` 等都可以实现，具体方案还是要结合项目和具体方式的优缺点来选择。比如项目中使用到了RabbitMQ，那使用RabbitMQ实现延迟队列就是比较好的方式，那具体选择插件方式还是死信队列方式，还需要看项目中对该功能的灵活程度来选择。\n\n**参考：**\n\n1. [https://www.rabbitmq.com/dlx.html](https://www.rabbitmq.com/dlx.html)\n2. [https://www.cnblogs.com/williamwsj/p/8108970.html](https://www.cnblogs.com/williamwsj/p/8108970.html)\n3. [https://www.jianshu.com/p/256d2eaf1786](https://www.jianshu.com/p/256d2eaf1786)\n4. [https://www.rabbitmq.com/community-plugins.html](https://www.rabbitmq.com/community-plugins.html)\n5. [https://blog.csdn.net/zhenghongcs/article/details/106700446](https://blog.csdn.net/zhenghongcs/article/details/106700446)\n\n------\n\n最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～\n","slug":"RabbitMQ的死信队列和延时队列","published":1,"updated":"2021-12-26T08:02:20.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxmyxe9o0003cjs64sose9qg","content":"<h1 id=\"RabbitMQ死信队列和延时队列\"><a href=\"#RabbitMQ死信队列和延时队列\" class=\"headerlink\" title=\"RabbitMQ死信队列和延时队列\"></a>RabbitMQ死信队列和延时队列</h1><p>​        RabbitMQ本身是具有<code>死信队列</code>和<code>死信交换机</code>属性的，<code>延时队列</code> 可以通过死信队列和死信交换机来实现。在电商行业中，通常都会有一个需求：订单超时未支付，自动取消该订单。那么通过RabbitMQ实现的延时队列就是实现该需求的一种方式。</p>\n<h2 id=\"1、死信队列\"><a href=\"#1、死信队列\" class=\"headerlink\" title=\"1、死信队列\"></a>1、死信队列</h2><p>​        <code>死信</code>顾名思义，就是死掉的信息，英文是Dead Letter。<code>死信交换机（Dead-Letter-Exchange）</code>和普通交换机没有区别，都是可以接受信息并转发到与之绑定并能路由到的队列，区别在于<code>死信交换机</code>是转发<code>死信</code>的，而和该<code>死信交换机</code>绑定的队列就是<code>死信队列</code>。说的再通俗一点，死信交换机和死信队列其实都只是普通的交换机和队列，只不过接受、转发的信息是<code>死信</code>，其他操作并没有区别。</p>\n<h3 id=\"1-1-死信的条件\"><a href=\"#1-1-死信的条件\" class=\"headerlink\" title=\"1.1 死信的条件\"></a>1.1 死信的条件</h3><p>​        称为<code>死信</code>的信息，需要如下几个条件：</p>\n<ul>\n<li>消息被消费者拒绝（通过basic.reject 或者 back.nack），并且设置 requeue=false。</li>\n<li>消息过期，因为队列设置了TTL（Time To Live）时间。</li>\n<li>消息被丢弃，因为超过了队列的长度限制。</li>\n</ul>\n<p>这时以上几个条件的方式基本上都有2种：1）<code>rabbitmqctl</code>命令行设置policy（策略）参数； 2）硬编码，也就是在代码中设置。</p>\n<h3 id=\"1-2-消费者拒绝\"><a href=\"#1-2-消费者拒绝\" class=\"headerlink\" title=\"1.2 消费者拒绝\"></a>1.2 消费者拒绝</h3><h4 id=\"1-2-1-编码方式\"><a href=\"#1-2-1-编码方式\" class=\"headerlink\" title=\"1.2.1 编码方式\"></a>1.2.1 编码方式</h4><p>​        硬编码就是在代码中编写<strong>业务队列声明时</strong>对应的参数：</p>\n<ul>\n<li><code>x-dead-letter-exchange</code>：死信交换机，必须</li>\n<li><code>x-dead-letter-routing-key</code>：死信交换机转发到死信队列的路由键，可选</li>\n</ul>\n<p><strong>Producer:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RejectProducer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义业务交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ORDER_X = <span class=\"string\">&quot;order.exchange&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// main方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 发消息，路由键分别为：d.order.123、d.other.123、d</span></span><br><span class=\"line\">        <span class=\"comment\">// 1）d.order.123：业务consumer会收到消息，order死信队列也会收到消息</span></span><br><span class=\"line\">        <span class=\"comment\">// 2）d.other.123：业务consumer会收到消息，other死信队列也会收到消息</span></span><br><span class=\"line\">        <span class=\"comment\">// 3）d：只有业务consumer会收到消息</span></span><br><span class=\"line\">        channel.basicPublish(ORDER_X, <span class=\"string\">&quot;d.order.123&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;hello my friend&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 死信队列条件：消费者拒绝</span></span><br><span class=\"line\"><span class=\"comment\"> * 1）basic.reject(tag, requeue) 表示拒绝接受消息，第二个参数表示是否重新入队，如果为true，可能造成死循环，需要注意</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）basic.nack(tag, multi, requeue) multi可以同时拒绝多条，requeue和reject相同。nack表示未ack的数据，会有单独的标识</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RejectConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_X = <span class=\"string\">&quot;dead.letter.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_Q_1 = <span class=\"string\">&quot;dead.letter.queue.order&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_Q_2 = <span class=\"string\">&quot;dead.letter.queue.other&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ORDER_X = <span class=\"string\">&quot;order.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ORDER_Q = <span class=\"string\">&quot;order.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// reject和nack方式</span></span><br><span class=\"line\">        rejectAndNack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectAndNack</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明死信队列和死信交换机</span></span><br><span class=\"line\">        declareOrderDLX(channel);</span><br><span class=\"line\">        declareOtherDLX(channel);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 声明业务交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(ORDER_X, <span class=\"string\">&quot;topic&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置业务参数</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 设置死信交换机，一个死信交换机绑定了两个死信队列，根据路由键来区分消息的转发</span></span><br><span class=\"line\">        arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_X);</span><br><span class=\"line\">        <span class=\"comment\">// 设置死信队列路由key：</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果这里设置了路由键，则publish过来的消息再转发到死信交换机时，以该路由键转发到死信队列，</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果未设置该参数，则按照publish时的路由键转发到死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;d.other&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// 声明业务队列</span></span><br><span class=\"line\">        channel.queueDeclare(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, arguments);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定业务队列和业务交换机</span></span><br><span class=\"line\">        channel.queueBind(ORDER_Q, ORDER_X, <span class=\"string\">&quot;#&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 监听业务队列消息</span></span><br><span class=\"line\">        channel.basicConsume(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;order consumer: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                <span class=\"comment\">// 拒绝</span></span><br><span class=\"line\">                channel.basicReject(envelope.getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;order properties: &quot;</span> + envelope.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明order死信队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOrderDLX</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机，只是为了模拟，设置的duriable=false，autodelete=true</span></span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_LETTER_X, <span class=\"string\">&quot;topic&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(DEAD_LETTER_Q_1, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定交换机和队列，只接受 *.order.# 规则的消息</span></span><br><span class=\"line\">        channel.queueBind(DEAD_LETTER_Q_1, DEAD_LETTER_X, <span class=\"string\">&quot;*.order.#&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 监听消息</span></span><br><span class=\"line\">        channel.basicConsume(DEAD_LETTER_Q_1, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter consumer 【order】: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter properties 【order】:&quot;</span> + envelope.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明other死信队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOtherDLX</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_LETTER_X, <span class=\"string\">&quot;topic&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(DEAD_LETTER_Q_2, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定交换机和队列，只接受 *.other.# 规则的消息</span></span><br><span class=\"line\">        channel.queueBind(DEAD_LETTER_Q_2, DEAD_LETTER_X, <span class=\"string\">&quot;*.other.#&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 监听消息</span></span><br><span class=\"line\">        channel.basicConsume(DEAD_LETTER_Q_2, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter consumer 【other】: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter properties 【other】:&quot;</span> + envelope.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p><strong>1）</strong> consumer方使用<code>basic.reject</code>或者<code>basic.nack</code>都会将消息转发到匹配的死信队列（requeue=false），区别在于<code>basic.reject</code>相比<code>basic.nack</code>少一个参数<code>mutil</code>，表示是否批量back。而且nack的数量可以再web端看到。</p>\n<p><strong>2）</strong> 使用<code>x-letter-dead-exchange</code>设置死信交换机，这个是必须设置的。<code>x-letter-dead-routing-key</code>设置死信交换机转发到死信队列的路由键，相当于重新定义了publish的路由键，该参数可选，可以根据具体业务判断是否需要设置。</p>\n<h4 id=\"1-1-2-策略方式\"><a href=\"#1-1-2-策略方式\" class=\"headerlink\" title=\"1.1.2 策略方式\"></a>1.1.2 策略方式</h4><p>策略方式需要在rabbitmq的服务器上执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy &#123;策略名称&#125; <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy dlx <span class=\"string\">&quot;dead.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;test-dead-letter-exchange&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示给所有的 <em>以dead.开头</em> 的队列设置死信交换机 <em>test-dead-letter-exchange</em> ，策略名字为 <em>dlx</em>。然后我们在rabbitmq的web界面新建一个名字为<code>test-dead-letter-exchange</code>的exchange，并且新建名为<code>dead.order.queue</code>和<code>dead.other.queue</code>的queue，绑定<code>test-dead-letter-exchange</code>，路由键分别为：<code>order.#</code>和<code>other.#</code>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9b1d1dd66aeb4e7292f0058df0a368b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"死信交换机绑定死信队列\"></p>\n<blockquote>\n<p>说明：由于我们要模拟的死信转发到死信队列的情况，所以这两个新建的queue都设置了ttl为10000ms，也就是10s。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/dbdbef64985544f8afdd75dc4cb06712.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"死信队列\">        </p>\n<p>我们看到消息在10s之后成功到了<code>dead.order.queue</code>，说明我们的配置生效。这里我将这个过程画个图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d6d9c46a56fc4a0cb9722c5000360189.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"绑定死信队列\"></p>\n<h3 id=\"1-3-设置过期时间\"><a href=\"#1-3-设置过期时间\" class=\"headerlink\" title=\"1.3 设置过期时间\"></a>1.3 设置过期时间</h3><blockquote>\n<p>文档：<a href=\"https://www.rabbitmq.com/ttl.html\">https://www.rabbitmq.com/ttl.html</a></p>\n</blockquote>\n<p>​        我们可以给 <em>队列</em> 或者 <em>消息</em> 设置过期时间。<em>队列</em> 的过期时间，类似于 <code>autoDelete</code> 参数，表示队列在指定时长内如果没有使用的话会被删除，队列没有使用者，队列最近未重新声明（重新声明续订租约），以及<code>basic.get</code>至少在过期期间未被调用，例如，这可以用于RPC样式的回复队列，其中可以创建许多可能永远不会被耗尽的队列。<em>消息</em> 的过期时间我们可以在发消息时设置在消息体，也可以给这个队列设置一个消息过期时间，其实就是两种方式，一种设置在队列上，另一种是设置在消息上。</p>\n<h4 id=\"1-3-1-编码方式\"><a href=\"#1-3-1-编码方式\" class=\"headerlink\" title=\"1.3.1 编码方式\"></a>1.3.1 编码方式</h4><p><strong>1）设置消息体过期时间</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置消息属性</span></span><br><span class=\"line\">AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties.Builder()</span><br><span class=\"line\">    .expiration(<span class=\"string\">&quot;2000&quot;</span>) <span class=\"comment\">// 设置消息过期时间，2s，既是所在队列没有过期时间也可以</span></span><br><span class=\"line\">    .build();</span><br><span class=\"line\"><span class=\"comment\">// 发消息</span></span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;order.123&quot;</span>, properties, <span class=\"string\">&quot;hello my friend&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）设置队列的消息过期时间</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 设置队列的过期时间，5s</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置死信队列</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_X);</span><br><span class=\"line\"><span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">channel.queueDeclare(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，创建好队列之后会有个<code>TTL</code>标识，<code>x-message-ttl</code>标识该队列设置的消息过期时间为5s。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c05ac2bbdb3049db94b434e4e3c508d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"队列的消息过期时间\"></p>\n<p><strong>3）设置队列的过期时间</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置队列参数</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 设置队列中消息的过期时间，5s</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置队列的过期时间，10s如果队列未使用（未操作），则删除队列</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-expires&quot;</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">channel.queueDeclare(ORDER_Q, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：无论队列中是否存在消息，如果没有操作队列，就会被自动删除。</strong></p>\n<h4 id=\"1-3-2-策略方式\"><a href=\"#1-3-2-策略方式\" class=\"headerlink\" title=\"1.3.2 策略方式\"></a>1.3.2 策略方式</h4><p><strong>1）设置队列的消息过期时间</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy --vhost /adu TTL <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;message-ttl&quot;:60000&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示在 <code>/adu</code>虚拟主机下增加一个名称为 <em>TTL</em> 策略，设所有队列 <code>message-ttl</code>消息过期时间60s。</p>\n<p><strong>2）设置队列的过期时间</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy --vhost /adu expiry <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;expires&quot;:1800000&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示在<code>/adu</code>虚拟主机下增加一个名称为 <em>expiry</em> 的策略，设置所有的队列过期时间为180s。</p>\n<h3 id=\"1-4-超过队列长度\"><a href=\"#1-4-超过队列长度\" class=\"headerlink\" title=\"1.4 超过队列长度\"></a>1.4 超过队列长度</h3><p>​        默认情况下，队列没有长度限制（但是总归是有硬盘和内存的限制的）。我们可以显示的设置队列的长度，可以是消息的<strong>数量限制</strong>，也可以是队列总消息内容的<strong>占用内存长度</strong>，或者两种都设置。一个队列的最大长度，可以使用 <em>策略</em> 或者 <em>编码</em> 的方式进行设置，或者在创建队列时web界面设置。如果 <code>策略</code> 方式和 <code>编码</code> 方式都设置了，则 <code>值更小的</code> 会生效。</p>\n<p>​        如果队列设置了队列长度限制，那么当队列中的消息达到最大长度时，默认的 <em>溢出</em> 规则为 <em>丢弃最老的消息（队列头部）</em>。我们可以改变这个规则，使用 <code>overflow</code> 参数来配置。<code>overflow</code> 可选值为 <code>x-reject-publish</code>或者<code>x-reject-publish-dls</code> ，两者都表示拒绝接受新消息，区别在于 <code>reject-publish-dlx</code> 也会导致死信拒绝消息<sup>1</sup>。</p>\n<blockquote>\n<p>此处有个疑问：reject-publish-dlx和reject-publish的区别问题。针对官网的翻译，我觉得 <code>reject-publish-dlx</code> 是与之绑定的死信队列不会收到消息， <code>reject-publish</code> 相反会收到消息。但是做实验的时候刚好和我理解的相反？熟悉的铁子们回复说一下哈呀。</p>\n</blockquote>\n<h4 id=\"1-4-1-编码方式\"><a href=\"#1-4-1-编码方式\" class=\"headerlink\" title=\"1.4.1 编码方式\"></a>1.4.1 编码方式</h4><p>​        使用<code>x-max-length</code>和<code>x-max-length-bytes</code>参数设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 设置队列最大长度，5条消息</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-max-length&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 队列溢出的策略：drop-head（默认）、reject-publish、reject-publish-dlx</span></span><br><span class=\"line\"><span class=\"comment\">//        arguments.put(&quot;x-overflow&quot;, &quot;reject-publish-dlx&quot;);</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-overflow&quot;</span>, <span class=\"string\">&quot;reject-publish&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置死信队列</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_X);</span><br><span class=\"line\"><span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">channel.queueDeclare(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-2-策略方式\"><a href=\"#1-4-2-策略方式\" class=\"headerlink\" title=\"1.4.2 策略方式\"></a>1.4.2 策略方式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy --vhost /adu <span class=\"built_in\">limit</span> <span class=\"string\">&quot;^five_msg&quot;</span> <span class=\"string\">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;test-dead-letter-exchange&quot;,&quot;max-length&quot;:5,&quot;overflow&quot;:&quot;reject-publish-dlx&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示在 <code>/adu</code>虚拟主机下增加一个名称为 <em>limit</em> 策略，设所有以 <em>five_msg</em> 开头的队列 <em>消息最多为5个</em>、<em>消息溢出策略为拒绝</em>、<em>设置死信交换机</em> 。</p>\n<blockquote>\n<p>设置 <code>max-length-bytes</code> 也是同样的方式。</p>\n</blockquote>\n<h2 id=\"2、延时队列\"><a href=\"#2、延时队列\" class=\"headerlink\" title=\"2、延时队列\"></a>2、延时队列</h2><p>​        延时队列，顾名思义就是存放延时消息的队列，也就是说消费者在一定的延时后才会收到消息。典型的应用场景就是如上所述的订单超时未支付自动取消。</p>\n<h3 id=\"2-1-借助死信队列实现\"><a href=\"#2-1-借助死信队列实现\" class=\"headerlink\" title=\"2.1 借助死信队列实现\"></a>2.1 借助死信队列实现</h3><p>​        其实在介绍完 <em>死信队列</em> 之后，就能大概看出来如何使用 <em>死信队列</em> 来实现延时队列了。就是使用消息的<code>TTL</code> 属性，将过期的消息转发到死信队列中，业务监听死信队列的消息就行了。这种情况适合给队列设置消息过期时间的情况，就是队列中所有的消息都是同一个过期时间，到期按照顺序转发到死信队列中，不会有问题。</p>\n<p>​        如果消息的过期时间是在发消息的时候设置在消息体上的，可能会出问题。比如按顺序发送msg1和msg2两条消息，msg1的过期时间为5s，msg2的过期时间为2s。正常理解下，结果肯定是msg2先到死信队列被消费，但是结果却是两条消息都在5s时转发到死信队列被消费。其实比较好理解，因为队列的特性就是 <em>先进先出</em> ，即使msg2先到了过期时间，但是msg1在它之前阻塞，只有msg1被消费了，msg2才能到队头被消费。 我们画个图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/15894c373b12405381d8e89b2383a82b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"死信队列实现延时队列问题\"></p>\n<h3 id=\"2-2-借助RabbitMQ插件实现\"><a href=\"#2-2-借助RabbitMQ插件实现\" class=\"headerlink\" title=\"2.2 借助RabbitMQ插件实现\"></a>2.2 借助RabbitMQ插件实现</h3><p>​        rabbitmq提供了一个插件 <code>rabbitmq_delayed_message_exchange</code> 让我们能够实现 <em>延迟队列</em> 的效果，同时能够解决 <em>通过死信队列实现延迟队列</em> 出现的消息阻塞问题。该插件从RabbitMQ的3.6.12开始支持，要确认当前自己的rabbitmq版本是否支持该插件。</p>\n<h4 id=\"2-2-1-下载插件\"><a href=\"#2-2-1-下载插件\" class=\"headerlink\" title=\"2.2.1 下载插件\"></a>2.2.1 下载插件</h4><blockquote>\n<p>下载地址：<a href=\"https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases</a></p>\n</blockquote>\n<p>​        下载该插件后，将 <code>rabbitmq_delayed_message_exchange-3.9.0.ez</code> 包放到 <em>RabbitMQ安装目录的plugins</em> 目录下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bb1b98bbafdf455dbd9a38491aeefccd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"插件位置\"></p>\n<h4 id=\"2-2-2-启用插件\"><a href=\"#2-2-2-启用插件\" class=\"headerlink\" title=\"2.2.2 启用插件\"></a>2.2.2 启用插件</h4><p>执行控制台命令，重启rabbitmq服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.列出所有插件</span></span><br><span class=\"line\">rabbitmq-plugins list</span><br><span class=\"line\"><span class=\"comment\"># 2.启用rabbitmq_delayed_message_exchange</span></span><br><span class=\"line\">rabbitmq-plubins <span class=\"built_in\">enable</span> rabbitmq_delayed_message_exchange</span><br><span class=\"line\"><span class=\"comment\"># 3.重启服务（好像可以不用重启）</span></span><br><span class=\"line\">systemctl restart rabbitmq-server.service</span><br></pre></td></tr></table></figure>\n\n<p>​        在此之后，web界面的 <em>exchanges</em> 便可以创建type为 <code>x-delayed-message</code> 的交换机，或者在代码中声明该类型的交换机。要是用其延时功能，需要在发消息的时候加一个 header ：<code>x-delay=xxx</code> ，表示延时xxx毫秒。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明延时交换机，type=x-delayed-message，x-delayed-type=direct|fanout|topic</span></span><br><span class=\"line\">Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">args.put(<span class=\"string\">&quot;x-delayed-type&quot;</span>, <span class=\"string\">&quot;topic&quot;</span>); <span class=\"comment\">// 相当于之前exchange的type</span></span><br><span class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;x-delayed-message&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送消息，x-delay，值为过期时间</span></span><br><span class=\"line\">Map&lt;String, Object&gt; headers = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">headers.put(<span class=\"string\">&quot;x-delay&quot;</span>, <span class=\"number\">5000</span>); <span class=\"comment\">// 5s</span></span><br><span class=\"line\">AMQP.BasicProperties props = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder()</span><br><span class=\"line\">    .headers(headers)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"><span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">channel.basicPublish(EXCHANGE_NAME, <span class=\"string\">&quot;other.save&quot;</span>, props, <span class=\"string\">&quot;i am 5s message&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/106078170371495d9f19780059e92d51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"添加延时交换机\"></p>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><p>​        上面我们提到了使用RabbitMQ实现延时队列功的方案：1）借助本事的死信队列实现，监听死信队列；2）借助插件实现。优缺点如下：</p>\n<ul>\n<li>死信队列实现方式，需要在队列上设置消息过期时间，不灵活；需要再多用一个死信队列，占用空间；rabbitmq本事自带死信队列，实现方便。</li>\n<li>插件实现方式，需要下载安装插件，要考虑版本兼容性；代码逻辑简单，容易上手。</li>\n</ul>\n<p>​        回到我们开头的需求：订单支付超时自动取消。这个功能主要就是需要一个延时队列，那通过rabbitmq实现延时队列只是一种方式，还可以通过其他方式实现，比如Java的 <code>DelayQueue</code> 、<code>Quartz定时任务</code>、<code>Redis的zset</code>、<code>时间轮</code> 等都可以实现，具体方案还是要结合项目和具体方式的优缺点来选择。比如项目中使用到了RabbitMQ，那使用RabbitMQ实现延迟队列就是比较好的方式，那具体选择插件方式还是死信队列方式，还需要看项目中对该功能的灵活程度来选择。</p>\n<p><strong>参考：</strong></p>\n<ol>\n<li><a href=\"https://www.rabbitmq.com/dlx.html\">https://www.rabbitmq.com/dlx.html</a></li>\n<li><a href=\"https://www.cnblogs.com/williamwsj/p/8108970.html\">https://www.cnblogs.com/williamwsj/p/8108970.html</a></li>\n<li><a href=\"https://www.jianshu.com/p/256d2eaf1786\">https://www.jianshu.com/p/256d2eaf1786</a></li>\n<li><a href=\"https://www.rabbitmq.com/community-plugins.html\">https://www.rabbitmq.com/community-plugins.html</a></li>\n<li><a href=\"https://blog.csdn.net/zhenghongcs/article/details/106700446\">https://blog.csdn.net/zhenghongcs/article/details/106700446</a></li>\n</ol>\n<hr>\n<p>最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RabbitMQ死信队列和延时队列\"><a href=\"#RabbitMQ死信队列和延时队列\" class=\"headerlink\" title=\"RabbitMQ死信队列和延时队列\"></a>RabbitMQ死信队列和延时队列</h1><p>​        RabbitMQ本身是具有<code>死信队列</code>和<code>死信交换机</code>属性的，<code>延时队列</code> 可以通过死信队列和死信交换机来实现。在电商行业中，通常都会有一个需求：订单超时未支付，自动取消该订单。那么通过RabbitMQ实现的延时队列就是实现该需求的一种方式。</p>\n<h2 id=\"1、死信队列\"><a href=\"#1、死信队列\" class=\"headerlink\" title=\"1、死信队列\"></a>1、死信队列</h2><p>​        <code>死信</code>顾名思义，就是死掉的信息，英文是Dead Letter。<code>死信交换机（Dead-Letter-Exchange）</code>和普通交换机没有区别，都是可以接受信息并转发到与之绑定并能路由到的队列，区别在于<code>死信交换机</code>是转发<code>死信</code>的，而和该<code>死信交换机</code>绑定的队列就是<code>死信队列</code>。说的再通俗一点，死信交换机和死信队列其实都只是普通的交换机和队列，只不过接受、转发的信息是<code>死信</code>，其他操作并没有区别。</p>\n<h3 id=\"1-1-死信的条件\"><a href=\"#1-1-死信的条件\" class=\"headerlink\" title=\"1.1 死信的条件\"></a>1.1 死信的条件</h3><p>​        称为<code>死信</code>的信息，需要如下几个条件：</p>\n<ul>\n<li>消息被消费者拒绝（通过basic.reject 或者 back.nack），并且设置 requeue=false。</li>\n<li>消息过期，因为队列设置了TTL（Time To Live）时间。</li>\n<li>消息被丢弃，因为超过了队列的长度限制。</li>\n</ul>\n<p>这时以上几个条件的方式基本上都有2种：1）<code>rabbitmqctl</code>命令行设置policy（策略）参数； 2）硬编码，也就是在代码中设置。</p>\n<h3 id=\"1-2-消费者拒绝\"><a href=\"#1-2-消费者拒绝\" class=\"headerlink\" title=\"1.2 消费者拒绝\"></a>1.2 消费者拒绝</h3><h4 id=\"1-2-1-编码方式\"><a href=\"#1-2-1-编码方式\" class=\"headerlink\" title=\"1.2.1 编码方式\"></a>1.2.1 编码方式</h4><p>​        硬编码就是在代码中编写<strong>业务队列声明时</strong>对应的参数：</p>\n<ul>\n<li><code>x-dead-letter-exchange</code>：死信交换机，必须</li>\n<li><code>x-dead-letter-routing-key</code>：死信交换机转发到死信队列的路由键，可选</li>\n</ul>\n<p><strong>Producer:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RejectProducer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 定义业务交换机</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ORDER_X = <span class=\"string\">&quot;order.exchange&quot;</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// main方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 发消息，路由键分别为：d.order.123、d.other.123、d</span></span><br><span class=\"line\">        <span class=\"comment\">// 1）d.order.123：业务consumer会收到消息，order死信队列也会收到消息</span></span><br><span class=\"line\">        <span class=\"comment\">// 2）d.other.123：业务consumer会收到消息，other死信队列也会收到消息</span></span><br><span class=\"line\">        <span class=\"comment\">// 3）d：只有业务consumer会收到消息</span></span><br><span class=\"line\">        channel.basicPublish(ORDER_X, <span class=\"string\">&quot;d.order.123&quot;</span>, <span class=\"keyword\">null</span>, <span class=\"string\">&quot;hello my friend&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        RabbitMQUtil.close(channel, connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Consumer:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 死信队列条件：消费者拒绝</span></span><br><span class=\"line\"><span class=\"comment\"> * 1）basic.reject(tag, requeue) 表示拒绝接受消息，第二个参数表示是否重新入队，如果为true，可能造成死循环，需要注意</span></span><br><span class=\"line\"><span class=\"comment\"> * 2）basic.nack(tag, multi, requeue) multi可以同时拒绝多条，requeue和reject相同。nack表示未ack的数据，会有单独的标识</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RejectConsumer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_X = <span class=\"string\">&quot;dead.letter.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_Q_1 = <span class=\"string\">&quot;dead.letter.queue.order&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEAD_LETTER_Q_2 = <span class=\"string\">&quot;dead.letter.queue.other&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ORDER_X = <span class=\"string\">&quot;order.exchange&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ORDER_Q = <span class=\"string\">&quot;order.queue&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// reject和nack方式</span></span><br><span class=\"line\">        rejectAndNack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">rejectAndNack</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取连接</span></span><br><span class=\"line\">        Connection connection = RabbitMQUtil.getConnection();</span><br><span class=\"line\">        <span class=\"comment\">// 获取通道</span></span><br><span class=\"line\">        Channel channel = RabbitMQUtil.getChannel(connection);</span><br><span class=\"line\">        <span class=\"comment\">// 声明死信队列和死信交换机</span></span><br><span class=\"line\">        declareOrderDLX(channel);</span><br><span class=\"line\">        declareOtherDLX(channel);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 声明业务交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(ORDER_X, <span class=\"string\">&quot;topic&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 设置业务参数</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 设置死信交换机，一个死信交换机绑定了两个死信队列，根据路由键来区分消息的转发</span></span><br><span class=\"line\">        arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_X);</span><br><span class=\"line\">        <span class=\"comment\">// 设置死信队列路由key：</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果这里设置了路由键，则publish过来的消息再转发到死信交换机时，以该路由键转发到死信队列，</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果未设置该参数，则按照publish时的路由键转发到死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//        arguments.put(&quot;x-dead-letter-routing-key&quot;, &quot;d.other&quot;);</span></span><br><span class=\"line\">        <span class=\"comment\">// 声明业务队列</span></span><br><span class=\"line\">        channel.queueDeclare(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, arguments);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定业务队列和业务交换机</span></span><br><span class=\"line\">        channel.queueBind(ORDER_Q, ORDER_X, <span class=\"string\">&quot;#&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 监听业务队列消息</span></span><br><span class=\"line\">        channel.basicConsume(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;order consumer: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                <span class=\"comment\">// 拒绝</span></span><br><span class=\"line\">                channel.basicReject(envelope.getDeliveryTag(), <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;order properties: &quot;</span> + envelope.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明order死信队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOrderDLX</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机，只是为了模拟，设置的duriable=false，autodelete=true</span></span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_LETTER_X, <span class=\"string\">&quot;topic&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(DEAD_LETTER_Q_1, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定交换机和队列，只接受 *.order.# 规则的消息</span></span><br><span class=\"line\">        channel.queueBind(DEAD_LETTER_Q_1, DEAD_LETTER_X, <span class=\"string\">&quot;*.order.#&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 监听消息</span></span><br><span class=\"line\">        channel.basicConsume(DEAD_LETTER_Q_1, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter consumer 【order】: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter properties 【order】:&quot;</span> + envelope.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明other死信队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">declareOtherDLX</span><span class=\"params\">(Channel channel)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 声明交换机</span></span><br><span class=\"line\">        channel.exchangeDeclare(DEAD_LETTER_X, <span class=\"string\">&quot;topic&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">        channel.queueDeclare(DEAD_LETTER_Q_2, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 绑定交换机和队列，只接受 *.other.# 规则的消息</span></span><br><span class=\"line\">        channel.queueBind(DEAD_LETTER_Q_2, DEAD_LETTER_X, <span class=\"string\">&quot;*.other.#&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 监听消息</span></span><br><span class=\"line\">        channel.basicConsume(DEAD_LETTER_Q_2, <span class=\"keyword\">true</span>, <span class=\"keyword\">new</span> DefaultConsumer(channel) &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">handleDelivery</span><span class=\"params\">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class=\"keyword\">byte</span>[] body)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter consumer 【other】: &quot;</span> + <span class=\"keyword\">new</span> String(body, StandardCharsets.UTF_8));</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;dead letter properties 【other】:&quot;</span> + envelope.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p><strong>1）</strong> consumer方使用<code>basic.reject</code>或者<code>basic.nack</code>都会将消息转发到匹配的死信队列（requeue=false），区别在于<code>basic.reject</code>相比<code>basic.nack</code>少一个参数<code>mutil</code>，表示是否批量back。而且nack的数量可以再web端看到。</p>\n<p><strong>2）</strong> 使用<code>x-letter-dead-exchange</code>设置死信交换机，这个是必须设置的。<code>x-letter-dead-routing-key</code>设置死信交换机转发到死信队列的路由键，相当于重新定义了publish的路由键，该参数可选，可以根据具体业务判断是否需要设置。</p>\n<h4 id=\"1-1-2-策略方式\"><a href=\"#1-1-2-策略方式\" class=\"headerlink\" title=\"1.1.2 策略方式\"></a>1.1.2 策略方式</h4><p>策略方式需要在rabbitmq的服务器上执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy &#123;策略名称&#125; <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;my-dlx&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy dlx <span class=\"string\">&quot;dead.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;test-dead-letter-exchange&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示给所有的 <em>以dead.开头</em> 的队列设置死信交换机 <em>test-dead-letter-exchange</em> ，策略名字为 <em>dlx</em>。然后我们在rabbitmq的web界面新建一个名字为<code>test-dead-letter-exchange</code>的exchange，并且新建名为<code>dead.order.queue</code>和<code>dead.other.queue</code>的queue，绑定<code>test-dead-letter-exchange</code>，路由键分别为：<code>order.#</code>和<code>other.#</code>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9b1d1dd66aeb4e7292f0058df0a368b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"死信交换机绑定死信队列\"></p>\n<blockquote>\n<p>说明：由于我们要模拟的死信转发到死信队列的情况，所以这两个新建的queue都设置了ttl为10000ms，也就是10s。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/dbdbef64985544f8afdd75dc4cb06712.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"死信队列\">        </p>\n<p>我们看到消息在10s之后成功到了<code>dead.order.queue</code>，说明我们的配置生效。这里我将这个过程画个图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d6d9c46a56fc4a0cb9722c5000360189.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"绑定死信队列\"></p>\n<h3 id=\"1-3-设置过期时间\"><a href=\"#1-3-设置过期时间\" class=\"headerlink\" title=\"1.3 设置过期时间\"></a>1.3 设置过期时间</h3><blockquote>\n<p>文档：<a href=\"https://www.rabbitmq.com/ttl.html\">https://www.rabbitmq.com/ttl.html</a></p>\n</blockquote>\n<p>​        我们可以给 <em>队列</em> 或者 <em>消息</em> 设置过期时间。<em>队列</em> 的过期时间，类似于 <code>autoDelete</code> 参数，表示队列在指定时长内如果没有使用的话会被删除，队列没有使用者，队列最近未重新声明（重新声明续订租约），以及<code>basic.get</code>至少在过期期间未被调用，例如，这可以用于RPC样式的回复队列，其中可以创建许多可能永远不会被耗尽的队列。<em>消息</em> 的过期时间我们可以在发消息时设置在消息体，也可以给这个队列设置一个消息过期时间，其实就是两种方式，一种设置在队列上，另一种是设置在消息上。</p>\n<h4 id=\"1-3-1-编码方式\"><a href=\"#1-3-1-编码方式\" class=\"headerlink\" title=\"1.3.1 编码方式\"></a>1.3.1 编码方式</h4><p><strong>1）设置消息体过期时间</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置消息属性</span></span><br><span class=\"line\">AMQP.BasicProperties properties = <span class=\"keyword\">new</span> AMQP.BasicProperties.Builder()</span><br><span class=\"line\">    .expiration(<span class=\"string\">&quot;2000&quot;</span>) <span class=\"comment\">// 设置消息过期时间，2s，既是所在队列没有过期时间也可以</span></span><br><span class=\"line\">    .build();</span><br><span class=\"line\"><span class=\"comment\">// 发消息</span></span><br><span class=\"line\">channel.basicPublish(<span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;order.123&quot;</span>, properties, <span class=\"string\">&quot;hello my friend&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><strong>2）设置队列的消息过期时间</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 设置队列的过期时间，5s</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置死信队列</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_X);</span><br><span class=\"line\"><span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">channel.queueDeclare(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以看到，创建好队列之后会有个<code>TTL</code>标识，<code>x-message-ttl</code>标识该队列设置的消息过期时间为5s。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/c05ac2bbdb3049db94b434e4e3c508d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"队列的消息过期时间\"></p>\n<p><strong>3）设置队列的过期时间</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置队列参数</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 设置队列中消息的过期时间，5s</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-message-ttl&quot;</span>, <span class=\"number\">5000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置队列的过期时间，10s如果队列未使用（未操作），则删除队列</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-expires&quot;</span>, <span class=\"number\">10000</span>);</span><br><span class=\"line\"><span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">channel.queueDeclare(ORDER_Q, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：无论队列中是否存在消息，如果没有操作队列，就会被自动删除。</strong></p>\n<h4 id=\"1-3-2-策略方式\"><a href=\"#1-3-2-策略方式\" class=\"headerlink\" title=\"1.3.2 策略方式\"></a>1.3.2 策略方式</h4><p><strong>1）设置队列的消息过期时间</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy --vhost /adu TTL <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;message-ttl&quot;:60000&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示在 <code>/adu</code>虚拟主机下增加一个名称为 <em>TTL</em> 策略，设所有队列 <code>message-ttl</code>消息过期时间60s。</p>\n<p><strong>2）设置队列的过期时间</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy --vhost /adu expiry <span class=\"string\">&quot;.*&quot;</span> <span class=\"string\">&#x27;&#123;&quot;expires&quot;:1800000&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示在<code>/adu</code>虚拟主机下增加一个名称为 <em>expiry</em> 的策略，设置所有的队列过期时间为180s。</p>\n<h3 id=\"1-4-超过队列长度\"><a href=\"#1-4-超过队列长度\" class=\"headerlink\" title=\"1.4 超过队列长度\"></a>1.4 超过队列长度</h3><p>​        默认情况下，队列没有长度限制（但是总归是有硬盘和内存的限制的）。我们可以显示的设置队列的长度，可以是消息的<strong>数量限制</strong>，也可以是队列总消息内容的<strong>占用内存长度</strong>，或者两种都设置。一个队列的最大长度，可以使用 <em>策略</em> 或者 <em>编码</em> 的方式进行设置，或者在创建队列时web界面设置。如果 <code>策略</code> 方式和 <code>编码</code> 方式都设置了，则 <code>值更小的</code> 会生效。</p>\n<p>​        如果队列设置了队列长度限制，那么当队列中的消息达到最大长度时，默认的 <em>溢出</em> 规则为 <em>丢弃最老的消息（队列头部）</em>。我们可以改变这个规则，使用 <code>overflow</code> 参数来配置。<code>overflow</code> 可选值为 <code>x-reject-publish</code>或者<code>x-reject-publish-dls</code> ，两者都表示拒绝接受新消息，区别在于 <code>reject-publish-dlx</code> 也会导致死信拒绝消息<sup>1</sup>。</p>\n<blockquote>\n<p>此处有个疑问：reject-publish-dlx和reject-publish的区别问题。针对官网的翻译，我觉得 <code>reject-publish-dlx</code> 是与之绑定的死信队列不会收到消息， <code>reject-publish</code> 相反会收到消息。但是做实验的时候刚好和我理解的相反？熟悉的铁子们回复说一下哈呀。</p>\n</blockquote>\n<h4 id=\"1-4-1-编码方式\"><a href=\"#1-4-1-编码方式\" class=\"headerlink\" title=\"1.4.1 编码方式\"></a>1.4.1 编码方式</h4><p>​        使用<code>x-max-length</code>和<code>x-max-length-bytes</code>参数设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 设置参数</span></span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 设置队列最大长度，5条消息</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-max-length&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 队列溢出的策略：drop-head（默认）、reject-publish、reject-publish-dlx</span></span><br><span class=\"line\"><span class=\"comment\">//        arguments.put(&quot;x-overflow&quot;, &quot;reject-publish-dlx&quot;);</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-overflow&quot;</span>, <span class=\"string\">&quot;reject-publish&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置死信队列</span></span><br><span class=\"line\">arguments.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_X);</span><br><span class=\"line\"><span class=\"comment\">// 声明队列</span></span><br><span class=\"line\">channel.queueDeclare(ORDER_Q, <span class=\"keyword\">false</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, arguments);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-4-2-策略方式\"><a href=\"#1-4-2-策略方式\" class=\"headerlink\" title=\"1.4.2 策略方式\"></a>1.4.2 策略方式</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rabbitmqctl set_policy --vhost /adu <span class=\"built_in\">limit</span> <span class=\"string\">&quot;^five_msg&quot;</span> <span class=\"string\">&#x27;&#123;&quot;dead-letter-exchange&quot;:&quot;test-dead-letter-exchange&quot;,&quot;max-length&quot;:5,&quot;overflow&quot;:&quot;reject-publish-dlx&quot;&#125;&#x27;</span> --apply-to queues</span><br></pre></td></tr></table></figure>\n\n<p>表示在 <code>/adu</code>虚拟主机下增加一个名称为 <em>limit</em> 策略，设所有以 <em>five_msg</em> 开头的队列 <em>消息最多为5个</em>、<em>消息溢出策略为拒绝</em>、<em>设置死信交换机</em> 。</p>\n<blockquote>\n<p>设置 <code>max-length-bytes</code> 也是同样的方式。</p>\n</blockquote>\n<h2 id=\"2、延时队列\"><a href=\"#2、延时队列\" class=\"headerlink\" title=\"2、延时队列\"></a>2、延时队列</h2><p>​        延时队列，顾名思义就是存放延时消息的队列，也就是说消费者在一定的延时后才会收到消息。典型的应用场景就是如上所述的订单超时未支付自动取消。</p>\n<h3 id=\"2-1-借助死信队列实现\"><a href=\"#2-1-借助死信队列实现\" class=\"headerlink\" title=\"2.1 借助死信队列实现\"></a>2.1 借助死信队列实现</h3><p>​        其实在介绍完 <em>死信队列</em> 之后，就能大概看出来如何使用 <em>死信队列</em> 来实现延时队列了。就是使用消息的<code>TTL</code> 属性，将过期的消息转发到死信队列中，业务监听死信队列的消息就行了。这种情况适合给队列设置消息过期时间的情况，就是队列中所有的消息都是同一个过期时间，到期按照顺序转发到死信队列中，不会有问题。</p>\n<p>​        如果消息的过期时间是在发消息的时候设置在消息体上的，可能会出问题。比如按顺序发送msg1和msg2两条消息，msg1的过期时间为5s，msg2的过期时间为2s。正常理解下，结果肯定是msg2先到死信队列被消费，但是结果却是两条消息都在5s时转发到死信队列被消费。其实比较好理解，因为队列的特性就是 <em>先进先出</em> ，即使msg2先到了过期时间，但是msg1在它之前阻塞，只有msg1被消费了，msg2才能到队头被消费。 我们画个图：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/15894c373b12405381d8e89b2383a82b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"死信队列实现延时队列问题\"></p>\n<h3 id=\"2-2-借助RabbitMQ插件实现\"><a href=\"#2-2-借助RabbitMQ插件实现\" class=\"headerlink\" title=\"2.2 借助RabbitMQ插件实现\"></a>2.2 借助RabbitMQ插件实现</h3><p>​        rabbitmq提供了一个插件 <code>rabbitmq_delayed_message_exchange</code> 让我们能够实现 <em>延迟队列</em> 的效果，同时能够解决 <em>通过死信队列实现延迟队列</em> 出现的消息阻塞问题。该插件从RabbitMQ的3.6.12开始支持，要确认当前自己的rabbitmq版本是否支持该插件。</p>\n<h4 id=\"2-2-1-下载插件\"><a href=\"#2-2-1-下载插件\" class=\"headerlink\" title=\"2.2.1 下载插件\"></a>2.2.1 下载插件</h4><blockquote>\n<p>下载地址：<a href=\"https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases</a></p>\n</blockquote>\n<p>​        下载该插件后，将 <code>rabbitmq_delayed_message_exchange-3.9.0.ez</code> 包放到 <em>RabbitMQ安装目录的plugins</em> 目录下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bb1b98bbafdf455dbd9a38491aeefccd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"插件位置\"></p>\n<h4 id=\"2-2-2-启用插件\"><a href=\"#2-2-2-启用插件\" class=\"headerlink\" title=\"2.2.2 启用插件\"></a>2.2.2 启用插件</h4><p>执行控制台命令，重启rabbitmq服务：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.列出所有插件</span></span><br><span class=\"line\">rabbitmq-plugins list</span><br><span class=\"line\"><span class=\"comment\"># 2.启用rabbitmq_delayed_message_exchange</span></span><br><span class=\"line\">rabbitmq-plubins <span class=\"built_in\">enable</span> rabbitmq_delayed_message_exchange</span><br><span class=\"line\"><span class=\"comment\"># 3.重启服务（好像可以不用重启）</span></span><br><span class=\"line\">systemctl restart rabbitmq-server.service</span><br></pre></td></tr></table></figure>\n\n<p>​        在此之后，web界面的 <em>exchanges</em> 便可以创建type为 <code>x-delayed-message</code> 的交换机，或者在代码中声明该类型的交换机。要是用其延时功能，需要在发消息的时候加一个 header ：<code>x-delay=xxx</code> ，表示延时xxx毫秒。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 声明延时交换机，type=x-delayed-message，x-delayed-type=direct|fanout|topic</span></span><br><span class=\"line\">Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">args.put(<span class=\"string\">&quot;x-delayed-type&quot;</span>, <span class=\"string\">&quot;topic&quot;</span>); <span class=\"comment\">// 相当于之前exchange的type</span></span><br><span class=\"line\">channel.exchangeDeclare(EXCHANGE_NAME, <span class=\"string\">&quot;x-delayed-message&quot;</span>, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>, args);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 发送消息，x-delay，值为过期时间</span></span><br><span class=\"line\">Map&lt;String, Object&gt; headers = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">headers.put(<span class=\"string\">&quot;x-delay&quot;</span>, <span class=\"number\">5000</span>); <span class=\"comment\">// 5s</span></span><br><span class=\"line\">AMQP.BasicProperties props = <span class=\"keyword\">new</span> AMQP.BasicProperties().builder()</span><br><span class=\"line\">    .headers(headers)</span><br><span class=\"line\">    .build();</span><br><span class=\"line\"><span class=\"comment\">// 发送消息</span></span><br><span class=\"line\">channel.basicPublish(EXCHANGE_NAME, <span class=\"string\">&quot;other.save&quot;</span>, props, <span class=\"string\">&quot;i am 5s message&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/106078170371495d9f19780059e92d51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"添加延时交换机\"></p>\n<h2 id=\"3、总结\"><a href=\"#3、总结\" class=\"headerlink\" title=\"3、总结\"></a>3、总结</h2><p>​        上面我们提到了使用RabbitMQ实现延时队列功的方案：1）借助本事的死信队列实现，监听死信队列；2）借助插件实现。优缺点如下：</p>\n<ul>\n<li>死信队列实现方式，需要在队列上设置消息过期时间，不灵活；需要再多用一个死信队列，占用空间；rabbitmq本事自带死信队列，实现方便。</li>\n<li>插件实现方式，需要下载安装插件，要考虑版本兼容性；代码逻辑简单，容易上手。</li>\n</ul>\n<p>​        回到我们开头的需求：订单支付超时自动取消。这个功能主要就是需要一个延时队列，那通过rabbitmq实现延时队列只是一种方式，还可以通过其他方式实现，比如Java的 <code>DelayQueue</code> 、<code>Quartz定时任务</code>、<code>Redis的zset</code>、<code>时间轮</code> 等都可以实现，具体方案还是要结合项目和具体方式的优缺点来选择。比如项目中使用到了RabbitMQ，那使用RabbitMQ实现延迟队列就是比较好的方式，那具体选择插件方式还是死信队列方式，还需要看项目中对该功能的灵活程度来选择。</p>\n<p><strong>参考：</strong></p>\n<ol>\n<li><a href=\"https://www.rabbitmq.com/dlx.html\">https://www.rabbitmq.com/dlx.html</a></li>\n<li><a href=\"https://www.cnblogs.com/williamwsj/p/8108970.html\">https://www.cnblogs.com/williamwsj/p/8108970.html</a></li>\n<li><a href=\"https://www.jianshu.com/p/256d2eaf1786\">https://www.jianshu.com/p/256d2eaf1786</a></li>\n<li><a href=\"https://www.rabbitmq.com/community-plugins.html\">https://www.rabbitmq.com/community-plugins.html</a></li>\n<li><a href=\"https://blog.csdn.net/zhenghongcs/article/details/106700446\">https://blog.csdn.net/zhenghongcs/article/details/106700446</a></li>\n</ol>\n<hr>\n<p>最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～</p>\n"},{"title":"使用Github和Hexo搭建个人博客系统","top":false,"date":"2021-12-27T03:20:19.000Z","_content":"# 利用Github和Hexo搭建个人博客\n\n作为一名开发人员，写技术博客既是一种对知识的巩固，也是一种分享精神。所以有一个自己的技术博客，对于我们技术人员来说，是很nice的一件事。\n\n## 1、条件\n\n​\t如果要使用github搭建自己的博客系统，需要有一个 *Github账号* ，我们可以注册一个账号。其次需要一个 *node开发环境（nodejs、npm）*，因为 *Hexo* 框架需要使用node环境搭建。\n\n- github账号\n- node、npm环境（省略）\n- 本地安装了git（省略）\n\n本次我的实验环境：\n\n- MacBook Air m1芯片\n- git 2.33.1\n- node v16.13.1\n- npm 8.1.2\n\n## 2、注册github账号\n\n​\t相信如果是程序员同学，那一定已经拥有一个自己的github账号了，如果是已经拥有github账号的伙伴们可以直接看 *2.2小节* 。\n\n### 2.1 注册账号\n\n​\tgithub注册账号还是比较简单的，需要一个邮箱就行。但是国内访问会比较慢，所以耐心一点就行，这里略过。\n\n### 2.2 创建项目\n\n​\t创建项目需要注意的地方是仓库的名字，命名为 *你的账号.github.io*  ，之后个人博客访问的域名就是 *https://你的账号.github.io* 。\n\n![创建github项目](https://img-blog.csdnimg.cn/9e3a87a1040a47038bcf0676a4c1d69c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n> 这里我已经创建过，所以提示已经存在。\n\n​\t项目创建好之后，需要本地把我们的项目拉下来，因为博客内容一般都是在本地写好在上传到github的，而且本地还可以启动服务预览博客，以便我们在正式发布之前，调整内容和样式。这里我们使用 `git` 协议去拉取仓库，就需要配置 `ssh key` ，因为直接使用账号密码不太安全，相关账号密码需要配置在配置文件。\n\n### 2.3 配置ssh key\n\n​\t首先连接过的ssh key会在  `~/.ssh` 目录下有 *xxx.pub*文件，就是公钥。但是是首次连接的话，那么就需要配置一下了，如下：\n\n```bash\n# 1.查看.ssh文件夹，是否有配置过密钥\nls ~/.ssh\n# 2.如果不存在密钥，则需要创建，如下命令直接三个回车就可以\nssh-keygen -t rsa-C \"邮箱地址\"\n# 3.执行完以上步骤之后，会生成两个文件\nid_rsa 和 id_rsa.pub\n# 4.使用vim打开id_ras.pub，复制内容到github的公钥配置中\n# 5.测试是否已经连通\nssh -T git@github.com\n看到结果如下则表示连通：Hi 用户名! You've successfully authenticated, but GitHub does not provide shell access.\n# 6.还需要配置下公共的用户名和邮箱\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱\"\n```\n\n### 2.4 设置gitbhu pages\n\n​\t找到项目的 `Settings -> Pages -> Source  ` ，设置branch和root。\n\n![设置Github Pages](https://img-blog.csdnimg.cn/7282fbfc184f4245997fc0367c5caf73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 3、搭建Hexo环境\n\n​\tHexo是一个快速、简介且高效的博客框架，官网：[https://hexo.io/zh-cn/](https://hexo.io/zh-cn/) ，可以在网站下学习他的API、文档、插件、主题等。\n\n### 3.1 搭建环境\n\n**注意：** 由于mac系统新版本对 `/usr/*` 做了权限限制，无法写入，所以我们需要修改下默认的npm全局依赖包的位置。\n\n```bash\n# 0.修改npm全局依赖仓库位置，并设置到环境变量\nmkdir ~/.npm-global\n# 1.将新位置加入到环境变量，在./bash_profile中加入以下内容\nexport PATH=~/.npm-global/bin:$PATH\n# 2.修改 .zshrc （因为我用的zsh），加入以下内容\nsource ~/.bash_profile\n```\n\n​\t接下来我们搭建hexo环境：\n\n```bash\n# 1.安装hexo-cli工具（全局）\nnpm install -g hexo-cli\n# 2.安装hexo（可局部安装，我就是安装在了我的博客项目中）\ncd ~/projects/dmaker1993@github.io\nnpm install hexo\n```\n\n### 3.2 初始化Hexo\n\n​\t我们要使用 `hexo` 命令初始化一个hexo博客写作环境，相当于是hexo的基本框架：\n\n```bash\n# 1.将项目拉到本地某个文件夹，我的是 /Users/adu/IdeaProjects/dmaker1993.github.io\ncd /Users/adu/IdeaProjects/\ngit clone git@dmaker1993@dmaker1993.github.io.git\n# 2.进入项目中，初始化hexo框架\ncd dmaker1993.github.io\nhexo init\n# 3.构建demo博客，生成静态文件\nhexo generate\n# 4.启动本地环境，查看demo\nhexo server\n# 5.访问localhost:4000\n```\n\n​\t初始化之后的目录结构如下：\n\n![hexo目录结构](https://img-blog.csdnimg.cn/b6f93034c3764ead8f64bf928ea85144.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n```tex\n.\n├── _config.yml # 网站的配置信息，可以配置网站的绝大部分信息\n├── package.json # 应用程序的信息，可以不关注\n├── scaffolds # 模版文件夹，我们在创建新文章时，可以指定某一个模板来生成新文章（.md文档）\n├── source # 存放用户资源文件的地方，同时这里也会存放我们的博客、标签、目录等内容，这里的.md和html文件会被编译到public文件夹\n|   ├── _drafts # 草稿文件\n|   └── _posts # 博客文件，这里的博客文件会被编译到public文件夹中\n└── themes # 主题文件夹，hexo会根据主题生成博客静态页面\n```\n\n#### 3.3 选择主题\n\n​\t经过 *[3.2步骤](#3.2)* 之后，我们就已经搭建好了一个hexo环境，然后就可以写博客了。但是默认的信息比如 *博客名称*、*所有者* 等等信息，需要都替换成我们自己的，也就是做一些配置的修改，我们直接修改项目根目录下的 `_config.yml` 文件, 以下是一些hexo配置信息的修改：\n\n```yaml\ntitle: 网站标题\nsubtitle: 网站副标题\ndescription: 网站描述\nkeywords: 网站的关键词。支持多个关键词\nauthor: 作者姓名\nlanguage: 语言，对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。\ntimezone: 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。\nurl: 网址, 必须以 http:// 或 https:// 开头\ntheme: 主题，这个是关键，我们可以在网上找一些好看主题\ndeploy:\n  type: git\n  repo: 仓库地址\n  branch: 分支，一般是master\n```\n\n​\t上述的 `theme` 就是主题的名字，我们可以到hexo官方提供的列表中选择一个自己喜欢的：[https://hexo.io/themes/](https://hexo.io/themes/)。我用的是 *[hexo-theme-melody](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/)* 这个主题，他的文档也比较全，下面是一些展示：\n\n![dmaker1993博客首页](https://img-blog.csdnimg.cn/5b038cb8bc9b4fe9b99cfcba1e9bef77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![damper993博客内容详情页](https://img-blog.csdnimg.cn/bc1d723e296d4913b5c0e0ab625d9b9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t更多的可以去看看我的博客：[https://dmaker1993.github.io/](https://dmaker1993.github.io/) 。\n\n#### 3.4 主题下载和配置\n\n​\t在搭建的过程中也是直接看的文档，比较简单，如果有什么问题可以给我留言哦。首先下载主题，因为我下载的hexo是最新的，所以我直接使用npm安装。\n\n1）主题下载\n\n```bash\nnpm install hexo-theme-melody\n```\n\n​\t下载之后，我们就可以在 `node_modules` 目录下找到这个主题的依赖：\n\n![hexo主题目录结构](https://img-blog.csdnimg.cn/04df98ca7c494ea28618cf314d0633ab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n2）设置主题\n\n​\t找到项目跟目录下的 `_config.yml` ，修改其中的 `theme` 值为 `melody`。\n\n```yaml\ntheme: melody # 将主题设置成melody\n```\n\n3）配置\n\n​\t先安装两个渲染插件：\n\n```bash\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n\n​\t然后将 `node_modules/hexo-theme-melody/_config.yml` 文件复制到项目根目录下，并改名为 `_config.melody.yml` ，修改其中的一些配置信息，比如我的配置（`_config.melody.yml`）是这样的：\n\n```yaml\n# 配置语言的\nlanguage: zh-Hans\n# 配置菜单的（ ':'之前的是展示的名字，之后的是博客中关联的）\nmenu:\n  首页: /\n  归档: /archives\n  标签: /tags\n  分类: /categories\n  #XXX: /xxx\n# 社交信息，可以挂一写自己的github，微博什么的\nsocial:\n#icon_name fa: url\n#icon_name fab: url\n  github fa: https://github.com/Dmaker1993\n  weibo fa: https://blog.csdn.net/DMaker1993\n# footer设置\nsince: 2021\n```\n\n全部的主题配置在这里：[https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html) 。\n\n4）测试\n\n​\t都配置好之后，我们就可以看一下效果了，执行如下命令：\n\n```bash\n# 清理\nhexo clear\n# 构建。hexo generate 简写为：hexo g\nhexo g\n# 启动服务。hexo server 简写：hexo s\nhexo s\n```\n\n​\t正常是一片 *Hello World* 的demo文章，这里我们就都配置好了，下面我们就可以开始写博客了。\n\n## 4、写博客\n\n​\t这个过程大概就是：生成博客文档、填充博客内容、构建博客页面、发布。等待几分钟之后，我们在自己的 *github.io* 页面中就能够看到了。下面我们看一下具体步骤：\n\n```bash\n# 1.生成博客文档，主要是生成一些hexo必要的配置\nhexo new [layout] \"博客名称\" \n\t## 这个命令会生成 ./source/_posts/博客名称.md 文档\n\t## layout表示模板名称，默认使用post，在./scaffolds中可以看到所有的模版\n# 2.写博客，我一般会用 typora 写mk文档\n# 3.将写好的mk文档复制到刚才生成的文档中，注意不要覆盖掉之前的配置，比如 title、categories等\n# 4.构建\nhexo g\n# 5.本地预览\nhexo s\n# 6.发布，就是将本地的代码上传到github，这个过程是完全覆盖现在github上的内容的，所以一定要先拉下来。\nhexo d\n```\n\n![创建新博客](https://img-blog.csdnimg.cn/bb8da1e5e6f94dadbab5387fc9b75758.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![创建结果](https://img-blog.csdnimg.cn/57fd27ae974643b49be6155b4e4bc5fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![创建博客默认内容](https://img-blog.csdnimg.cn/ec5e8acbb2264485b4a4494ec9cb5fc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t这里需要看一下最后一步 **发布** 过程，第一次如果发布失败，可能需要安装插件 `hexo-deployer-git` ：\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n​\t然后确认下 `_config.yml` 中git配置是否正确：\n\n```yaml\ndeploy:\n  type: git\n  repo: <repository url> #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch: [branch] 默认maste\n```\n\n​\t以上配置之后，在使用 `hexo d` 命令发布，等待几分钟，在 *您的账号.github.io* 中便可以看到内容。\n\n​\t**注意：因为发布过程是直接覆盖github内容，所以在写博客之前，先将github内容拉到本地，然后在发布！！！**\n\n\n## 5、总结\n\n​\t综合以上内容，安装nodejs、npm、hexo，再有一个github账号，我们就可以免费拥有一个自己的博客系统啦～其实搭建的过程中还是会遇到很多困难，但是跟着看文档就都可以解决掉。而且 `hexo` 和 `hexo-theme-melody` 文档都支持中文，更方便了，赶紧搞起～\n\n\n\n**参考：**\n\n1. [https://hexo.io/zh-cn/docs](https://hexo.io/zh-cn/docs)\n2. [https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)\n3. [https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html)\n4. [https://dmaker1993.github.io/](https://dmaker1993.github.io/)\n\n---\n\n欢迎浏览我的更多文章：[一名不愿透露姓名的程序员](https://dmaker1993.github.io/) 或者  [https://dmaker1993.github.io](https://dmaker1993.github.io)\n\n最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～","source":"_posts/使用Github和Hexo搭建个人博客系统.md","raw":"---\ntitle: 使用Github和Hexo搭建个人博客系统\ntop: false\ndate: 2021-12-27 11:20:19\ntags:\n    - 博客系统\n    - 经验\ncategories:\n    - 经验分享\n---\n# 利用Github和Hexo搭建个人博客\n\n作为一名开发人员，写技术博客既是一种对知识的巩固，也是一种分享精神。所以有一个自己的技术博客，对于我们技术人员来说，是很nice的一件事。\n\n## 1、条件\n\n​\t如果要使用github搭建自己的博客系统，需要有一个 *Github账号* ，我们可以注册一个账号。其次需要一个 *node开发环境（nodejs、npm）*，因为 *Hexo* 框架需要使用node环境搭建。\n\n- github账号\n- node、npm环境（省略）\n- 本地安装了git（省略）\n\n本次我的实验环境：\n\n- MacBook Air m1芯片\n- git 2.33.1\n- node v16.13.1\n- npm 8.1.2\n\n## 2、注册github账号\n\n​\t相信如果是程序员同学，那一定已经拥有一个自己的github账号了，如果是已经拥有github账号的伙伴们可以直接看 *2.2小节* 。\n\n### 2.1 注册账号\n\n​\tgithub注册账号还是比较简单的，需要一个邮箱就行。但是国内访问会比较慢，所以耐心一点就行，这里略过。\n\n### 2.2 创建项目\n\n​\t创建项目需要注意的地方是仓库的名字，命名为 *你的账号.github.io*  ，之后个人博客访问的域名就是 *https://你的账号.github.io* 。\n\n![创建github项目](https://img-blog.csdnimg.cn/9e3a87a1040a47038bcf0676a4c1d69c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n> 这里我已经创建过，所以提示已经存在。\n\n​\t项目创建好之后，需要本地把我们的项目拉下来，因为博客内容一般都是在本地写好在上传到github的，而且本地还可以启动服务预览博客，以便我们在正式发布之前，调整内容和样式。这里我们使用 `git` 协议去拉取仓库，就需要配置 `ssh key` ，因为直接使用账号密码不太安全，相关账号密码需要配置在配置文件。\n\n### 2.3 配置ssh key\n\n​\t首先连接过的ssh key会在  `~/.ssh` 目录下有 *xxx.pub*文件，就是公钥。但是是首次连接的话，那么就需要配置一下了，如下：\n\n```bash\n# 1.查看.ssh文件夹，是否有配置过密钥\nls ~/.ssh\n# 2.如果不存在密钥，则需要创建，如下命令直接三个回车就可以\nssh-keygen -t rsa-C \"邮箱地址\"\n# 3.执行完以上步骤之后，会生成两个文件\nid_rsa 和 id_rsa.pub\n# 4.使用vim打开id_ras.pub，复制内容到github的公钥配置中\n# 5.测试是否已经连通\nssh -T git@github.com\n看到结果如下则表示连通：Hi 用户名! You've successfully authenticated, but GitHub does not provide shell access.\n# 6.还需要配置下公共的用户名和邮箱\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱\"\n```\n\n### 2.4 设置gitbhu pages\n\n​\t找到项目的 `Settings -> Pages -> Source  ` ，设置branch和root。\n\n![设置Github Pages](https://img-blog.csdnimg.cn/7282fbfc184f4245997fc0367c5caf73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n## 3、搭建Hexo环境\n\n​\tHexo是一个快速、简介且高效的博客框架，官网：[https://hexo.io/zh-cn/](https://hexo.io/zh-cn/) ，可以在网站下学习他的API、文档、插件、主题等。\n\n### 3.1 搭建环境\n\n**注意：** 由于mac系统新版本对 `/usr/*` 做了权限限制，无法写入，所以我们需要修改下默认的npm全局依赖包的位置。\n\n```bash\n# 0.修改npm全局依赖仓库位置，并设置到环境变量\nmkdir ~/.npm-global\n# 1.将新位置加入到环境变量，在./bash_profile中加入以下内容\nexport PATH=~/.npm-global/bin:$PATH\n# 2.修改 .zshrc （因为我用的zsh），加入以下内容\nsource ~/.bash_profile\n```\n\n​\t接下来我们搭建hexo环境：\n\n```bash\n# 1.安装hexo-cli工具（全局）\nnpm install -g hexo-cli\n# 2.安装hexo（可局部安装，我就是安装在了我的博客项目中）\ncd ~/projects/dmaker1993@github.io\nnpm install hexo\n```\n\n### 3.2 初始化Hexo\n\n​\t我们要使用 `hexo` 命令初始化一个hexo博客写作环境，相当于是hexo的基本框架：\n\n```bash\n# 1.将项目拉到本地某个文件夹，我的是 /Users/adu/IdeaProjects/dmaker1993.github.io\ncd /Users/adu/IdeaProjects/\ngit clone git@dmaker1993@dmaker1993.github.io.git\n# 2.进入项目中，初始化hexo框架\ncd dmaker1993.github.io\nhexo init\n# 3.构建demo博客，生成静态文件\nhexo generate\n# 4.启动本地环境，查看demo\nhexo server\n# 5.访问localhost:4000\n```\n\n​\t初始化之后的目录结构如下：\n\n![hexo目录结构](https://img-blog.csdnimg.cn/b6f93034c3764ead8f64bf928ea85144.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n```tex\n.\n├── _config.yml # 网站的配置信息，可以配置网站的绝大部分信息\n├── package.json # 应用程序的信息，可以不关注\n├── scaffolds # 模版文件夹，我们在创建新文章时，可以指定某一个模板来生成新文章（.md文档）\n├── source # 存放用户资源文件的地方，同时这里也会存放我们的博客、标签、目录等内容，这里的.md和html文件会被编译到public文件夹\n|   ├── _drafts # 草稿文件\n|   └── _posts # 博客文件，这里的博客文件会被编译到public文件夹中\n└── themes # 主题文件夹，hexo会根据主题生成博客静态页面\n```\n\n#### 3.3 选择主题\n\n​\t经过 *[3.2步骤](#3.2)* 之后，我们就已经搭建好了一个hexo环境，然后就可以写博客了。但是默认的信息比如 *博客名称*、*所有者* 等等信息，需要都替换成我们自己的，也就是做一些配置的修改，我们直接修改项目根目录下的 `_config.yml` 文件, 以下是一些hexo配置信息的修改：\n\n```yaml\ntitle: 网站标题\nsubtitle: 网站副标题\ndescription: 网站描述\nkeywords: 网站的关键词。支持多个关键词\nauthor: 作者姓名\nlanguage: 语言，对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。\ntimezone: 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。\nurl: 网址, 必须以 http:// 或 https:// 开头\ntheme: 主题，这个是关键，我们可以在网上找一些好看主题\ndeploy:\n  type: git\n  repo: 仓库地址\n  branch: 分支，一般是master\n```\n\n​\t上述的 `theme` 就是主题的名字，我们可以到hexo官方提供的列表中选择一个自己喜欢的：[https://hexo.io/themes/](https://hexo.io/themes/)。我用的是 *[hexo-theme-melody](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/)* 这个主题，他的文档也比较全，下面是一些展示：\n\n![dmaker1993博客首页](https://img-blog.csdnimg.cn/5b038cb8bc9b4fe9b99cfcba1e9bef77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![damper993博客内容详情页](https://img-blog.csdnimg.cn/bc1d723e296d4913b5c0e0ab625d9b9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t更多的可以去看看我的博客：[https://dmaker1993.github.io/](https://dmaker1993.github.io/) 。\n\n#### 3.4 主题下载和配置\n\n​\t在搭建的过程中也是直接看的文档，比较简单，如果有什么问题可以给我留言哦。首先下载主题，因为我下载的hexo是最新的，所以我直接使用npm安装。\n\n1）主题下载\n\n```bash\nnpm install hexo-theme-melody\n```\n\n​\t下载之后，我们就可以在 `node_modules` 目录下找到这个主题的依赖：\n\n![hexo主题目录结构](https://img-blog.csdnimg.cn/04df98ca7c494ea28618cf314d0633ab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n\n2）设置主题\n\n​\t找到项目跟目录下的 `_config.yml` ，修改其中的 `theme` 值为 `melody`。\n\n```yaml\ntheme: melody # 将主题设置成melody\n```\n\n3）配置\n\n​\t先安装两个渲染插件：\n\n```bash\nnpm install hexo-renderer-pug hexo-renderer-stylus --save\n```\n\n​\t然后将 `node_modules/hexo-theme-melody/_config.yml` 文件复制到项目根目录下，并改名为 `_config.melody.yml` ，修改其中的一些配置信息，比如我的配置（`_config.melody.yml`）是这样的：\n\n```yaml\n# 配置语言的\nlanguage: zh-Hans\n# 配置菜单的（ ':'之前的是展示的名字，之后的是博客中关联的）\nmenu:\n  首页: /\n  归档: /archives\n  标签: /tags\n  分类: /categories\n  #XXX: /xxx\n# 社交信息，可以挂一写自己的github，微博什么的\nsocial:\n#icon_name fa: url\n#icon_name fab: url\n  github fa: https://github.com/Dmaker1993\n  weibo fa: https://blog.csdn.net/DMaker1993\n# footer设置\nsince: 2021\n```\n\n全部的主题配置在这里：[https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html) 。\n\n4）测试\n\n​\t都配置好之后，我们就可以看一下效果了，执行如下命令：\n\n```bash\n# 清理\nhexo clear\n# 构建。hexo generate 简写为：hexo g\nhexo g\n# 启动服务。hexo server 简写：hexo s\nhexo s\n```\n\n​\t正常是一片 *Hello World* 的demo文章，这里我们就都配置好了，下面我们就可以开始写博客了。\n\n## 4、写博客\n\n​\t这个过程大概就是：生成博客文档、填充博客内容、构建博客页面、发布。等待几分钟之后，我们在自己的 *github.io* 页面中就能够看到了。下面我们看一下具体步骤：\n\n```bash\n# 1.生成博客文档，主要是生成一些hexo必要的配置\nhexo new [layout] \"博客名称\" \n\t## 这个命令会生成 ./source/_posts/博客名称.md 文档\n\t## layout表示模板名称，默认使用post，在./scaffolds中可以看到所有的模版\n# 2.写博客，我一般会用 typora 写mk文档\n# 3.将写好的mk文档复制到刚才生成的文档中，注意不要覆盖掉之前的配置，比如 title、categories等\n# 4.构建\nhexo g\n# 5.本地预览\nhexo s\n# 6.发布，就是将本地的代码上传到github，这个过程是完全覆盖现在github上的内容的，所以一定要先拉下来。\nhexo d\n```\n\n![创建新博客](https://img-blog.csdnimg.cn/bb8da1e5e6f94dadbab5387fc9b75758.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![创建结果](https://img-blog.csdnimg.cn/57fd27ae974643b49be6155b4e4bc5fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n![创建博客默认内容](https://img-blog.csdnimg.cn/ec5e8acbb2264485b4a4494ec9cb5fc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n\n​\t这里需要看一下最后一步 **发布** 过程，第一次如果发布失败，可能需要安装插件 `hexo-deployer-git` ：\n\n```bash\nnpm install hexo-deployer-git --save\n```\n\n​\t然后确认下 `_config.yml` 中git配置是否正确：\n\n```yaml\ndeploy:\n  type: git\n  repo: <repository url> #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io\n  branch: [branch] 默认maste\n```\n\n​\t以上配置之后，在使用 `hexo d` 命令发布，等待几分钟，在 *您的账号.github.io* 中便可以看到内容。\n\n​\t**注意：因为发布过程是直接覆盖github内容，所以在写博客之前，先将github内容拉到本地，然后在发布！！！**\n\n\n## 5、总结\n\n​\t综合以上内容，安装nodejs、npm、hexo，再有一个github账号，我们就可以免费拥有一个自己的博客系统啦～其实搭建的过程中还是会遇到很多困难，但是跟着看文档就都可以解决掉。而且 `hexo` 和 `hexo-theme-melody` 文档都支持中文，更方便了，赶紧搞起～\n\n\n\n**参考：**\n\n1. [https://hexo.io/zh-cn/docs](https://hexo.io/zh-cn/docs)\n2. [https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)\n3. [https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html](https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html)\n4. [https://dmaker1993.github.io/](https://dmaker1993.github.io/)\n\n---\n\n欢迎浏览我的更多文章：[一名不愿透露姓名的程序员](https://dmaker1993.github.io/) 或者  [https://dmaker1993.github.io](https://dmaker1993.github.io)\n\n最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～","slug":"使用Github和Hexo搭建个人博客系统","published":1,"updated":"2021-12-27T06:16:39.875Z","_id":"ckxo72x9o000083s6c1si9iui","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"利用Github和Hexo搭建个人博客\"><a href=\"#利用Github和Hexo搭建个人博客\" class=\"headerlink\" title=\"利用Github和Hexo搭建个人博客\"></a>利用Github和Hexo搭建个人博客</h1><p>作为一名开发人员，写技术博客既是一种对知识的巩固，也是一种分享精神。所以有一个自己的技术博客，对于我们技术人员来说，是很nice的一件事。</p>\n<h2 id=\"1、条件\"><a href=\"#1、条件\" class=\"headerlink\" title=\"1、条件\"></a>1、条件</h2><p>​    如果要使用github搭建自己的博客系统，需要有一个 <em>Github账号</em> ，我们可以注册一个账号。其次需要一个 <em>node开发环境（nodejs、npm）</em>，因为 <em>Hexo</em> 框架需要使用node环境搭建。</p>\n<ul>\n<li>github账号</li>\n<li>node、npm环境（省略）</li>\n<li>本地安装了git（省略）</li>\n</ul>\n<p>本次我的实验环境：</p>\n<ul>\n<li>MacBook Air m1芯片</li>\n<li>git 2.33.1</li>\n<li>node v16.13.1</li>\n<li>npm 8.1.2</li>\n</ul>\n<h2 id=\"2、注册github账号\"><a href=\"#2、注册github账号\" class=\"headerlink\" title=\"2、注册github账号\"></a>2、注册github账号</h2><p>​    相信如果是程序员同学，那一定已经拥有一个自己的github账号了，如果是已经拥有github账号的伙伴们可以直接看 <em>2.2小节</em> 。</p>\n<h3 id=\"2-1-注册账号\"><a href=\"#2-1-注册账号\" class=\"headerlink\" title=\"2.1 注册账号\"></a>2.1 注册账号</h3><p>​    github注册账号还是比较简单的，需要一个邮箱就行。但是国内访问会比较慢，所以耐心一点就行，这里略过。</p>\n<h3 id=\"2-2-创建项目\"><a href=\"#2-2-创建项目\" class=\"headerlink\" title=\"2.2 创建项目\"></a>2.2 创建项目</h3><p>​    创建项目需要注意的地方是仓库的名字，命名为 <em>你的账号.github.io</em>  ，之后个人博客访问的域名就是 <em>https://你的账号.github.io</em> 。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9e3a87a1040a47038bcf0676a4c1d69c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建github项目\"></p>\n<blockquote>\n<p>这里我已经创建过，所以提示已经存在。</p>\n</blockquote>\n<p>​    项目创建好之后，需要本地把我们的项目拉下来，因为博客内容一般都是在本地写好在上传到github的，而且本地还可以启动服务预览博客，以便我们在正式发布之前，调整内容和样式。这里我们使用 <code>git</code> 协议去拉取仓库，就需要配置 <code>ssh key</code> ，因为直接使用账号密码不太安全，相关账号密码需要配置在配置文件。</p>\n<h3 id=\"2-3-配置ssh-key\"><a href=\"#2-3-配置ssh-key\" class=\"headerlink\" title=\"2.3 配置ssh key\"></a>2.3 配置ssh key</h3><p>​    首先连接过的ssh key会在  <code>~/.ssh</code> 目录下有 <em>xxx.pub</em>文件，就是公钥。但是是首次连接的话，那么就需要配置一下了，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.查看.ssh文件夹，是否有配置过密钥</span></span><br><span class=\"line\">ls ~/.ssh</span><br><span class=\"line\"><span class=\"comment\"># 2.如果不存在密钥，则需要创建，如下命令直接三个回车就可以</span></span><br><span class=\"line\">ssh-keygen -t rsa-C <span class=\"string\">&quot;邮箱地址&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 3.执行完以上步骤之后，会生成两个文件</span></span><br><span class=\"line\">id_rsa 和 id_rsa.pub</span><br><span class=\"line\"><span class=\"comment\"># 4.使用vim打开id_ras.pub，复制内容到github的公钥配置中</span></span><br><span class=\"line\"><span class=\"comment\"># 5.测试是否已经连通</span></span><br><span class=\"line\">ssh -T git@github.com</span><br><span class=\"line\">看到结果如下则表示连通：Hi 用户名! You<span class=\"string\">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class=\"line\"><span class=\"string\"># 6.还需要配置下公共的用户名和邮箱</span></span><br><span class=\"line\"><span class=\"string\">git config --global user.name &quot;你的用户名&quot;</span></span><br><span class=\"line\"><span class=\"string\">git config --global user.email &quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-设置gitbhu-pages\"><a href=\"#2-4-设置gitbhu-pages\" class=\"headerlink\" title=\"2.4 设置gitbhu pages\"></a>2.4 设置gitbhu pages</h3><p>​    找到项目的 <code>Settings -&gt; Pages -&gt; Source  </code> ，设置branch和root。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7282fbfc184f4245997fc0367c5caf73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"设置Github Pages\"></p>\n<h2 id=\"3、搭建Hexo环境\"><a href=\"#3、搭建Hexo环境\" class=\"headerlink\" title=\"3、搭建Hexo环境\"></a>3、搭建Hexo环境</h2><p>​    Hexo是一个快速、简介且高效的博客框架，官网：<a href=\"https://hexo.io/zh-cn/\">https://hexo.io/zh-cn/</a> ，可以在网站下学习他的API、文档、插件、主题等。</p>\n<h3 id=\"3-1-搭建环境\"><a href=\"#3-1-搭建环境\" class=\"headerlink\" title=\"3.1 搭建环境\"></a>3.1 搭建环境</h3><p><strong>注意：</strong> 由于mac系统新版本对 <code>/usr/*</code> 做了权限限制，无法写入，所以我们需要修改下默认的npm全局依赖包的位置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 0.修改npm全局依赖仓库位置，并设置到环境变量</span></span><br><span class=\"line\">mkdir ~/.npm-global</span><br><span class=\"line\"><span class=\"comment\"># 1.将新位置加入到环境变量，在./bash_profile中加入以下内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=~/.npm-global/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"comment\"># 2.修改 .zshrc （因为我用的zsh），加入以下内容</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>​    接下来我们搭建hexo环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.安装hexo-cli工具（全局）</span></span><br><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"><span class=\"comment\"># 2.安装hexo（可局部安装，我就是安装在了我的博客项目中）</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/projects/dmaker1993@github.io</span><br><span class=\"line\">npm install hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-初始化Hexo\"><a href=\"#3-2-初始化Hexo\" class=\"headerlink\" title=\"3.2 初始化Hexo\"></a>3.2 初始化Hexo</h3><p>​    我们要使用 <code>hexo</code> 命令初始化一个hexo博客写作环境，相当于是hexo的基本框架：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.将项目拉到本地某个文件夹，我的是 /Users/adu/IdeaProjects/dmaker1993.github.io</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /Users/adu/IdeaProjects/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@dmaker1993@dmaker1993.github.io.git</span><br><span class=\"line\"><span class=\"comment\"># 2.进入项目中，初始化hexo框架</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> dmaker1993.github.io</span><br><span class=\"line\">hexo init</span><br><span class=\"line\"><span class=\"comment\"># 3.构建demo博客，生成静态文件</span></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"><span class=\"comment\"># 4.启动本地环境，查看demo</span></span><br><span class=\"line\">hexo server</span><br><span class=\"line\"><span class=\"comment\"># 5.访问localhost:4000</span></span><br></pre></td></tr></table></figure>\n\n<p>​    初始化之后的目录结构如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b6f93034c3764ead8f64bf928ea85144.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"hexo目录结构\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── <span class=\"built_in\">_</span>config.yml <span class=\"params\">#</span> 网站的配置信息，可以配置网站的绝大部分信息</span><br><span class=\"line\">├── package.json <span class=\"params\">#</span> 应用程序的信息，可以不关注</span><br><span class=\"line\">├── scaffolds <span class=\"params\">#</span> 模版文件夹，我们在创建新文章时，可以指定某一个模板来生成新文章（.md文档）</span><br><span class=\"line\">├── source <span class=\"params\">#</span> 存放用户资源文件的地方，同时这里也会存放我们的博客、标签、目录等内容，这里的.md和html文件会被编译到public文件夹</span><br><span class=\"line\">|   ├── <span class=\"built_in\">_</span>drafts <span class=\"params\">#</span> 草稿文件</span><br><span class=\"line\">|   └── <span class=\"built_in\">_</span>posts <span class=\"params\">#</span> 博客文件，这里的博客文件会被编译到public文件夹中</span><br><span class=\"line\">└── themes <span class=\"params\">#</span> 主题文件夹，hexo会根据主题生成博客静态页面</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-选择主题\"><a href=\"#3-3-选择主题\" class=\"headerlink\" title=\"3.3 选择主题\"></a>3.3 选择主题</h4><p>​    经过 <em><a href=\"#3.2\">3.2步骤</a></em> 之后，我们就已经搭建好了一个hexo环境，然后就可以写博客了。但是默认的信息比如 <em>博客名称</em>、<em>所有者</em> 等等信息，需要都替换成我们自己的，也就是做一些配置的修改，我们直接修改项目根目录下的 <code>_config.yml</code> 文件, 以下是一些hexo配置信息的修改：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">网站标题</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">网站副标题</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">网站描述</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">网站的关键词。支持多个关键词</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">作者姓名</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">语言，对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有</span> <span class=\"string\">zh-Hans和</span> <span class=\"string\">zh-CN。</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">网站时区。Hexo</span> <span class=\"string\">默认使用您电脑的时区。请参考</span> <span class=\"string\">时区列表</span> <span class=\"string\">进行设置，如</span> <span class=\"string\">America/New_York,</span> <span class=\"string\">Japan,</span> <span class=\"string\">和</span> <span class=\"string\">UTC</span> <span class=\"string\">。一般的，对于中国大陆地区可以使用</span> <span class=\"string\">Asia/Shanghai。</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">网址,</span> <span class=\"string\">必须以</span> <span class=\"string\">http://</span> <span class=\"string\">或</span> <span class=\"string\">https://</span> <span class=\"string\">开头</span></span><br><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">主题，这个是关键，我们可以在网上找一些好看主题</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">分支，一般是master</span></span><br></pre></td></tr></table></figure>\n\n<p>​    上述的 <code>theme</code> 就是主题的名字，我们可以到hexo官方提供的列表中选择一个自己喜欢的：<a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a>。我用的是 <em><a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/\">hexo-theme-melody</a></em> 这个主题，他的文档也比较全，下面是一些展示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5b038cb8bc9b4fe9b99cfcba1e9bef77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"dmaker1993博客首页\"><br><img src=\"https://img-blog.csdnimg.cn/bc1d723e296d4913b5c0e0ab625d9b9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"damper993博客内容详情页\"></p>\n<p>​    更多的可以去看看我的博客：<a href=\"https://dmaker1993.github.io/\">https://dmaker1993.github.io/</a> 。</p>\n<h4 id=\"3-4-主题下载和配置\"><a href=\"#3-4-主题下载和配置\" class=\"headerlink\" title=\"3.4 主题下载和配置\"></a>3.4 主题下载和配置</h4><p>​    在搭建的过程中也是直接看的文档，比较简单，如果有什么问题可以给我留言哦。首先下载主题，因为我下载的hexo是最新的，所以我直接使用npm安装。</p>\n<p>1）主题下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-theme-melody</span><br></pre></td></tr></table></figure>\n\n<p>​    下载之后，我们就可以在 <code>node_modules</code> 目录下找到这个主题的依赖：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/04df98ca7c494ea28618cf314d0633ab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"hexo主题目录结构\"></p>\n<p>2）设置主题</p>\n<p>​    找到项目跟目录下的 <code>_config.yml</code> ，修改其中的 <code>theme</code> 值为 <code>melody</code>。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">melody</span> <span class=\"comment\"># 将主题设置成melody</span></span><br></pre></td></tr></table></figure>\n\n<p>3）配置</p>\n<p>​    先安装两个渲染插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<p>​    然后将 <code>node_modules/hexo-theme-melody/_config.yml</code> 文件复制到项目根目录下，并改名为 <code>_config.melody.yml</code> ，修改其中的一些配置信息，比如我的配置（<code>_config.melody.yml</code>）是这样的：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置语言的</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-Hans</span></span><br><span class=\"line\"><span class=\"comment\"># 配置菜单的（ &#x27;:&#x27;之前的是展示的名字，之后的是博客中关联的）</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"string\">首页:</span> <span class=\"string\">/</span></span><br><span class=\"line\">  <span class=\"string\">归档:</span> <span class=\"string\">/archives</span></span><br><span class=\"line\">  <span class=\"string\">标签:</span> <span class=\"string\">/tags</span></span><br><span class=\"line\">  <span class=\"string\">分类:</span> <span class=\"string\">/categories</span></span><br><span class=\"line\">  <span class=\"comment\">#<span class=\"doctag\">XXX:</span> /xxx</span></span><br><span class=\"line\"><span class=\"comment\"># 社交信息，可以挂一写自己的github，微博什么的</span></span><br><span class=\"line\"><span class=\"attr\">social:</span></span><br><span class=\"line\"><span class=\"comment\">#icon_name fa: url</span></span><br><span class=\"line\"><span class=\"comment\">#icon_name fab: url</span></span><br><span class=\"line\">  <span class=\"attr\">github fa:</span> <span class=\"string\">https://github.com/Dmaker1993</span></span><br><span class=\"line\">  <span class=\"attr\">weibo fa:</span> <span class=\"string\">https://blog.csdn.net/DMaker1993</span></span><br><span class=\"line\"><span class=\"comment\"># footer设置</span></span><br><span class=\"line\"><span class=\"attr\">since:</span> <span class=\"number\">2021</span></span><br></pre></td></tr></table></figure>\n\n<p>全部的主题配置在这里：<a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html\">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html</a> 。</p>\n<p>4）测试</p>\n<p>​    都配置好之后，我们就可以看一下效果了，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理</span></span><br><span class=\"line\">hexo clear</span><br><span class=\"line\"><span class=\"comment\"># 构建。hexo generate 简写为：hexo g</span></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"><span class=\"comment\"># 启动服务。hexo server 简写：hexo s</span></span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>​    正常是一片 <em>Hello World</em> 的demo文章，这里我们就都配置好了，下面我们就可以开始写博客了。</p>\n<h2 id=\"4、写博客\"><a href=\"#4、写博客\" class=\"headerlink\" title=\"4、写博客\"></a>4、写博客</h2><p>​    这个过程大概就是：生成博客文档、填充博客内容、构建博客页面、发布。等待几分钟之后，我们在自己的 <em>github.io</em> 页面中就能够看到了。下面我们看一下具体步骤：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.生成博客文档，主要是生成一些hexo必要的配置</span></span><br><span class=\"line\">hexo new [layout] <span class=\"string\">&quot;博客名称&quot;</span> </span><br><span class=\"line\">\t<span class=\"comment\">## 这个命令会生成 ./source/_posts/博客名称.md 文档</span></span><br><span class=\"line\">\t<span class=\"comment\">## layout表示模板名称，默认使用post，在./scaffolds中可以看到所有的模版</span></span><br><span class=\"line\"><span class=\"comment\"># 2.写博客，我一般会用 typora 写mk文档</span></span><br><span class=\"line\"><span class=\"comment\"># 3.将写好的mk文档复制到刚才生成的文档中，注意不要覆盖掉之前的配置，比如 title、categories等</span></span><br><span class=\"line\"><span class=\"comment\"># 4.构建</span></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"><span class=\"comment\"># 5.本地预览</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 6.发布，就是将本地的代码上传到github，这个过程是完全覆盖现在github上的内容的，所以一定要先拉下来。</span></span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/bb8da1e5e6f94dadbab5387fc9b75758.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建新博客\"><br><img src=\"https://img-blog.csdnimg.cn/57fd27ae974643b49be6155b4e4bc5fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建结果\"><br><img src=\"https://img-blog.csdnimg.cn/ec5e8acbb2264485b4a4494ec9cb5fc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建博客默认内容\"></p>\n<p>​    这里需要看一下最后一步 <strong>发布</strong> 过程，第一次如果发布失败，可能需要安装插件 <code>hexo-deployer-git</code> ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>​    然后确认下 <code>_config.yml</code> 中git配置是否正确：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">&lt;repository</span> <span class=\"string\">url&gt;</span> <span class=\"comment\">#https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> [<span class=\"string\">branch</span>] <span class=\"string\">默认maste</span></span><br></pre></td></tr></table></figure>\n\n<p>​    以上配置之后，在使用 <code>hexo d</code> 命令发布，等待几分钟，在 <em>您的账号.github.io</em> 中便可以看到内容。</p>\n<p>​    <strong>注意：因为发布过程是直接覆盖github内容，所以在写博客之前，先将github内容拉到本地，然后在发布！！！</strong></p>\n<h2 id=\"5、总结\"><a href=\"#5、总结\" class=\"headerlink\" title=\"5、总结\"></a>5、总结</h2><p>​    综合以上内容，安装nodejs、npm、hexo，再有一个github账号，我们就可以免费拥有一个自己的博客系统啦～其实搭建的过程中还是会遇到很多困难，但是跟着看文档就都可以解决掉。而且 <code>hexo</code> 和 <code>hexo-theme-melody</code> 文档都支持中文，更方便了，赶紧搞起～</p>\n<p><strong>参考：</strong></p>\n<ol>\n<li><a href=\"https://hexo.io/zh-cn/docs\">https://hexo.io/zh-cn/docs</a></li>\n<li><a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></li>\n<li><a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html\">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html</a></li>\n<li><a href=\"https://dmaker1993.github.io/\">https://dmaker1993.github.io/</a></li>\n</ol>\n<hr>\n<p>欢迎浏览我的更多文章：<a href=\"https://dmaker1993.github.io/\">一名不愿透露姓名的程序员</a> 或者  <a href=\"https://dmaker1993.github.io/\">https://dmaker1993.github.io</a></p>\n<p>最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"利用Github和Hexo搭建个人博客\"><a href=\"#利用Github和Hexo搭建个人博客\" class=\"headerlink\" title=\"利用Github和Hexo搭建个人博客\"></a>利用Github和Hexo搭建个人博客</h1><p>作为一名开发人员，写技术博客既是一种对知识的巩固，也是一种分享精神。所以有一个自己的技术博客，对于我们技术人员来说，是很nice的一件事。</p>\n<h2 id=\"1、条件\"><a href=\"#1、条件\" class=\"headerlink\" title=\"1、条件\"></a>1、条件</h2><p>​    如果要使用github搭建自己的博客系统，需要有一个 <em>Github账号</em> ，我们可以注册一个账号。其次需要一个 <em>node开发环境（nodejs、npm）</em>，因为 <em>Hexo</em> 框架需要使用node环境搭建。</p>\n<ul>\n<li>github账号</li>\n<li>node、npm环境（省略）</li>\n<li>本地安装了git（省略）</li>\n</ul>\n<p>本次我的实验环境：</p>\n<ul>\n<li>MacBook Air m1芯片</li>\n<li>git 2.33.1</li>\n<li>node v16.13.1</li>\n<li>npm 8.1.2</li>\n</ul>\n<h2 id=\"2、注册github账号\"><a href=\"#2、注册github账号\" class=\"headerlink\" title=\"2、注册github账号\"></a>2、注册github账号</h2><p>​    相信如果是程序员同学，那一定已经拥有一个自己的github账号了，如果是已经拥有github账号的伙伴们可以直接看 <em>2.2小节</em> 。</p>\n<h3 id=\"2-1-注册账号\"><a href=\"#2-1-注册账号\" class=\"headerlink\" title=\"2.1 注册账号\"></a>2.1 注册账号</h3><p>​    github注册账号还是比较简单的，需要一个邮箱就行。但是国内访问会比较慢，所以耐心一点就行，这里略过。</p>\n<h3 id=\"2-2-创建项目\"><a href=\"#2-2-创建项目\" class=\"headerlink\" title=\"2.2 创建项目\"></a>2.2 创建项目</h3><p>​    创建项目需要注意的地方是仓库的名字，命名为 <em>你的账号.github.io</em>  ，之后个人博客访问的域名就是 <em>https://你的账号.github.io</em> 。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9e3a87a1040a47038bcf0676a4c1d69c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建github项目\"></p>\n<blockquote>\n<p>这里我已经创建过，所以提示已经存在。</p>\n</blockquote>\n<p>​    项目创建好之后，需要本地把我们的项目拉下来，因为博客内容一般都是在本地写好在上传到github的，而且本地还可以启动服务预览博客，以便我们在正式发布之前，调整内容和样式。这里我们使用 <code>git</code> 协议去拉取仓库，就需要配置 <code>ssh key</code> ，因为直接使用账号密码不太安全，相关账号密码需要配置在配置文件。</p>\n<h3 id=\"2-3-配置ssh-key\"><a href=\"#2-3-配置ssh-key\" class=\"headerlink\" title=\"2.3 配置ssh key\"></a>2.3 配置ssh key</h3><p>​    首先连接过的ssh key会在  <code>~/.ssh</code> 目录下有 <em>xxx.pub</em>文件，就是公钥。但是是首次连接的话，那么就需要配置一下了，如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.查看.ssh文件夹，是否有配置过密钥</span></span><br><span class=\"line\">ls ~/.ssh</span><br><span class=\"line\"><span class=\"comment\"># 2.如果不存在密钥，则需要创建，如下命令直接三个回车就可以</span></span><br><span class=\"line\">ssh-keygen -t rsa-C <span class=\"string\">&quot;邮箱地址&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 3.执行完以上步骤之后，会生成两个文件</span></span><br><span class=\"line\">id_rsa 和 id_rsa.pub</span><br><span class=\"line\"><span class=\"comment\"># 4.使用vim打开id_ras.pub，复制内容到github的公钥配置中</span></span><br><span class=\"line\"><span class=\"comment\"># 5.测试是否已经连通</span></span><br><span class=\"line\">ssh -T git@github.com</span><br><span class=\"line\">看到结果如下则表示连通：Hi 用户名! You<span class=\"string\">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class=\"line\"><span class=\"string\"># 6.还需要配置下公共的用户名和邮箱</span></span><br><span class=\"line\"><span class=\"string\">git config --global user.name &quot;你的用户名&quot;</span></span><br><span class=\"line\"><span class=\"string\">git config --global user.email &quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-设置gitbhu-pages\"><a href=\"#2-4-设置gitbhu-pages\" class=\"headerlink\" title=\"2.4 设置gitbhu pages\"></a>2.4 设置gitbhu pages</h3><p>​    找到项目的 <code>Settings -&gt; Pages -&gt; Source  </code> ，设置branch和root。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7282fbfc184f4245997fc0367c5caf73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"设置Github Pages\"></p>\n<h2 id=\"3、搭建Hexo环境\"><a href=\"#3、搭建Hexo环境\" class=\"headerlink\" title=\"3、搭建Hexo环境\"></a>3、搭建Hexo环境</h2><p>​    Hexo是一个快速、简介且高效的博客框架，官网：<a href=\"https://hexo.io/zh-cn/\">https://hexo.io/zh-cn/</a> ，可以在网站下学习他的API、文档、插件、主题等。</p>\n<h3 id=\"3-1-搭建环境\"><a href=\"#3-1-搭建环境\" class=\"headerlink\" title=\"3.1 搭建环境\"></a>3.1 搭建环境</h3><p><strong>注意：</strong> 由于mac系统新版本对 <code>/usr/*</code> 做了权限限制，无法写入，所以我们需要修改下默认的npm全局依赖包的位置。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 0.修改npm全局依赖仓库位置，并设置到环境变量</span></span><br><span class=\"line\">mkdir ~/.npm-global</span><br><span class=\"line\"><span class=\"comment\"># 1.将新位置加入到环境变量，在./bash_profile中加入以下内容</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=~/.npm-global/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"comment\"># 2.修改 .zshrc （因为我用的zsh），加入以下内容</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>\n\n<p>​    接下来我们搭建hexo环境：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.安装hexo-cli工具（全局）</span></span><br><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\"><span class=\"comment\"># 2.安装hexo（可局部安装，我就是安装在了我的博客项目中）</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> ~/projects/dmaker1993@github.io</span><br><span class=\"line\">npm install hexo</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-初始化Hexo\"><a href=\"#3-2-初始化Hexo\" class=\"headerlink\" title=\"3.2 初始化Hexo\"></a>3.2 初始化Hexo</h3><p>​    我们要使用 <code>hexo</code> 命令初始化一个hexo博客写作环境，相当于是hexo的基本框架：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.将项目拉到本地某个文件夹，我的是 /Users/adu/IdeaProjects/dmaker1993.github.io</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> /Users/adu/IdeaProjects/</span><br><span class=\"line\">git <span class=\"built_in\">clone</span> git@dmaker1993@dmaker1993.github.io.git</span><br><span class=\"line\"><span class=\"comment\"># 2.进入项目中，初始化hexo框架</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> dmaker1993.github.io</span><br><span class=\"line\">hexo init</span><br><span class=\"line\"><span class=\"comment\"># 3.构建demo博客，生成静态文件</span></span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"><span class=\"comment\"># 4.启动本地环境，查看demo</span></span><br><span class=\"line\">hexo server</span><br><span class=\"line\"><span class=\"comment\"># 5.访问localhost:4000</span></span><br></pre></td></tr></table></figure>\n\n<p>​    初始化之后的目录结构如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b6f93034c3764ead8f64bf928ea85144.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"hexo目录结构\"></p>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── <span class=\"built_in\">_</span>config.yml <span class=\"params\">#</span> 网站的配置信息，可以配置网站的绝大部分信息</span><br><span class=\"line\">├── package.json <span class=\"params\">#</span> 应用程序的信息，可以不关注</span><br><span class=\"line\">├── scaffolds <span class=\"params\">#</span> 模版文件夹，我们在创建新文章时，可以指定某一个模板来生成新文章（.md文档）</span><br><span class=\"line\">├── source <span class=\"params\">#</span> 存放用户资源文件的地方，同时这里也会存放我们的博客、标签、目录等内容，这里的.md和html文件会被编译到public文件夹</span><br><span class=\"line\">|   ├── <span class=\"built_in\">_</span>drafts <span class=\"params\">#</span> 草稿文件</span><br><span class=\"line\">|   └── <span class=\"built_in\">_</span>posts <span class=\"params\">#</span> 博客文件，这里的博客文件会被编译到public文件夹中</span><br><span class=\"line\">└── themes <span class=\"params\">#</span> 主题文件夹，hexo会根据主题生成博客静态页面</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-3-选择主题\"><a href=\"#3-3-选择主题\" class=\"headerlink\" title=\"3.3 选择主题\"></a>3.3 选择主题</h4><p>​    经过 <em><a href=\"#3.2\">3.2步骤</a></em> 之后，我们就已经搭建好了一个hexo环境，然后就可以写博客了。但是默认的信息比如 <em>博客名称</em>、<em>所有者</em> 等等信息，需要都替换成我们自己的，也就是做一些配置的修改，我们直接修改项目根目录下的 <code>_config.yml</code> 文件, 以下是一些hexo配置信息的修改：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">title:</span> <span class=\"string\">网站标题</span></span><br><span class=\"line\"><span class=\"attr\">subtitle:</span> <span class=\"string\">网站副标题</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">网站描述</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span> <span class=\"string\">网站的关键词。支持多个关键词</span></span><br><span class=\"line\"><span class=\"attr\">author:</span> <span class=\"string\">作者姓名</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">语言，对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有</span> <span class=\"string\">zh-Hans和</span> <span class=\"string\">zh-CN。</span></span><br><span class=\"line\"><span class=\"attr\">timezone:</span> <span class=\"string\">网站时区。Hexo</span> <span class=\"string\">默认使用您电脑的时区。请参考</span> <span class=\"string\">时区列表</span> <span class=\"string\">进行设置，如</span> <span class=\"string\">America/New_York,</span> <span class=\"string\">Japan,</span> <span class=\"string\">和</span> <span class=\"string\">UTC</span> <span class=\"string\">。一般的，对于中国大陆地区可以使用</span> <span class=\"string\">Asia/Shanghai。</span></span><br><span class=\"line\"><span class=\"attr\">url:</span> <span class=\"string\">网址,</span> <span class=\"string\">必须以</span> <span class=\"string\">http://</span> <span class=\"string\">或</span> <span class=\"string\">https://</span> <span class=\"string\">开头</span></span><br><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">主题，这个是关键，我们可以在网上找一些好看主题</span></span><br><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">仓库地址</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> <span class=\"string\">分支，一般是master</span></span><br></pre></td></tr></table></figure>\n\n<p>​    上述的 <code>theme</code> 就是主题的名字，我们可以到hexo官方提供的列表中选择一个自己喜欢的：<a href=\"https://hexo.io/themes/\">https://hexo.io/themes/</a>。我用的是 <em><a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/\">hexo-theme-melody</a></em> 这个主题，他的文档也比较全，下面是一些展示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5b038cb8bc9b4fe9b99cfcba1e9bef77.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"dmaker1993博客首页\"><br><img src=\"https://img-blog.csdnimg.cn/bc1d723e296d4913b5c0e0ab625d9b9e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"damper993博客内容详情页\"></p>\n<p>​    更多的可以去看看我的博客：<a href=\"https://dmaker1993.github.io/\">https://dmaker1993.github.io/</a> 。</p>\n<h4 id=\"3-4-主题下载和配置\"><a href=\"#3-4-主题下载和配置\" class=\"headerlink\" title=\"3.4 主题下载和配置\"></a>3.4 主题下载和配置</h4><p>​    在搭建的过程中也是直接看的文档，比较简单，如果有什么问题可以给我留言哦。首先下载主题，因为我下载的hexo是最新的，所以我直接使用npm安装。</p>\n<p>1）主题下载</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-theme-melody</span><br></pre></td></tr></table></figure>\n\n<p>​    下载之后，我们就可以在 <code>node_modules</code> 目录下找到这个主题的依赖：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/04df98ca7c494ea28618cf314d0633ab.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"hexo主题目录结构\"></p>\n<p>2）设置主题</p>\n<p>​    找到项目跟目录下的 <code>_config.yml</code> ，修改其中的 <code>theme</code> 值为 <code>melody</code>。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">theme:</span> <span class=\"string\">melody</span> <span class=\"comment\"># 将主题设置成melody</span></span><br></pre></td></tr></table></figure>\n\n<p>3）配置</p>\n<p>​    先安装两个渲染插件：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>\n\n<p>​    然后将 <code>node_modules/hexo-theme-melody/_config.yml</code> 文件复制到项目根目录下，并改名为 <code>_config.melody.yml</code> ，修改其中的一些配置信息，比如我的配置（<code>_config.melody.yml</code>）是这样的：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 配置语言的</span></span><br><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-Hans</span></span><br><span class=\"line\"><span class=\"comment\"># 配置菜单的（ &#x27;:&#x27;之前的是展示的名字，之后的是博客中关联的）</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\">  <span class=\"string\">首页:</span> <span class=\"string\">/</span></span><br><span class=\"line\">  <span class=\"string\">归档:</span> <span class=\"string\">/archives</span></span><br><span class=\"line\">  <span class=\"string\">标签:</span> <span class=\"string\">/tags</span></span><br><span class=\"line\">  <span class=\"string\">分类:</span> <span class=\"string\">/categories</span></span><br><span class=\"line\">  <span class=\"comment\">#<span class=\"doctag\">XXX:</span> /xxx</span></span><br><span class=\"line\"><span class=\"comment\"># 社交信息，可以挂一写自己的github，微博什么的</span></span><br><span class=\"line\"><span class=\"attr\">social:</span></span><br><span class=\"line\"><span class=\"comment\">#icon_name fa: url</span></span><br><span class=\"line\"><span class=\"comment\">#icon_name fab: url</span></span><br><span class=\"line\">  <span class=\"attr\">github fa:</span> <span class=\"string\">https://github.com/Dmaker1993</span></span><br><span class=\"line\">  <span class=\"attr\">weibo fa:</span> <span class=\"string\">https://blog.csdn.net/DMaker1993</span></span><br><span class=\"line\"><span class=\"comment\"># footer设置</span></span><br><span class=\"line\"><span class=\"attr\">since:</span> <span class=\"number\">2021</span></span><br></pre></td></tr></table></figure>\n\n<p>全部的主题配置在这里：<a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html\">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/theme-config.html</a> 。</p>\n<p>4）测试</p>\n<p>​    都配置好之后，我们就可以看一下效果了，执行如下命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 清理</span></span><br><span class=\"line\">hexo clear</span><br><span class=\"line\"><span class=\"comment\"># 构建。hexo generate 简写为：hexo g</span></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"><span class=\"comment\"># 启动服务。hexo server 简写：hexo s</span></span><br><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure>\n\n<p>​    正常是一片 <em>Hello World</em> 的demo文章，这里我们就都配置好了，下面我们就可以开始写博客了。</p>\n<h2 id=\"4、写博客\"><a href=\"#4、写博客\" class=\"headerlink\" title=\"4、写博客\"></a>4、写博客</h2><p>​    这个过程大概就是：生成博客文档、填充博客内容、构建博客页面、发布。等待几分钟之后，我们在自己的 <em>github.io</em> 页面中就能够看到了。下面我们看一下具体步骤：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1.生成博客文档，主要是生成一些hexo必要的配置</span></span><br><span class=\"line\">hexo new [layout] <span class=\"string\">&quot;博客名称&quot;</span> </span><br><span class=\"line\">\t<span class=\"comment\">## 这个命令会生成 ./source/_posts/博客名称.md 文档</span></span><br><span class=\"line\">\t<span class=\"comment\">## layout表示模板名称，默认使用post，在./scaffolds中可以看到所有的模版</span></span><br><span class=\"line\"><span class=\"comment\"># 2.写博客，我一般会用 typora 写mk文档</span></span><br><span class=\"line\"><span class=\"comment\"># 3.将写好的mk文档复制到刚才生成的文档中，注意不要覆盖掉之前的配置，比如 title、categories等</span></span><br><span class=\"line\"><span class=\"comment\"># 4.构建</span></span><br><span class=\"line\">hexo g</span><br><span class=\"line\"><span class=\"comment\"># 5.本地预览</span></span><br><span class=\"line\">hexo s</span><br><span class=\"line\"><span class=\"comment\"># 6.发布，就是将本地的代码上传到github，这个过程是完全覆盖现在github上的内容的，所以一定要先拉下来。</span></span><br><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdnimg.cn/bb8da1e5e6f94dadbab5387fc9b75758.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建新博客\"><br><img src=\"https://img-blog.csdnimg.cn/57fd27ae974643b49be6155b4e4bc5fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建结果\"><br><img src=\"https://img-blog.csdnimg.cn/ec5e8acbb2264485b4a4494ec9cb5fc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARE1ha2VyMTk5Mw==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center\" alt=\"创建博客默认内容\"></p>\n<p>​    这里需要看一下最后一步 <strong>发布</strong> 过程，第一次如果发布失败，可能需要安装插件 <code>hexo-deployer-git</code> ：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>​    然后确认下 <code>_config.yml</code> 中git配置是否正确：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\">  <span class=\"attr\">type:</span> <span class=\"string\">git</span></span><br><span class=\"line\">  <span class=\"attr\">repo:</span> <span class=\"string\">&lt;repository</span> <span class=\"string\">url&gt;</span> <span class=\"comment\">#https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class=\"line\">  <span class=\"attr\">branch:</span> [<span class=\"string\">branch</span>] <span class=\"string\">默认maste</span></span><br></pre></td></tr></table></figure>\n\n<p>​    以上配置之后，在使用 <code>hexo d</code> 命令发布，等待几分钟，在 <em>您的账号.github.io</em> 中便可以看到内容。</p>\n<p>​    <strong>注意：因为发布过程是直接覆盖github内容，所以在写博客之前，先将github内容拉到本地，然后在发布！！！</strong></p>\n<h2 id=\"5、总结\"><a href=\"#5、总结\" class=\"headerlink\" title=\"5、总结\"></a>5、总结</h2><p>​    综合以上内容，安装nodejs、npm、hexo，再有一个github账号，我们就可以免费拥有一个自己的博客系统啦～其实搭建的过程中还是会遇到很多困难，但是跟着看文档就都可以解决掉。而且 <code>hexo</code> 和 <code>hexo-theme-melody</code> 文档都支持中文，更方便了，赶紧搞起～</p>\n<p><strong>参考：</strong></p>\n<ol>\n<li><a href=\"https://hexo.io/zh-cn/docs\">https://hexo.io/zh-cn/docs</a></li>\n<li><a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></li>\n<li><a href=\"https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html\">https://molunerfinn.com/hexo-theme-melody-doc/zh-Hans/quick-start.html</a></li>\n<li><a href=\"https://dmaker1993.github.io/\">https://dmaker1993.github.io/</a></li>\n</ol>\n<hr>\n<p>欢迎浏览我的更多文章：<a href=\"https://dmaker1993.github.io/\">一名不愿透露姓名的程序员</a> 或者  <a href=\"https://dmaker1993.github.io/\">https://dmaker1993.github.io</a></p>\n<p>最后：因小的才疏学浅，如有问题，请不吝指出，感谢感谢～</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckxmyxe9m0001cjs65kd96hvf","category_id":"ckxmyxe9p0004cjs65fwk0rf4","_id":"ckxmyxe9r0009cjs66pu80d8e"},{"post_id":"ckxmyxe9o0003cjs64sose9qg","category_id":"ckxmyxe9p0004cjs65fwk0rf4","_id":"ckxmyxe9r000bcjs67bmj8zl1"},{"post_id":"ckxo72x9o000083s6c1si9iui","category_id":"ckxoafk1f0000l0s62qgi7dvc","_id":"ckxoafk1g0003l0s61dl78ull"}],"PostTag":[{"post_id":"ckxmyxe9m0001cjs65kd96hvf","tag_id":"ckxmyxe9q0005cjs6g9gv3mq2","_id":"ckxmyxe9r000dcjs6b1decelk"},{"post_id":"ckxmyxe9m0001cjs65kd96hvf","tag_id":"ckxmyxe9q0008cjs6djfiesrb","_id":"ckxmyxe9r000ecjs6b32zfaef"},{"post_id":"ckxmyxe9m0001cjs65kd96hvf","tag_id":"ckxmyxe9r000acjs63wbbg5rz","_id":"ckxmyxe9s000gcjs65ow0advz"},{"post_id":"ckxmyxe9o0003cjs64sose9qg","tag_id":"ckxmyxe9q0005cjs6g9gv3mq2","_id":"ckxmyxe9s000hcjs6a4t51juh"},{"post_id":"ckxmyxe9o0003cjs64sose9qg","tag_id":"ckxmyxe9r000acjs63wbbg5rz","_id":"ckxmyxe9s000icjs6e6232dio"},{"post_id":"ckxo72x9o000083s6c1si9iui","tag_id":"ckxo785jg000196s6htsya9s5","_id":"ckxo785jh000396s67y52eg0p"},{"post_id":"ckxo72x9o000083s6c1si9iui","tag_id":"ckxoafk1g0001l0s68qeo9nj6","_id":"ckxoafk1g0002l0s64tvz7457"}],"Tag":[{"name":"中间件","_id":"ckxmyxe9q0005cjs6g9gv3mq2"},{"name":"集群","_id":"ckxmyxe9q0008cjs6djfiesrb"},{"name":"RabbitMQ","_id":"ckxmyxe9r000acjs63wbbg5rz"},{"name":"工具","_id":"ckxo785je000096s6a1ns0zfz"},{"name":"博客系统","_id":"ckxo785jg000196s6htsya9s5"},{"name":"经验","_id":"ckxoafk1g0001l0s68qeo9nj6"}]}}